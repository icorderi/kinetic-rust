// This file is generated. Do not edit

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]
#![allow(non_snake_case)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[deriving(Clone,Default)]
pub struct Local {
    protocolVersion: ::protobuf::SingularField<::std::string::String>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Local {
    pub fn new() -> Local {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Local {
        static mut instance: ::protobuf::lazy::Lazy<Local> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Local,
        };
        unsafe {
            instance.get(|| {
                Local {
                    protocolVersion: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string protocolVersion = 1;

    pub fn clear_protocolVersion(&mut self) {
        self.protocolVersion.clear();
    }

    pub fn has_protocolVersion(&self) -> bool {
        self.protocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocolVersion(&mut self, v: ::std::string::String) {
        self.protocolVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolVersion(&'a mut self) -> &'a mut ::std::string::String {
        if self.protocolVersion.is_none() {
            self.protocolVersion.set_default();
        };
        self.protocolVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocolVersion(&mut self) -> ::std::string::String {
        self.protocolVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocolVersion(&'a self) -> &'a str {
        match self.protocolVersion.as_ref() {
            Some(v) => v.as_slice(),
            None => "3.0.5",
        }
    }
}

impl ::protobuf::Message for Local {
    fn new() -> Local {
        Local::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.protocolVersion.set_default();
                    try!(is.read_string_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.protocolVersion.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.protocolVersion.as_ref() {
            Some(v) => {
                try!(os.write_string(1, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Local>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Local>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Local_protocolVersion_acc as &'static ::protobuf::reflect::FieldAccessor<Local>) });
                ::protobuf::reflect::MessageDescriptor::new::<Local>(
                    "Local",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Local>()
    }
}

impl ::protobuf::Clear for Local {
    fn clear(&mut self) {
        self.clear_protocolVersion();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Local {
    fn eq(&self, other: &Local) -> bool {
        self.protocolVersion == other.protocolVersion &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Local {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Local_protocolVersion_acc_type;
static Local_protocolVersion_acc: Local_protocolVersion_acc_type = Local_protocolVersion_acc_type;

impl ::protobuf::reflect::FieldAccessor<Local> for Local_protocolVersion_acc_type {
    fn name(&self) -> &'static str {
        "protocolVersion"
    }

    fn has_field(&self, m: &Local) -> bool {
        m.has_protocolVersion()
    }

    fn get_str<'a>(&self, m: &'a Local) -> &'a str {
        m.get_protocolVersion()
    }
}

#[deriving(Clone,Default)]
pub struct Message {
    authType: ::std::option::Option<Message_AuthType>,
    hmacAuth: ::protobuf::SingularPtrField<Message_HMACauth>,
    pinAuth: ::protobuf::SingularPtrField<Message_PINauth>,
    commandBytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Message,
        };
        unsafe {
            instance.get(|| {
                Message {
                    authType: ::std::option::None,
                    hmacAuth: ::protobuf::SingularPtrField::none(),
                    pinAuth: ::protobuf::SingularPtrField::none(),
                    commandBytes: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .com.seagate.kinetic.proto.Message.AuthType authType = 4;

    pub fn clear_authType(&mut self) {
        self.authType = ::std::option::None;
    }

    pub fn has_authType(&self) -> bool {
        self.authType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authType(&mut self, v: Message_AuthType) {
        self.authType = ::std::option::Some(v);
    }

    pub fn get_authType(&self) -> Message_AuthType {
        self.authType.unwrap_or(Message_AuthType::INVALID_AUTH_TYPE)
    }

    // optional .com.seagate.kinetic.proto.Message.HMACauth hmacAuth = 5;

    pub fn clear_hmacAuth(&mut self) {
        self.hmacAuth.clear();
    }

    pub fn has_hmacAuth(&self) -> bool {
        self.hmacAuth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hmacAuth(&mut self, v: Message_HMACauth) {
        self.hmacAuth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hmacAuth(&'a mut self) -> &'a mut Message_HMACauth {
        if self.hmacAuth.is_none() {
            self.hmacAuth.set_default();
        };
        self.hmacAuth.as_mut().unwrap()
    }

    // Take field
    pub fn take_hmacAuth(&mut self) -> Message_HMACauth {
        self.hmacAuth.take().unwrap_or_else(|| Message_HMACauth::new())
    }

    pub fn get_hmacAuth(&'a self) -> &'a Message_HMACauth {
        self.hmacAuth.as_ref().unwrap_or_else(|| Message_HMACauth::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Message.PINauth pinAuth = 6;

    pub fn clear_pinAuth(&mut self) {
        self.pinAuth.clear();
    }

    pub fn has_pinAuth(&self) -> bool {
        self.pinAuth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinAuth(&mut self, v: Message_PINauth) {
        self.pinAuth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pinAuth(&'a mut self) -> &'a mut Message_PINauth {
        if self.pinAuth.is_none() {
            self.pinAuth.set_default();
        };
        self.pinAuth.as_mut().unwrap()
    }

    // Take field
    pub fn take_pinAuth(&mut self) -> Message_PINauth {
        self.pinAuth.take().unwrap_or_else(|| Message_PINauth::new())
    }

    pub fn get_pinAuth(&'a self) -> &'a Message_PINauth {
        self.pinAuth.as_ref().unwrap_or_else(|| Message_PINauth::default_instance())
    }

    // optional bytes commandBytes = 7;

    pub fn clear_commandBytes(&mut self) {
        self.commandBytes.clear();
    }

    pub fn has_commandBytes(&self) -> bool {
        self.commandBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commandBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.commandBytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commandBytes(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.commandBytes.is_none() {
            self.commandBytes.set_default();
        };
        self.commandBytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_commandBytes(&mut self) -> ::std::vec::Vec<u8> {
        self.commandBytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_commandBytes(&'a self) -> &'a [u8] {
        match self.commandBytes.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for Message {
    fn new() -> Message {
        Message::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.authType = ::std::option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hmacAuth.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.pinAuth.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.commandBytes.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.authType.iter() {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        for value in self.hmacAuth.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.pinAuth.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.commandBytes.iter() {
            my_size += ::protobuf::rt::bytes_size(7, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.authType {
            Some(v) => {
                try!(os.write_enum(4, v as i32));
            },
            None => {},
        };
        match self.hmacAuth.as_ref() {
            Some(v) => {
                try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.pinAuth.as_ref() {
            Some(v) => {
                try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.commandBytes.as_ref() {
            Some(v) => {
                try!(os.write_bytes(7, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Message>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Message>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Message_authType_acc as &'static ::protobuf::reflect::FieldAccessor<Message>) });
                fields.push(unsafe { ::std::mem::transmute(&Message_hmacAuth_acc as &'static ::protobuf::reflect::FieldAccessor<Message>) });
                fields.push(unsafe { ::std::mem::transmute(&Message_pinAuth_acc as &'static ::protobuf::reflect::FieldAccessor<Message>) });
                fields.push(unsafe { ::std::mem::transmute(&Message_commandBytes_acc as &'static ::protobuf::reflect::FieldAccessor<Message>) });
                ::protobuf::reflect::MessageDescriptor::new::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Message>()
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.clear_authType();
        self.clear_hmacAuth();
        self.clear_pinAuth();
        self.clear_commandBytes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Message {
    fn eq(&self, other: &Message) -> bool {
        self.authType == other.authType &&
        self.hmacAuth == other.hmacAuth &&
        self.pinAuth == other.pinAuth &&
        self.commandBytes == other.commandBytes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Message_authType_acc_type;
static Message_authType_acc: Message_authType_acc_type = Message_authType_acc_type;

impl ::protobuf::reflect::FieldAccessor<Message> for Message_authType_acc_type {
    fn name(&self) -> &'static str {
        "authType"
    }

    fn has_field(&self, m: &Message) -> bool {
        m.has_authType()
    }

    fn get_enum<'a>(&self, m: &Message) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_authType().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Message_hmacAuth_acc_type;
static Message_hmacAuth_acc: Message_hmacAuth_acc_type = Message_hmacAuth_acc_type;

impl ::protobuf::reflect::FieldAccessor<Message> for Message_hmacAuth_acc_type {
    fn name(&self) -> &'static str {
        "hmacAuth"
    }

    fn has_field(&self, m: &Message) -> bool {
        m.has_hmacAuth()
    }

    fn get_message<'a>(&self, m: &'a Message) -> &'a ::protobuf::Message {
        m.get_hmacAuth() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Message_pinAuth_acc_type;
static Message_pinAuth_acc: Message_pinAuth_acc_type = Message_pinAuth_acc_type;

impl ::protobuf::reflect::FieldAccessor<Message> for Message_pinAuth_acc_type {
    fn name(&self) -> &'static str {
        "pinAuth"
    }

    fn has_field(&self, m: &Message) -> bool {
        m.has_pinAuth()
    }

    fn get_message<'a>(&self, m: &'a Message) -> &'a ::protobuf::Message {
        m.get_pinAuth() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Message_commandBytes_acc_type;
static Message_commandBytes_acc: Message_commandBytes_acc_type = Message_commandBytes_acc_type;

impl ::protobuf::reflect::FieldAccessor<Message> for Message_commandBytes_acc_type {
    fn name(&self) -> &'static str {
        "commandBytes"
    }

    fn has_field(&self, m: &Message) -> bool {
        m.has_commandBytes()
    }

    fn get_bytes<'a>(&self, m: &'a Message) -> &'a [u8] {
        m.get_commandBytes()
    }
}

#[deriving(Clone,Default)]
pub struct Message_HMACauth {
    identity: ::std::option::Option<i64>,
    hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Message_HMACauth {
    pub fn new() -> Message_HMACauth {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Message_HMACauth {
        static mut instance: ::protobuf::lazy::Lazy<Message_HMACauth> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Message_HMACauth,
        };
        unsafe {
            instance.get(|| {
                Message_HMACauth {
                    identity: ::std::option::None,
                    hmac: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 identity = 1;

    pub fn clear_identity(&mut self) {
        self.identity = ::std::option::None;
    }

    pub fn has_identity(&self) -> bool {
        self.identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: i64) {
        self.identity = ::std::option::Some(v);
    }

    pub fn get_identity(&self) -> i64 {
        self.identity.unwrap_or(0)
    }

    // optional bytes hmac = 2;

    pub fn clear_hmac(&mut self) {
        self.hmac.clear();
    }

    pub fn has_hmac(&self) -> bool {
        self.hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hmac(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.hmac.is_none() {
            self.hmac.set_default();
        };
        self.hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_hmac(&'a self) -> &'a [u8] {
        match self.hmac.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for Message_HMACauth {
    fn new() -> Message_HMACauth {
        Message_HMACauth::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.identity = ::std::option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hmac.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.identity.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.hmac.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.identity {
            Some(v) => {
                try!(os.write_int64(1, v));
            },
            None => {},
        };
        match self.hmac.as_ref() {
            Some(v) => {
                try!(os.write_bytes(2, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Message_HMACauth>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Message_HMACauth>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Message_HMACauth_identity_acc as &'static ::protobuf::reflect::FieldAccessor<Message_HMACauth>) });
                fields.push(unsafe { ::std::mem::transmute(&Message_HMACauth_hmac_acc as &'static ::protobuf::reflect::FieldAccessor<Message_HMACauth>) });
                ::protobuf::reflect::MessageDescriptor::new::<Message_HMACauth>(
                    "Message_HMACauth",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Message_HMACauth>()
    }
}

impl ::protobuf::Clear for Message_HMACauth {
    fn clear(&mut self) {
        self.clear_identity();
        self.clear_hmac();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Message_HMACauth {
    fn eq(&self, other: &Message_HMACauth) -> bool {
        self.identity == other.identity &&
        self.hmac == other.hmac &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Message_HMACauth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Message_HMACauth_identity_acc_type;
static Message_HMACauth_identity_acc: Message_HMACauth_identity_acc_type = Message_HMACauth_identity_acc_type;

impl ::protobuf::reflect::FieldAccessor<Message_HMACauth> for Message_HMACauth_identity_acc_type {
    fn name(&self) -> &'static str {
        "identity"
    }

    fn has_field(&self, m: &Message_HMACauth) -> bool {
        m.has_identity()
    }

    fn get_i64(&self, m: &Message_HMACauth) -> i64 {
        m.get_identity()
    }
}

#[allow(non_camel_case_types)]
struct Message_HMACauth_hmac_acc_type;
static Message_HMACauth_hmac_acc: Message_HMACauth_hmac_acc_type = Message_HMACauth_hmac_acc_type;

impl ::protobuf::reflect::FieldAccessor<Message_HMACauth> for Message_HMACauth_hmac_acc_type {
    fn name(&self) -> &'static str {
        "hmac"
    }

    fn has_field(&self, m: &Message_HMACauth) -> bool {
        m.has_hmac()
    }

    fn get_bytes<'a>(&self, m: &'a Message_HMACauth) -> &'a [u8] {
        m.get_hmac()
    }
}

#[deriving(Clone,Default)]
pub struct Message_PINauth {
    pin: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Message_PINauth {
    pub fn new() -> Message_PINauth {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Message_PINauth {
        static mut instance: ::protobuf::lazy::Lazy<Message_PINauth> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Message_PINauth,
        };
        unsafe {
            instance.get(|| {
                Message_PINauth {
                    pin: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes pin = 1;

    pub fn clear_pin(&mut self) {
        self.pin.clear();
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::vec::Vec<u8>) {
        self.pin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.pin.is_none() {
            self.pin.set_default();
        };
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::vec::Vec<u8> {
        self.pin.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_pin(&'a self) -> &'a [u8] {
        match self.pin.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for Message_PINauth {
    fn new() -> Message_PINauth {
        Message_PINauth::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.pin.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.pin.iter() {
            my_size += ::protobuf::rt::bytes_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.pin.as_ref() {
            Some(v) => {
                try!(os.write_bytes(1, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Message_PINauth>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Message_PINauth>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Message_PINauth_pin_acc as &'static ::protobuf::reflect::FieldAccessor<Message_PINauth>) });
                ::protobuf::reflect::MessageDescriptor::new::<Message_PINauth>(
                    "Message_PINauth",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Message_PINauth>()
    }
}

impl ::protobuf::Clear for Message_PINauth {
    fn clear(&mut self) {
        self.clear_pin();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Message_PINauth {
    fn eq(&self, other: &Message_PINauth) -> bool {
        self.pin == other.pin &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Message_PINauth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Message_PINauth_pin_acc_type;
static Message_PINauth_pin_acc: Message_PINauth_pin_acc_type = Message_PINauth_pin_acc_type;

impl ::protobuf::reflect::FieldAccessor<Message_PINauth> for Message_PINauth_pin_acc_type {
    fn name(&self) -> &'static str {
        "pin"
    }

    fn has_field(&self, m: &Message_PINauth) -> bool {
        m.has_pin()
    }

    fn get_bytes<'a>(&self, m: &'a Message_PINauth) -> &'a [u8] {
        m.get_pin()
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Message_AuthType {
    INVALID_AUTH_TYPE = -1,
    HMACAUTH = 1,
    PINAUTH = 2,
    UNSOLICITEDSTATUS = 3,
}


impl ::protobuf::ProtobufEnum for Message_AuthType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Message_AuthType> {
        match value {
            -1 => ::std::option::Some(Message_AuthType::INVALID_AUTH_TYPE),
            1 => ::std::option::Some(Message_AuthType::HMACAUTH),
            2 => ::std::option::Some(Message_AuthType::PINAUTH),
            3 => ::std::option::Some(Message_AuthType::UNSOLICITEDSTATUS),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Message_AuthType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Message_AuthType", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,Default)]
pub struct Command {
    header: ::protobuf::SingularPtrField<Command_Header>,
    body: ::protobuf::SingularPtrField<Command_Body>,
    status: ::protobuf::SingularPtrField<Command_Status>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command {
    pub fn new() -> Command {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command {
        static mut instance: ::protobuf::lazy::Lazy<Command> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command,
        };
        unsafe {
            instance.get(|| {
                Command {
                    header: ::protobuf::SingularPtrField::none(),
                    body: ::protobuf::SingularPtrField::none(),
                    status: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .com.seagate.kinetic.proto.Command.Header header = 1;

    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Command_Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&'a mut self) -> &'a mut Command_Header {
        if self.header.is_none() {
            self.header.set_default();
        };
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Command_Header {
        self.header.take().unwrap_or_else(|| Command_Header::new())
    }

    pub fn get_header(&'a self) -> &'a Command_Header {
        self.header.as_ref().unwrap_or_else(|| Command_Header::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.Body body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: Command_Body) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&'a mut self) -> &'a mut Command_Body {
        if self.body.is_none() {
            self.body.set_default();
        };
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> Command_Body {
        self.body.take().unwrap_or_else(|| Command_Body::new())
    }

    pub fn get_body(&'a self) -> &'a Command_Body {
        self.body.as_ref().unwrap_or_else(|| Command_Body::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.Status status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Command_Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&'a mut self) -> &'a mut Command_Status {
        if self.status.is_none() {
            self.status.set_default();
        };
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> Command_Status {
        self.status.take().unwrap_or_else(|| Command_Status::new())
    }

    pub fn get_status(&'a self) -> &'a Command_Status {
        self.status.as_ref().unwrap_or_else(|| Command_Status::default_instance())
    }
}

impl ::protobuf::Message for Command {
    fn new() -> Command {
        Command::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.header.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.body.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.status.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.header.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.body.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.status.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.header.as_ref() {
            Some(v) => {
                try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.body.as_ref() {
            Some(v) => {
                try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.status.as_ref() {
            Some(v) => {
                try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_header_acc as &'static ::protobuf::reflect::FieldAccessor<Command>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_body_acc as &'static ::protobuf::reflect::FieldAccessor<Command>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_status_acc as &'static ::protobuf::reflect::FieldAccessor<Command>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command>(
                    "Command",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command>()
    }
}

impl ::protobuf::Clear for Command {
    fn clear(&mut self) {
        self.clear_header();
        self.clear_body();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command {
    fn eq(&self, other: &Command) -> bool {
        self.header == other.header &&
        self.body == other.body &&
        self.status == other.status &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_header_acc_type;
static Command_header_acc: Command_header_acc_type = Command_header_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command> for Command_header_acc_type {
    fn name(&self) -> &'static str {
        "header"
    }

    fn has_field(&self, m: &Command) -> bool {
        m.has_header()
    }

    fn get_message<'a>(&self, m: &'a Command) -> &'a ::protobuf::Message {
        m.get_header() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_body_acc_type;
static Command_body_acc: Command_body_acc_type = Command_body_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command> for Command_body_acc_type {
    fn name(&self) -> &'static str {
        "body"
    }

    fn has_field(&self, m: &Command) -> bool {
        m.has_body()
    }

    fn get_message<'a>(&self, m: &'a Command) -> &'a ::protobuf::Message {
        m.get_body() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_status_acc_type;
static Command_status_acc: Command_status_acc_type = Command_status_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command> for Command_status_acc_type {
    fn name(&self) -> &'static str {
        "status"
    }

    fn has_field(&self, m: &Command) -> bool {
        m.has_status()
    }

    fn get_message<'a>(&self, m: &'a Command) -> &'a ::protobuf::Message {
        m.get_status() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,Default)]
pub struct Command_Header {
    clusterVersion: ::std::option::Option<i64>,
    connectionID: ::std::option::Option<i64>,
    sequence: ::std::option::Option<i64>,
    ackSequence: ::std::option::Option<i64>,
    messageType: ::std::option::Option<Command_MessageType>,
    timeout: ::std::option::Option<i64>,
    earlyExit: ::std::option::Option<bool>,
    priority: ::std::option::Option<Command_Priority>,
    TimeQuanta: ::std::option::Option<i64>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_Header {
    pub fn new() -> Command_Header {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_Header {
        static mut instance: ::protobuf::lazy::Lazy<Command_Header> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_Header,
        };
        unsafe {
            instance.get(|| {
                Command_Header {
                    clusterVersion: ::std::option::None,
                    connectionID: ::std::option::None,
                    sequence: ::std::option::None,
                    ackSequence: ::std::option::None,
                    messageType: ::std::option::None,
                    timeout: ::std::option::None,
                    earlyExit: ::std::option::None,
                    priority: ::std::option::None,
                    TimeQuanta: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 clusterVersion = 1;

    pub fn clear_clusterVersion(&mut self) {
        self.clusterVersion = ::std::option::None;
    }

    pub fn has_clusterVersion(&self) -> bool {
        self.clusterVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterVersion(&mut self, v: i64) {
        self.clusterVersion = ::std::option::Some(v);
    }

    pub fn get_clusterVersion(&self) -> i64 {
        self.clusterVersion.unwrap_or(0)
    }

    // optional int64 connectionID = 3;

    pub fn clear_connectionID(&mut self) {
        self.connectionID = ::std::option::None;
    }

    pub fn has_connectionID(&self) -> bool {
        self.connectionID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectionID(&mut self, v: i64) {
        self.connectionID = ::std::option::Some(v);
    }

    pub fn get_connectionID(&self) -> i64 {
        self.connectionID.unwrap_or(0)
    }

    // optional int64 sequence = 4;

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: i64) {
        self.sequence = ::std::option::Some(v);
    }

    pub fn get_sequence(&self) -> i64 {
        self.sequence.unwrap_or(0)
    }

    // optional int64 ackSequence = 6;

    pub fn clear_ackSequence(&mut self) {
        self.ackSequence = ::std::option::None;
    }

    pub fn has_ackSequence(&self) -> bool {
        self.ackSequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ackSequence(&mut self, v: i64) {
        self.ackSequence = ::std::option::Some(v);
    }

    pub fn get_ackSequence(&self) -> i64 {
        self.ackSequence.unwrap_or(0)
    }

    // optional .com.seagate.kinetic.proto.Command.MessageType messageType = 7;

    pub fn clear_messageType(&mut self) {
        self.messageType = ::std::option::None;
    }

    pub fn has_messageType(&self) -> bool {
        self.messageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageType(&mut self, v: Command_MessageType) {
        self.messageType = ::std::option::Some(v);
    }

    pub fn get_messageType(&self) -> Command_MessageType {
        self.messageType.unwrap_or(Command_MessageType::INVALID_MESSAGE_TYPE)
    }

    // optional int64 timeout = 9;

    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: i64) {
        self.timeout = ::std::option::Some(v);
    }

    pub fn get_timeout(&self) -> i64 {
        self.timeout.unwrap_or(0)
    }

    // optional bool earlyExit = 10;

    pub fn clear_earlyExit(&mut self) {
        self.earlyExit = ::std::option::None;
    }

    pub fn has_earlyExit(&self) -> bool {
        self.earlyExit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_earlyExit(&mut self, v: bool) {
        self.earlyExit = ::std::option::Some(v);
    }

    pub fn get_earlyExit(&self) -> bool {
        self.earlyExit.unwrap_or(false)
    }

    // optional .com.seagate.kinetic.proto.Command.Priority priority = 12;

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: Command_Priority) {
        self.priority = ::std::option::Some(v);
    }

    pub fn get_priority(&self) -> Command_Priority {
        self.priority.unwrap_or(Command_Priority::NORMAL)
    }

    // optional int64 TimeQuanta = 13;

    pub fn clear_TimeQuanta(&mut self) {
        self.TimeQuanta = ::std::option::None;
    }

    pub fn has_TimeQuanta(&self) -> bool {
        self.TimeQuanta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TimeQuanta(&mut self, v: i64) {
        self.TimeQuanta = ::std::option::Some(v);
    }

    pub fn get_TimeQuanta(&self) -> i64 {
        self.TimeQuanta.unwrap_or(0)
    }
}

impl ::protobuf::Message for Command_Header {
    fn new() -> Command_Header {
        Command_Header::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.clusterVersion = ::std::option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.connectionID = ::std::option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.sequence = ::std::option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.ackSequence = ::std::option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.messageType = ::std::option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.timeout = ::std::option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.earlyExit = ::std::option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.priority = ::std::option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.TimeQuanta = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.clusterVersion.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.connectionID.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sequence.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ackSequence.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.messageType.iter() {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        for value in self.timeout.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.earlyExit.is_some() {
            my_size += 2;
        };
        for value in self.priority.iter() {
            my_size += ::protobuf::rt::enum_size(12, *value);
        };
        for value in self.TimeQuanta.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.clusterVersion {
            Some(v) => {
                try!(os.write_int64(1, v));
            },
            None => {},
        };
        match self.connectionID {
            Some(v) => {
                try!(os.write_int64(3, v));
            },
            None => {},
        };
        match self.sequence {
            Some(v) => {
                try!(os.write_int64(4, v));
            },
            None => {},
        };
        match self.ackSequence {
            Some(v) => {
                try!(os.write_int64(6, v));
            },
            None => {},
        };
        match self.messageType {
            Some(v) => {
                try!(os.write_enum(7, v as i32));
            },
            None => {},
        };
        match self.timeout {
            Some(v) => {
                try!(os.write_int64(9, v));
            },
            None => {},
        };
        match self.earlyExit {
            Some(v) => {
                try!(os.write_bool(10, v));
            },
            None => {},
        };
        match self.priority {
            Some(v) => {
                try!(os.write_enum(12, v as i32));
            },
            None => {},
        };
        match self.TimeQuanta {
            Some(v) => {
                try!(os.write_int64(13, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_Header>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_Header>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_clusterVersion_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_connectionID_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_sequence_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_ackSequence_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_messageType_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_timeout_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_earlyExit_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_priority_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Header_TimeQuanta_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Header>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_Header>(
                    "Command_Header",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_Header>()
    }
}

impl ::protobuf::Clear for Command_Header {
    fn clear(&mut self) {
        self.clear_clusterVersion();
        self.clear_connectionID();
        self.clear_sequence();
        self.clear_ackSequence();
        self.clear_messageType();
        self.clear_timeout();
        self.clear_earlyExit();
        self.clear_priority();
        self.clear_TimeQuanta();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_Header {
    fn eq(&self, other: &Command_Header) -> bool {
        self.clusterVersion == other.clusterVersion &&
        self.connectionID == other.connectionID &&
        self.sequence == other.sequence &&
        self.ackSequence == other.ackSequence &&
        self.messageType == other.messageType &&
        self.timeout == other.timeout &&
        self.earlyExit == other.earlyExit &&
        self.priority == other.priority &&
        self.TimeQuanta == other.TimeQuanta &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_Header_clusterVersion_acc_type;
static Command_Header_clusterVersion_acc: Command_Header_clusterVersion_acc_type = Command_Header_clusterVersion_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_clusterVersion_acc_type {
    fn name(&self) -> &'static str {
        "clusterVersion"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_clusterVersion()
    }

    fn get_i64(&self, m: &Command_Header) -> i64 {
        m.get_clusterVersion()
    }
}

#[allow(non_camel_case_types)]
struct Command_Header_connectionID_acc_type;
static Command_Header_connectionID_acc: Command_Header_connectionID_acc_type = Command_Header_connectionID_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_connectionID_acc_type {
    fn name(&self) -> &'static str {
        "connectionID"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_connectionID()
    }

    fn get_i64(&self, m: &Command_Header) -> i64 {
        m.get_connectionID()
    }
}

#[allow(non_camel_case_types)]
struct Command_Header_sequence_acc_type;
static Command_Header_sequence_acc: Command_Header_sequence_acc_type = Command_Header_sequence_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_sequence_acc_type {
    fn name(&self) -> &'static str {
        "sequence"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_sequence()
    }

    fn get_i64(&self, m: &Command_Header) -> i64 {
        m.get_sequence()
    }
}

#[allow(non_camel_case_types)]
struct Command_Header_ackSequence_acc_type;
static Command_Header_ackSequence_acc: Command_Header_ackSequence_acc_type = Command_Header_ackSequence_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_ackSequence_acc_type {
    fn name(&self) -> &'static str {
        "ackSequence"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_ackSequence()
    }

    fn get_i64(&self, m: &Command_Header) -> i64 {
        m.get_ackSequence()
    }
}

#[allow(non_camel_case_types)]
struct Command_Header_messageType_acc_type;
static Command_Header_messageType_acc: Command_Header_messageType_acc_type = Command_Header_messageType_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_messageType_acc_type {
    fn name(&self) -> &'static str {
        "messageType"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_messageType()
    }

    fn get_enum<'a>(&self, m: &Command_Header) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_messageType().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Command_Header_timeout_acc_type;
static Command_Header_timeout_acc: Command_Header_timeout_acc_type = Command_Header_timeout_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_timeout_acc_type {
    fn name(&self) -> &'static str {
        "timeout"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_timeout()
    }

    fn get_i64(&self, m: &Command_Header) -> i64 {
        m.get_timeout()
    }
}

#[allow(non_camel_case_types)]
struct Command_Header_earlyExit_acc_type;
static Command_Header_earlyExit_acc: Command_Header_earlyExit_acc_type = Command_Header_earlyExit_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_earlyExit_acc_type {
    fn name(&self) -> &'static str {
        "earlyExit"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_earlyExit()
    }

    fn get_bool(&self, m: &Command_Header) -> bool {
        m.get_earlyExit()
    }
}

#[allow(non_camel_case_types)]
struct Command_Header_priority_acc_type;
static Command_Header_priority_acc: Command_Header_priority_acc_type = Command_Header_priority_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_priority_acc_type {
    fn name(&self) -> &'static str {
        "priority"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_priority()
    }

    fn get_enum<'a>(&self, m: &Command_Header) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_priority().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Command_Header_TimeQuanta_acc_type;
static Command_Header_TimeQuanta_acc: Command_Header_TimeQuanta_acc_type = Command_Header_TimeQuanta_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Header> for Command_Header_TimeQuanta_acc_type {
    fn name(&self) -> &'static str {
        "TimeQuanta"
    }

    fn has_field(&self, m: &Command_Header) -> bool {
        m.has_TimeQuanta()
    }

    fn get_i64(&self, m: &Command_Header) -> i64 {
        m.get_TimeQuanta()
    }
}

#[deriving(Clone,Default)]
pub struct Command_Body {
    keyValue: ::protobuf::SingularPtrField<Command_KeyValue>,
    range: ::protobuf::SingularPtrField<Command_Range>,
    setup: ::protobuf::SingularPtrField<Command_Setup>,
    p2pOperation: ::protobuf::SingularPtrField<Command_P2POperation>,
    getLog: ::protobuf::SingularPtrField<Command_GetLog>,
    security: ::protobuf::SingularPtrField<Command_Security>,
    pinOp: ::protobuf::SingularPtrField<Command_PinOperation>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_Body {
    pub fn new() -> Command_Body {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_Body {
        static mut instance: ::protobuf::lazy::Lazy<Command_Body> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_Body,
        };
        unsafe {
            instance.get(|| {
                Command_Body {
                    keyValue: ::protobuf::SingularPtrField::none(),
                    range: ::protobuf::SingularPtrField::none(),
                    setup: ::protobuf::SingularPtrField::none(),
                    p2pOperation: ::protobuf::SingularPtrField::none(),
                    getLog: ::protobuf::SingularPtrField::none(),
                    security: ::protobuf::SingularPtrField::none(),
                    pinOp: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .com.seagate.kinetic.proto.Command.KeyValue keyValue = 1;

    pub fn clear_keyValue(&mut self) {
        self.keyValue.clear();
    }

    pub fn has_keyValue(&self) -> bool {
        self.keyValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyValue(&mut self, v: Command_KeyValue) {
        self.keyValue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyValue(&'a mut self) -> &'a mut Command_KeyValue {
        if self.keyValue.is_none() {
            self.keyValue.set_default();
        };
        self.keyValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyValue(&mut self) -> Command_KeyValue {
        self.keyValue.take().unwrap_or_else(|| Command_KeyValue::new())
    }

    pub fn get_keyValue(&'a self) -> &'a Command_KeyValue {
        self.keyValue.as_ref().unwrap_or_else(|| Command_KeyValue::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.Range range = 2;

    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Command_Range) {
        self.range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&'a mut self) -> &'a mut Command_Range {
        if self.range.is_none() {
            self.range.set_default();
        };
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> Command_Range {
        self.range.take().unwrap_or_else(|| Command_Range::new())
    }

    pub fn get_range(&'a self) -> &'a Command_Range {
        self.range.as_ref().unwrap_or_else(|| Command_Range::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.Setup setup = 3;

    pub fn clear_setup(&mut self) {
        self.setup.clear();
    }

    pub fn has_setup(&self) -> bool {
        self.setup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setup(&mut self, v: Command_Setup) {
        self.setup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setup(&'a mut self) -> &'a mut Command_Setup {
        if self.setup.is_none() {
            self.setup.set_default();
        };
        self.setup.as_mut().unwrap()
    }

    // Take field
    pub fn take_setup(&mut self) -> Command_Setup {
        self.setup.take().unwrap_or_else(|| Command_Setup::new())
    }

    pub fn get_setup(&'a self) -> &'a Command_Setup {
        self.setup.as_ref().unwrap_or_else(|| Command_Setup::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.P2POperation p2pOperation = 4;

    pub fn clear_p2pOperation(&mut self) {
        self.p2pOperation.clear();
    }

    pub fn has_p2pOperation(&self) -> bool {
        self.p2pOperation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2pOperation(&mut self, v: Command_P2POperation) {
        self.p2pOperation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2pOperation(&'a mut self) -> &'a mut Command_P2POperation {
        if self.p2pOperation.is_none() {
            self.p2pOperation.set_default();
        };
        self.p2pOperation.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2pOperation(&mut self) -> Command_P2POperation {
        self.p2pOperation.take().unwrap_or_else(|| Command_P2POperation::new())
    }

    pub fn get_p2pOperation(&'a self) -> &'a Command_P2POperation {
        self.p2pOperation.as_ref().unwrap_or_else(|| Command_P2POperation::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.GetLog getLog = 6;

    pub fn clear_getLog(&mut self) {
        self.getLog.clear();
    }

    pub fn has_getLog(&self) -> bool {
        self.getLog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLog(&mut self, v: Command_GetLog) {
        self.getLog = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLog(&'a mut self) -> &'a mut Command_GetLog {
        if self.getLog.is_none() {
            self.getLog.set_default();
        };
        self.getLog.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLog(&mut self) -> Command_GetLog {
        self.getLog.take().unwrap_or_else(|| Command_GetLog::new())
    }

    pub fn get_getLog(&'a self) -> &'a Command_GetLog {
        self.getLog.as_ref().unwrap_or_else(|| Command_GetLog::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.Security security = 7;

    pub fn clear_security(&mut self) {
        self.security.clear();
    }

    pub fn has_security(&self) -> bool {
        self.security.is_some()
    }

    // Param is passed by value, moved
    pub fn set_security(&mut self, v: Command_Security) {
        self.security = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security(&'a mut self) -> &'a mut Command_Security {
        if self.security.is_none() {
            self.security.set_default();
        };
        self.security.as_mut().unwrap()
    }

    // Take field
    pub fn take_security(&mut self) -> Command_Security {
        self.security.take().unwrap_or_else(|| Command_Security::new())
    }

    pub fn get_security(&'a self) -> &'a Command_Security {
        self.security.as_ref().unwrap_or_else(|| Command_Security::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.PinOperation pinOp = 8;

    pub fn clear_pinOp(&mut self) {
        self.pinOp.clear();
    }

    pub fn has_pinOp(&self) -> bool {
        self.pinOp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinOp(&mut self, v: Command_PinOperation) {
        self.pinOp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pinOp(&'a mut self) -> &'a mut Command_PinOperation {
        if self.pinOp.is_none() {
            self.pinOp.set_default();
        };
        self.pinOp.as_mut().unwrap()
    }

    // Take field
    pub fn take_pinOp(&mut self) -> Command_PinOperation {
        self.pinOp.take().unwrap_or_else(|| Command_PinOperation::new())
    }

    pub fn get_pinOp(&'a self) -> &'a Command_PinOperation {
        self.pinOp.as_ref().unwrap_or_else(|| Command_PinOperation::default_instance())
    }
}

impl ::protobuf::Message for Command_Body {
    fn new() -> Command_Body {
        Command_Body::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.keyValue.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.range.set_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.setup.set_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.p2pOperation.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.getLog.set_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.security.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.pinOp.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.keyValue.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.range.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.setup.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.p2pOperation.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.getLog.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.security.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.pinOp.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.keyValue.as_ref() {
            Some(v) => {
                try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.range.as_ref() {
            Some(v) => {
                try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.setup.as_ref() {
            Some(v) => {
                try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.p2pOperation.as_ref() {
            Some(v) => {
                try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.getLog.as_ref() {
            Some(v) => {
                try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.security.as_ref() {
            Some(v) => {
                try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.pinOp.as_ref() {
            Some(v) => {
                try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_Body>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_Body>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_Body_keyValue_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Body>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Body_range_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Body>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Body_setup_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Body>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Body_p2pOperation_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Body>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Body_getLog_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Body>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Body_security_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Body>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Body_pinOp_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Body>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_Body>(
                    "Command_Body",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_Body>()
    }
}

impl ::protobuf::Clear for Command_Body {
    fn clear(&mut self) {
        self.clear_keyValue();
        self.clear_range();
        self.clear_setup();
        self.clear_p2pOperation();
        self.clear_getLog();
        self.clear_security();
        self.clear_pinOp();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_Body {
    fn eq(&self, other: &Command_Body) -> bool {
        self.keyValue == other.keyValue &&
        self.range == other.range &&
        self.setup == other.setup &&
        self.p2pOperation == other.p2pOperation &&
        self.getLog == other.getLog &&
        self.security == other.security &&
        self.pinOp == other.pinOp &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_Body {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_Body_keyValue_acc_type;
static Command_Body_keyValue_acc: Command_Body_keyValue_acc_type = Command_Body_keyValue_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Body> for Command_Body_keyValue_acc_type {
    fn name(&self) -> &'static str {
        "keyValue"
    }

    fn has_field(&self, m: &Command_Body) -> bool {
        m.has_keyValue()
    }

    fn get_message<'a>(&self, m: &'a Command_Body) -> &'a ::protobuf::Message {
        m.get_keyValue() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_Body_range_acc_type;
static Command_Body_range_acc: Command_Body_range_acc_type = Command_Body_range_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Body> for Command_Body_range_acc_type {
    fn name(&self) -> &'static str {
        "range"
    }

    fn has_field(&self, m: &Command_Body) -> bool {
        m.has_range()
    }

    fn get_message<'a>(&self, m: &'a Command_Body) -> &'a ::protobuf::Message {
        m.get_range() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_Body_setup_acc_type;
static Command_Body_setup_acc: Command_Body_setup_acc_type = Command_Body_setup_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Body> for Command_Body_setup_acc_type {
    fn name(&self) -> &'static str {
        "setup"
    }

    fn has_field(&self, m: &Command_Body) -> bool {
        m.has_setup()
    }

    fn get_message<'a>(&self, m: &'a Command_Body) -> &'a ::protobuf::Message {
        m.get_setup() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_Body_p2pOperation_acc_type;
static Command_Body_p2pOperation_acc: Command_Body_p2pOperation_acc_type = Command_Body_p2pOperation_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Body> for Command_Body_p2pOperation_acc_type {
    fn name(&self) -> &'static str {
        "p2pOperation"
    }

    fn has_field(&self, m: &Command_Body) -> bool {
        m.has_p2pOperation()
    }

    fn get_message<'a>(&self, m: &'a Command_Body) -> &'a ::protobuf::Message {
        m.get_p2pOperation() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_Body_getLog_acc_type;
static Command_Body_getLog_acc: Command_Body_getLog_acc_type = Command_Body_getLog_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Body> for Command_Body_getLog_acc_type {
    fn name(&self) -> &'static str {
        "getLog"
    }

    fn has_field(&self, m: &Command_Body) -> bool {
        m.has_getLog()
    }

    fn get_message<'a>(&self, m: &'a Command_Body) -> &'a ::protobuf::Message {
        m.get_getLog() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_Body_security_acc_type;
static Command_Body_security_acc: Command_Body_security_acc_type = Command_Body_security_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Body> for Command_Body_security_acc_type {
    fn name(&self) -> &'static str {
        "security"
    }

    fn has_field(&self, m: &Command_Body) -> bool {
        m.has_security()
    }

    fn get_message<'a>(&self, m: &'a Command_Body) -> &'a ::protobuf::Message {
        m.get_security() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_Body_pinOp_acc_type;
static Command_Body_pinOp_acc: Command_Body_pinOp_acc_type = Command_Body_pinOp_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Body> for Command_Body_pinOp_acc_type {
    fn name(&self) -> &'static str {
        "pinOp"
    }

    fn has_field(&self, m: &Command_Body) -> bool {
        m.has_pinOp()
    }

    fn get_message<'a>(&self, m: &'a Command_Body) -> &'a ::protobuf::Message {
        m.get_pinOp() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,Default)]
pub struct Command_Status {
    code: ::std::option::Option<Command_Status_StatusCode>,
    statusMessage: ::protobuf::SingularField<::std::string::String>,
    detailedMessage: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_Status {
    pub fn new() -> Command_Status {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_Status {
        static mut instance: ::protobuf::lazy::Lazy<Command_Status> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_Status,
        };
        unsafe {
            instance.get(|| {
                Command_Status {
                    code: ::std::option::None,
                    statusMessage: ::protobuf::SingularField::none(),
                    detailedMessage: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .com.seagate.kinetic.proto.Command.Status.StatusCode code = 1;

    pub fn clear_code(&mut self) {
        self.code = ::std::option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Command_Status_StatusCode) {
        self.code = ::std::option::Some(v);
    }

    pub fn get_code(&self) -> Command_Status_StatusCode {
        self.code.unwrap_or(Command_Status_StatusCode::INVALID_STATUS_CODE)
    }

    // optional string statusMessage = 2;

    pub fn clear_statusMessage(&mut self) {
        self.statusMessage.clear();
    }

    pub fn has_statusMessage(&self) -> bool {
        self.statusMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusMessage(&mut self, v: ::std::string::String) {
        self.statusMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statusMessage(&'a mut self) -> &'a mut ::std::string::String {
        if self.statusMessage.is_none() {
            self.statusMessage.set_default();
        };
        self.statusMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_statusMessage(&mut self) -> ::std::string::String {
        self.statusMessage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_statusMessage(&'a self) -> &'a str {
        match self.statusMessage.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional bytes detailedMessage = 3;

    pub fn clear_detailedMessage(&mut self) {
        self.detailedMessage.clear();
    }

    pub fn has_detailedMessage(&self) -> bool {
        self.detailedMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detailedMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.detailedMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detailedMessage(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.detailedMessage.is_none() {
            self.detailedMessage.set_default();
        };
        self.detailedMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_detailedMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.detailedMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_detailedMessage(&'a self) -> &'a [u8] {
        match self.detailedMessage.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for Command_Status {
    fn new() -> Command_Status {
        Command_Status::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.code = ::std::option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.statusMessage.set_default();
                    try!(is.read_string_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.detailedMessage.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.code.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.statusMessage.iter() {
            my_size += ::protobuf::rt::string_size(2, value.as_slice());
        };
        for value in self.detailedMessage.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.code {
            Some(v) => {
                try!(os.write_enum(1, v as i32));
            },
            None => {},
        };
        match self.statusMessage.as_ref() {
            Some(v) => {
                try!(os.write_string(2, v.as_slice()));
            },
            None => {},
        };
        match self.detailedMessage.as_ref() {
            Some(v) => {
                try!(os.write_bytes(3, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_Status>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_Status>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_Status_code_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Status>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Status_statusMessage_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Status>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Status_detailedMessage_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Status>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_Status>(
                    "Command_Status",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_Status>()
    }
}

impl ::protobuf::Clear for Command_Status {
    fn clear(&mut self) {
        self.clear_code();
        self.clear_statusMessage();
        self.clear_detailedMessage();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_Status {
    fn eq(&self, other: &Command_Status) -> bool {
        self.code == other.code &&
        self.statusMessage == other.statusMessage &&
        self.detailedMessage == other.detailedMessage &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_Status_code_acc_type;
static Command_Status_code_acc: Command_Status_code_acc_type = Command_Status_code_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Status> for Command_Status_code_acc_type {
    fn name(&self) -> &'static str {
        "code"
    }

    fn has_field(&self, m: &Command_Status) -> bool {
        m.has_code()
    }

    fn get_enum<'a>(&self, m: &Command_Status) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_code().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Command_Status_statusMessage_acc_type;
static Command_Status_statusMessage_acc: Command_Status_statusMessage_acc_type = Command_Status_statusMessage_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Status> for Command_Status_statusMessage_acc_type {
    fn name(&self) -> &'static str {
        "statusMessage"
    }

    fn has_field(&self, m: &Command_Status) -> bool {
        m.has_statusMessage()
    }

    fn get_str<'a>(&self, m: &'a Command_Status) -> &'a str {
        m.get_statusMessage()
    }
}

#[allow(non_camel_case_types)]
struct Command_Status_detailedMessage_acc_type;
static Command_Status_detailedMessage_acc: Command_Status_detailedMessage_acc_type = Command_Status_detailedMessage_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Status> for Command_Status_detailedMessage_acc_type {
    fn name(&self) -> &'static str {
        "detailedMessage"
    }

    fn has_field(&self, m: &Command_Status) -> bool {
        m.has_detailedMessage()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Status) -> &'a [u8] {
        m.get_detailedMessage()
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_Status_StatusCode {
    INVALID_STATUS_CODE = -1,
    NOT_ATTEMPTED = 0,
    SUCCESS = 1,
    HMAC_FAILURE = 2,
    NOT_AUTHORIZED = 3,
    VERSION_FAILURE = 4,
    INTERNAL_ERROR = 5,
    HEADER_REQUIRED = 6,
    NOT_FOUND = 7,
    VERSION_MISMATCH = 8,
    SERVICE_BUSY = 9,
    EXPIRED = 10,
    DATA_ERROR = 11,
    PERM_DATA_ERROR = 12,
    REMOTE_CONNECTION_ERROR = 13,
    NO_SPACE = 14,
    NO_SUCH_HMAC_ALGORITHM = 15,
    INVALID_REQUEST = 16,
    NESTED_OPERATION_ERRORS = 17,
    DEVICE_LOCKED = 18,
    DEVICE_ALREADY_UNLOCKED = 19,
    CONNECTION_TERMINATED = 20,
}


impl ::protobuf::ProtobufEnum for Command_Status_StatusCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_Status_StatusCode> {
        match value {
            -1 => ::std::option::Some(Command_Status_StatusCode::INVALID_STATUS_CODE),
            0 => ::std::option::Some(Command_Status_StatusCode::NOT_ATTEMPTED),
            1 => ::std::option::Some(Command_Status_StatusCode::SUCCESS),
            2 => ::std::option::Some(Command_Status_StatusCode::HMAC_FAILURE),
            3 => ::std::option::Some(Command_Status_StatusCode::NOT_AUTHORIZED),
            4 => ::std::option::Some(Command_Status_StatusCode::VERSION_FAILURE),
            5 => ::std::option::Some(Command_Status_StatusCode::INTERNAL_ERROR),
            6 => ::std::option::Some(Command_Status_StatusCode::HEADER_REQUIRED),
            7 => ::std::option::Some(Command_Status_StatusCode::NOT_FOUND),
            8 => ::std::option::Some(Command_Status_StatusCode::VERSION_MISMATCH),
            9 => ::std::option::Some(Command_Status_StatusCode::SERVICE_BUSY),
            10 => ::std::option::Some(Command_Status_StatusCode::EXPIRED),
            11 => ::std::option::Some(Command_Status_StatusCode::DATA_ERROR),
            12 => ::std::option::Some(Command_Status_StatusCode::PERM_DATA_ERROR),
            13 => ::std::option::Some(Command_Status_StatusCode::REMOTE_CONNECTION_ERROR),
            14 => ::std::option::Some(Command_Status_StatusCode::NO_SPACE),
            15 => ::std::option::Some(Command_Status_StatusCode::NO_SUCH_HMAC_ALGORITHM),
            16 => ::std::option::Some(Command_Status_StatusCode::INVALID_REQUEST),
            17 => ::std::option::Some(Command_Status_StatusCode::NESTED_OPERATION_ERRORS),
            18 => ::std::option::Some(Command_Status_StatusCode::DEVICE_LOCKED),
            19 => ::std::option::Some(Command_Status_StatusCode::DEVICE_ALREADY_UNLOCKED),
            20 => ::std::option::Some(Command_Status_StatusCode::CONNECTION_TERMINATED),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_Status_StatusCode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_Status_StatusCode", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,Default)]
pub struct Command_KeyValue {
    newVersion: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    force: ::std::option::Option<bool>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    dbVersion: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tag: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    algorithm: ::std::option::Option<Command_Algorithm>,
    metadataOnly: ::std::option::Option<bool>,
    synchronization: ::std::option::Option<Command_Synchronization>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_KeyValue {
    pub fn new() -> Command_KeyValue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_KeyValue {
        static mut instance: ::protobuf::lazy::Lazy<Command_KeyValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_KeyValue,
        };
        unsafe {
            instance.get(|| {
                Command_KeyValue {
                    newVersion: ::protobuf::SingularField::none(),
                    force: ::std::option::None,
                    key: ::protobuf::SingularField::none(),
                    dbVersion: ::protobuf::SingularField::none(),
                    tag: ::protobuf::SingularField::none(),
                    algorithm: ::std::option::None,
                    metadataOnly: ::std::option::None,
                    synchronization: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes newVersion = 2;

    pub fn clear_newVersion(&mut self) {
        self.newVersion.clear();
    }

    pub fn has_newVersion(&self) -> bool {
        self.newVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newVersion(&mut self, v: ::std::vec::Vec<u8>) {
        self.newVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newVersion(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.newVersion.is_none() {
            self.newVersion.set_default();
        };
        self.newVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_newVersion(&mut self) -> ::std::vec::Vec<u8> {
        self.newVersion.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_newVersion(&'a self) -> &'a [u8] {
        match self.newVersion.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bool force = 8;

    pub fn clear_force(&mut self) {
        self.force = ::std::option::None;
    }

    pub fn has_force(&self) -> bool {
        self.force.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = ::std::option::Some(v);
    }

    pub fn get_force(&self) -> bool {
        self.force.unwrap_or(false)
    }

    // optional bytes key = 3;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_key(&'a self) -> &'a [u8] {
        match self.key.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes dbVersion = 4;

    pub fn clear_dbVersion(&mut self) {
        self.dbVersion.clear();
    }

    pub fn has_dbVersion(&self) -> bool {
        self.dbVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dbVersion(&mut self, v: ::std::vec::Vec<u8>) {
        self.dbVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dbVersion(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.dbVersion.is_none() {
            self.dbVersion.set_default();
        };
        self.dbVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_dbVersion(&mut self) -> ::std::vec::Vec<u8> {
        self.dbVersion.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_dbVersion(&'a self) -> &'a [u8] {
        match self.dbVersion.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes tag = 5;

    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::vec::Vec<u8>) {
        self.tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.tag.is_none() {
            self.tag.set_default();
        };
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::vec::Vec<u8> {
        self.tag.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_tag(&'a self) -> &'a [u8] {
        match self.tag.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional .com.seagate.kinetic.proto.Command.Algorithm algorithm = 6;

    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: Command_Algorithm) {
        self.algorithm = ::std::option::Some(v);
    }

    pub fn get_algorithm(&self) -> Command_Algorithm {
        self.algorithm.unwrap_or(Command_Algorithm::INVALID_ALGORITHM)
    }

    // optional bool metadataOnly = 7;

    pub fn clear_metadataOnly(&mut self) {
        self.metadataOnly = ::std::option::None;
    }

    pub fn has_metadataOnly(&self) -> bool {
        self.metadataOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadataOnly(&mut self, v: bool) {
        self.metadataOnly = ::std::option::Some(v);
    }

    pub fn get_metadataOnly(&self) -> bool {
        self.metadataOnly.unwrap_or(false)
    }

    // optional .com.seagate.kinetic.proto.Command.Synchronization synchronization = 9;

    pub fn clear_synchronization(&mut self) {
        self.synchronization = ::std::option::None;
    }

    pub fn has_synchronization(&self) -> bool {
        self.synchronization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_synchronization(&mut self, v: Command_Synchronization) {
        self.synchronization = ::std::option::Some(v);
    }

    pub fn get_synchronization(&self) -> Command_Synchronization {
        self.synchronization.unwrap_or(Command_Synchronization::INVALID_SYNCHRONIZATION)
    }
}

impl ::protobuf::Message for Command_KeyValue {
    fn new() -> Command_KeyValue {
        Command_KeyValue::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.newVersion.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.force = ::std::option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.key.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.dbVersion.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.tag.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.algorithm = ::std::option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.metadataOnly = ::std::option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.synchronization = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.newVersion.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        if self.force.is_some() {
            my_size += 2;
        };
        for value in self.key.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        for value in self.dbVersion.iter() {
            my_size += ::protobuf::rt::bytes_size(4, value.as_slice());
        };
        for value in self.tag.iter() {
            my_size += ::protobuf::rt::bytes_size(5, value.as_slice());
        };
        for value in self.algorithm.iter() {
            my_size += ::protobuf::rt::enum_size(6, *value);
        };
        if self.metadataOnly.is_some() {
            my_size += 2;
        };
        for value in self.synchronization.iter() {
            my_size += ::protobuf::rt::enum_size(9, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.newVersion.as_ref() {
            Some(v) => {
                try!(os.write_bytes(2, v.as_slice()));
            },
            None => {},
        };
        match self.force {
            Some(v) => {
                try!(os.write_bool(8, v));
            },
            None => {},
        };
        match self.key.as_ref() {
            Some(v) => {
                try!(os.write_bytes(3, v.as_slice()));
            },
            None => {},
        };
        match self.dbVersion.as_ref() {
            Some(v) => {
                try!(os.write_bytes(4, v.as_slice()));
            },
            None => {},
        };
        match self.tag.as_ref() {
            Some(v) => {
                try!(os.write_bytes(5, v.as_slice()));
            },
            None => {},
        };
        match self.algorithm {
            Some(v) => {
                try!(os.write_enum(6, v as i32));
            },
            None => {},
        };
        match self.metadataOnly {
            Some(v) => {
                try!(os.write_bool(7, v));
            },
            None => {},
        };
        match self.synchronization {
            Some(v) => {
                try!(os.write_enum(9, v as i32));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_KeyValue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_KeyValue_newVersion_acc as &'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_KeyValue_force_acc as &'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_KeyValue_key_acc as &'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_KeyValue_dbVersion_acc as &'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_KeyValue_tag_acc as &'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_KeyValue_algorithm_acc as &'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_KeyValue_metadataOnly_acc as &'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_KeyValue_synchronization_acc as &'static ::protobuf::reflect::FieldAccessor<Command_KeyValue>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_KeyValue>(
                    "Command_KeyValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_KeyValue>()
    }
}

impl ::protobuf::Clear for Command_KeyValue {
    fn clear(&mut self) {
        self.clear_newVersion();
        self.clear_force();
        self.clear_key();
        self.clear_dbVersion();
        self.clear_tag();
        self.clear_algorithm();
        self.clear_metadataOnly();
        self.clear_synchronization();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_KeyValue {
    fn eq(&self, other: &Command_KeyValue) -> bool {
        self.newVersion == other.newVersion &&
        self.force == other.force &&
        self.key == other.key &&
        self.dbVersion == other.dbVersion &&
        self.tag == other.tag &&
        self.algorithm == other.algorithm &&
        self.metadataOnly == other.metadataOnly &&
        self.synchronization == other.synchronization &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_KeyValue_newVersion_acc_type;
static Command_KeyValue_newVersion_acc: Command_KeyValue_newVersion_acc_type = Command_KeyValue_newVersion_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_KeyValue> for Command_KeyValue_newVersion_acc_type {
    fn name(&self) -> &'static str {
        "newVersion"
    }

    fn has_field(&self, m: &Command_KeyValue) -> bool {
        m.has_newVersion()
    }

    fn get_bytes<'a>(&self, m: &'a Command_KeyValue) -> &'a [u8] {
        m.get_newVersion()
    }
}

#[allow(non_camel_case_types)]
struct Command_KeyValue_force_acc_type;
static Command_KeyValue_force_acc: Command_KeyValue_force_acc_type = Command_KeyValue_force_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_KeyValue> for Command_KeyValue_force_acc_type {
    fn name(&self) -> &'static str {
        "force"
    }

    fn has_field(&self, m: &Command_KeyValue) -> bool {
        m.has_force()
    }

    fn get_bool(&self, m: &Command_KeyValue) -> bool {
        m.get_force()
    }
}

#[allow(non_camel_case_types)]
struct Command_KeyValue_key_acc_type;
static Command_KeyValue_key_acc: Command_KeyValue_key_acc_type = Command_KeyValue_key_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_KeyValue> for Command_KeyValue_key_acc_type {
    fn name(&self) -> &'static str {
        "key"
    }

    fn has_field(&self, m: &Command_KeyValue) -> bool {
        m.has_key()
    }

    fn get_bytes<'a>(&self, m: &'a Command_KeyValue) -> &'a [u8] {
        m.get_key()
    }
}

#[allow(non_camel_case_types)]
struct Command_KeyValue_dbVersion_acc_type;
static Command_KeyValue_dbVersion_acc: Command_KeyValue_dbVersion_acc_type = Command_KeyValue_dbVersion_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_KeyValue> for Command_KeyValue_dbVersion_acc_type {
    fn name(&self) -> &'static str {
        "dbVersion"
    }

    fn has_field(&self, m: &Command_KeyValue) -> bool {
        m.has_dbVersion()
    }

    fn get_bytes<'a>(&self, m: &'a Command_KeyValue) -> &'a [u8] {
        m.get_dbVersion()
    }
}

#[allow(non_camel_case_types)]
struct Command_KeyValue_tag_acc_type;
static Command_KeyValue_tag_acc: Command_KeyValue_tag_acc_type = Command_KeyValue_tag_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_KeyValue> for Command_KeyValue_tag_acc_type {
    fn name(&self) -> &'static str {
        "tag"
    }

    fn has_field(&self, m: &Command_KeyValue) -> bool {
        m.has_tag()
    }

    fn get_bytes<'a>(&self, m: &'a Command_KeyValue) -> &'a [u8] {
        m.get_tag()
    }
}

#[allow(non_camel_case_types)]
struct Command_KeyValue_algorithm_acc_type;
static Command_KeyValue_algorithm_acc: Command_KeyValue_algorithm_acc_type = Command_KeyValue_algorithm_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_KeyValue> for Command_KeyValue_algorithm_acc_type {
    fn name(&self) -> &'static str {
        "algorithm"
    }

    fn has_field(&self, m: &Command_KeyValue) -> bool {
        m.has_algorithm()
    }

    fn get_enum<'a>(&self, m: &Command_KeyValue) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_algorithm().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Command_KeyValue_metadataOnly_acc_type;
static Command_KeyValue_metadataOnly_acc: Command_KeyValue_metadataOnly_acc_type = Command_KeyValue_metadataOnly_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_KeyValue> for Command_KeyValue_metadataOnly_acc_type {
    fn name(&self) -> &'static str {
        "metadataOnly"
    }

    fn has_field(&self, m: &Command_KeyValue) -> bool {
        m.has_metadataOnly()
    }

    fn get_bool(&self, m: &Command_KeyValue) -> bool {
        m.get_metadataOnly()
    }
}

#[allow(non_camel_case_types)]
struct Command_KeyValue_synchronization_acc_type;
static Command_KeyValue_synchronization_acc: Command_KeyValue_synchronization_acc_type = Command_KeyValue_synchronization_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_KeyValue> for Command_KeyValue_synchronization_acc_type {
    fn name(&self) -> &'static str {
        "synchronization"
    }

    fn has_field(&self, m: &Command_KeyValue) -> bool {
        m.has_synchronization()
    }

    fn get_enum<'a>(&self, m: &Command_KeyValue) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_synchronization().descriptor()
    }
}

#[deriving(Clone,Default)]
pub struct Command_Range {
    startKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    endKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    startKeyInclusive: ::std::option::Option<bool>,
    endKeyInclusive: ::std::option::Option<bool>,
    maxReturned: ::std::option::Option<i32>,
    reverse: ::std::option::Option<bool>,
    keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_Range {
    pub fn new() -> Command_Range {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_Range {
        static mut instance: ::protobuf::lazy::Lazy<Command_Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_Range,
        };
        unsafe {
            instance.get(|| {
                Command_Range {
                    startKey: ::protobuf::SingularField::none(),
                    endKey: ::protobuf::SingularField::none(),
                    startKeyInclusive: ::std::option::None,
                    endKeyInclusive: ::std::option::None,
                    maxReturned: ::std::option::None,
                    reverse: ::std::option::None,
                    keys: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes startKey = 1;

    pub fn clear_startKey(&mut self) {
        self.startKey.clear();
    }

    pub fn has_startKey(&self) -> bool {
        self.startKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.startKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startKey(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.startKey.is_none() {
            self.startKey.set_default();
        };
        self.startKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_startKey(&mut self) -> ::std::vec::Vec<u8> {
        self.startKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_startKey(&'a self) -> &'a [u8] {
        match self.startKey.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes endKey = 2;

    pub fn clear_endKey(&mut self) {
        self.endKey.clear();
    }

    pub fn has_endKey(&self) -> bool {
        self.endKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.endKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endKey(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.endKey.is_none() {
            self.endKey.set_default();
        };
        self.endKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_endKey(&mut self) -> ::std::vec::Vec<u8> {
        self.endKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_endKey(&'a self) -> &'a [u8] {
        match self.endKey.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bool startKeyInclusive = 3;

    pub fn clear_startKeyInclusive(&mut self) {
        self.startKeyInclusive = ::std::option::None;
    }

    pub fn has_startKeyInclusive(&self) -> bool {
        self.startKeyInclusive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startKeyInclusive(&mut self, v: bool) {
        self.startKeyInclusive = ::std::option::Some(v);
    }

    pub fn get_startKeyInclusive(&self) -> bool {
        self.startKeyInclusive.unwrap_or(false)
    }

    // optional bool endKeyInclusive = 4;

    pub fn clear_endKeyInclusive(&mut self) {
        self.endKeyInclusive = ::std::option::None;
    }

    pub fn has_endKeyInclusive(&self) -> bool {
        self.endKeyInclusive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endKeyInclusive(&mut self, v: bool) {
        self.endKeyInclusive = ::std::option::Some(v);
    }

    pub fn get_endKeyInclusive(&self) -> bool {
        self.endKeyInclusive.unwrap_or(false)
    }

    // optional int32 maxReturned = 5;

    pub fn clear_maxReturned(&mut self) {
        self.maxReturned = ::std::option::None;
    }

    pub fn has_maxReturned(&self) -> bool {
        self.maxReturned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxReturned(&mut self, v: i32) {
        self.maxReturned = ::std::option::Some(v);
    }

    pub fn get_maxReturned(&self) -> i32 {
        self.maxReturned.unwrap_or(0)
    }

    // optional bool reverse = 6;

    pub fn clear_reverse(&mut self) {
        self.reverse = ::std::option::None;
    }

    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = ::std::option::Some(v);
    }

    pub fn get_reverse(&self) -> bool {
        self.reverse.unwrap_or(false)
    }

    // repeated bytes keys = 8;

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    pub fn get_keys(&'a self) -> &'a [::std::vec::Vec<u8>] {
        self.keys.as_slice()
    }
}

impl ::protobuf::Message for Command_Range {
    fn new() -> Command_Range {
        Command_Range::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.startKey.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.endKey.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.startKeyInclusive = ::std::option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.endKeyInclusive = ::std::option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.maxReturned = ::std::option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.reverse = ::std::option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.keys.push_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.startKey.iter() {
            my_size += ::protobuf::rt::bytes_size(1, value.as_slice());
        };
        for value in self.endKey.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        if self.startKeyInclusive.is_some() {
            my_size += 2;
        };
        if self.endKeyInclusive.is_some() {
            my_size += 2;
        };
        for value in self.maxReturned.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.reverse.is_some() {
            my_size += 2;
        };
        for value in self.keys.iter() {
            my_size += ::protobuf::rt::bytes_size(8, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.startKey.as_ref() {
            Some(v) => {
                try!(os.write_bytes(1, v.as_slice()));
            },
            None => {},
        };
        match self.endKey.as_ref() {
            Some(v) => {
                try!(os.write_bytes(2, v.as_slice()));
            },
            None => {},
        };
        match self.startKeyInclusive {
            Some(v) => {
                try!(os.write_bool(3, v));
            },
            None => {},
        };
        match self.endKeyInclusive {
            Some(v) => {
                try!(os.write_bool(4, v));
            },
            None => {},
        };
        match self.maxReturned {
            Some(v) => {
                try!(os.write_int32(5, v));
            },
            None => {},
        };
        match self.reverse {
            Some(v) => {
                try!(os.write_bool(6, v));
            },
            None => {},
        };
        for v in self.keys.iter() {
            try!(os.write_bytes(8, v.as_slice()));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_Range>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_Range>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_Range_startKey_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Range>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Range_endKey_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Range>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Range_startKeyInclusive_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Range>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Range_endKeyInclusive_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Range>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Range_maxReturned_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Range>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Range_reverse_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Range>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Range_keys_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Range>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_Range>(
                    "Command_Range",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_Range>()
    }
}

impl ::protobuf::Clear for Command_Range {
    fn clear(&mut self) {
        self.clear_startKey();
        self.clear_endKey();
        self.clear_startKeyInclusive();
        self.clear_endKeyInclusive();
        self.clear_maxReturned();
        self.clear_reverse();
        self.clear_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_Range {
    fn eq(&self, other: &Command_Range) -> bool {
        self.startKey == other.startKey &&
        self.endKey == other.endKey &&
        self.startKeyInclusive == other.startKeyInclusive &&
        self.endKeyInclusive == other.endKeyInclusive &&
        self.maxReturned == other.maxReturned &&
        self.reverse == other.reverse &&
        self.keys == other.keys &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_Range_startKey_acc_type;
static Command_Range_startKey_acc: Command_Range_startKey_acc_type = Command_Range_startKey_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Range> for Command_Range_startKey_acc_type {
    fn name(&self) -> &'static str {
        "startKey"
    }

    fn has_field(&self, m: &Command_Range) -> bool {
        m.has_startKey()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Range) -> &'a [u8] {
        m.get_startKey()
    }
}

#[allow(non_camel_case_types)]
struct Command_Range_endKey_acc_type;
static Command_Range_endKey_acc: Command_Range_endKey_acc_type = Command_Range_endKey_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Range> for Command_Range_endKey_acc_type {
    fn name(&self) -> &'static str {
        "endKey"
    }

    fn has_field(&self, m: &Command_Range) -> bool {
        m.has_endKey()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Range) -> &'a [u8] {
        m.get_endKey()
    }
}

#[allow(non_camel_case_types)]
struct Command_Range_startKeyInclusive_acc_type;
static Command_Range_startKeyInclusive_acc: Command_Range_startKeyInclusive_acc_type = Command_Range_startKeyInclusive_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Range> for Command_Range_startKeyInclusive_acc_type {
    fn name(&self) -> &'static str {
        "startKeyInclusive"
    }

    fn has_field(&self, m: &Command_Range) -> bool {
        m.has_startKeyInclusive()
    }

    fn get_bool(&self, m: &Command_Range) -> bool {
        m.get_startKeyInclusive()
    }
}

#[allow(non_camel_case_types)]
struct Command_Range_endKeyInclusive_acc_type;
static Command_Range_endKeyInclusive_acc: Command_Range_endKeyInclusive_acc_type = Command_Range_endKeyInclusive_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Range> for Command_Range_endKeyInclusive_acc_type {
    fn name(&self) -> &'static str {
        "endKeyInclusive"
    }

    fn has_field(&self, m: &Command_Range) -> bool {
        m.has_endKeyInclusive()
    }

    fn get_bool(&self, m: &Command_Range) -> bool {
        m.get_endKeyInclusive()
    }
}

#[allow(non_camel_case_types)]
struct Command_Range_maxReturned_acc_type;
static Command_Range_maxReturned_acc: Command_Range_maxReturned_acc_type = Command_Range_maxReturned_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Range> for Command_Range_maxReturned_acc_type {
    fn name(&self) -> &'static str {
        "maxReturned"
    }

    fn has_field(&self, m: &Command_Range) -> bool {
        m.has_maxReturned()
    }

    fn get_i32(&self, m: &Command_Range) -> i32 {
        m.get_maxReturned()
    }
}

#[allow(non_camel_case_types)]
struct Command_Range_reverse_acc_type;
static Command_Range_reverse_acc: Command_Range_reverse_acc_type = Command_Range_reverse_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Range> for Command_Range_reverse_acc_type {
    fn name(&self) -> &'static str {
        "reverse"
    }

    fn has_field(&self, m: &Command_Range) -> bool {
        m.has_reverse()
    }

    fn get_bool(&self, m: &Command_Range) -> bool {
        m.get_reverse()
    }
}

#[allow(non_camel_case_types)]
struct Command_Range_keys_acc_type;
static Command_Range_keys_acc: Command_Range_keys_acc_type = Command_Range_keys_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Range> for Command_Range_keys_acc_type {
    fn name(&self) -> &'static str {
        "keys"
    }

    fn len_field(&self, m: &Command_Range) -> uint {
        m.get_keys().len()
    }

    fn get_rep_bytes<'a>(&self, m: &'a Command_Range) -> &'a [::std::vec::Vec<u8>] {
        m.get_keys()
    }
}

#[deriving(Clone,Default)]
pub struct Command_Setup {
    newClusterVersion: ::std::option::Option<i64>,
    firmwareDownload: ::std::option::Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_Setup {
    pub fn new() -> Command_Setup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_Setup {
        static mut instance: ::protobuf::lazy::Lazy<Command_Setup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_Setup,
        };
        unsafe {
            instance.get(|| {
                Command_Setup {
                    newClusterVersion: ::std::option::None,
                    firmwareDownload: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 newClusterVersion = 1;

    pub fn clear_newClusterVersion(&mut self) {
        self.newClusterVersion = ::std::option::None;
    }

    pub fn has_newClusterVersion(&self) -> bool {
        self.newClusterVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newClusterVersion(&mut self, v: i64) {
        self.newClusterVersion = ::std::option::Some(v);
    }

    pub fn get_newClusterVersion(&self) -> i64 {
        self.newClusterVersion.unwrap_or(0)
    }

    // optional bool firmwareDownload = 5;

    pub fn clear_firmwareDownload(&mut self) {
        self.firmwareDownload = ::std::option::None;
    }

    pub fn has_firmwareDownload(&self) -> bool {
        self.firmwareDownload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firmwareDownload(&mut self, v: bool) {
        self.firmwareDownload = ::std::option::Some(v);
    }

    pub fn get_firmwareDownload(&self) -> bool {
        self.firmwareDownload.unwrap_or(false)
    }
}

impl ::protobuf::Message for Command_Setup {
    fn new() -> Command_Setup {
        Command_Setup::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.newClusterVersion = ::std::option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.firmwareDownload = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.newClusterVersion.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.firmwareDownload.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.newClusterVersion {
            Some(v) => {
                try!(os.write_int64(1, v));
            },
            None => {},
        };
        match self.firmwareDownload {
            Some(v) => {
                try!(os.write_bool(5, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_Setup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_Setup>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_Setup_newClusterVersion_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Setup>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Setup_firmwareDownload_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Setup>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_Setup>(
                    "Command_Setup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_Setup>()
    }
}

impl ::protobuf::Clear for Command_Setup {
    fn clear(&mut self) {
        self.clear_newClusterVersion();
        self.clear_firmwareDownload();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_Setup {
    fn eq(&self, other: &Command_Setup) -> bool {
        self.newClusterVersion == other.newClusterVersion &&
        self.firmwareDownload == other.firmwareDownload &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_Setup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_Setup_newClusterVersion_acc_type;
static Command_Setup_newClusterVersion_acc: Command_Setup_newClusterVersion_acc_type = Command_Setup_newClusterVersion_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Setup> for Command_Setup_newClusterVersion_acc_type {
    fn name(&self) -> &'static str {
        "newClusterVersion"
    }

    fn has_field(&self, m: &Command_Setup) -> bool {
        m.has_newClusterVersion()
    }

    fn get_i64(&self, m: &Command_Setup) -> i64 {
        m.get_newClusterVersion()
    }
}

#[allow(non_camel_case_types)]
struct Command_Setup_firmwareDownload_acc_type;
static Command_Setup_firmwareDownload_acc: Command_Setup_firmwareDownload_acc_type = Command_Setup_firmwareDownload_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Setup> for Command_Setup_firmwareDownload_acc_type {
    fn name(&self) -> &'static str {
        "firmwareDownload"
    }

    fn has_field(&self, m: &Command_Setup) -> bool {
        m.has_firmwareDownload()
    }

    fn get_bool(&self, m: &Command_Setup) -> bool {
        m.get_firmwareDownload()
    }
}

#[deriving(Clone,Default)]
pub struct Command_P2POperation {
    peer: ::protobuf::SingularPtrField<Command_P2POperation_Peer>,
    operation: ::protobuf::RepeatedField<Command_P2POperation_Operation>,
    allChildOperationsSucceeded: ::std::option::Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_P2POperation {
    pub fn new() -> Command_P2POperation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_P2POperation {
        static mut instance: ::protobuf::lazy::Lazy<Command_P2POperation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_P2POperation,
        };
        unsafe {
            instance.get(|| {
                Command_P2POperation {
                    peer: ::protobuf::SingularPtrField::none(),
                    operation: ::protobuf::RepeatedField::new(),
                    allChildOperationsSucceeded: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .com.seagate.kinetic.proto.Command.P2POperation.Peer peer = 1;

    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    pub fn has_peer(&self) -> bool {
        self.peer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: Command_P2POperation_Peer) {
        self.peer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer(&'a mut self) -> &'a mut Command_P2POperation_Peer {
        if self.peer.is_none() {
            self.peer.set_default();
        };
        self.peer.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer(&mut self) -> Command_P2POperation_Peer {
        self.peer.take().unwrap_or_else(|| Command_P2POperation_Peer::new())
    }

    pub fn get_peer(&'a self) -> &'a Command_P2POperation_Peer {
        self.peer.as_ref().unwrap_or_else(|| Command_P2POperation_Peer::default_instance())
    }

    // repeated .com.seagate.kinetic.proto.Command.P2POperation.Operation operation = 2;

    pub fn clear_operation(&mut self) {
        self.operation.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::protobuf::RepeatedField<Command_P2POperation_Operation>) {
        self.operation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operation(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Command_P2POperation_Operation> {
        &mut self.operation
    }

    // Take field
    pub fn take_operation(&mut self) -> ::protobuf::RepeatedField<Command_P2POperation_Operation> {
        ::std::mem::replace(&mut self.operation, ::protobuf::RepeatedField::new())
    }

    pub fn get_operation(&'a self) -> &'a [Command_P2POperation_Operation] {
        self.operation.as_slice()
    }

    // optional bool allChildOperationsSucceeded = 3;

    pub fn clear_allChildOperationsSucceeded(&mut self) {
        self.allChildOperationsSucceeded = ::std::option::None;
    }

    pub fn has_allChildOperationsSucceeded(&self) -> bool {
        self.allChildOperationsSucceeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allChildOperationsSucceeded(&mut self, v: bool) {
        self.allChildOperationsSucceeded = ::std::option::Some(v);
    }

    pub fn get_allChildOperationsSucceeded(&self) -> bool {
        self.allChildOperationsSucceeded.unwrap_or(false)
    }
}

impl ::protobuf::Message for Command_P2POperation {
    fn new() -> Command_P2POperation {
        Command_P2POperation::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.peer.set_default();
                    try!(is.merge_message(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.operation.push_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.allChildOperationsSucceeded = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.peer.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.operation.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.allChildOperationsSucceeded.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.peer.as_ref() {
            Some(v) => {
                try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        for v in self.operation.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        match self.allChildOperationsSucceeded {
            Some(v) => {
                try!(os.write_bool(3, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_P2POperation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_P2POperation>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_peer_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_operation_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_allChildOperationsSucceeded_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_P2POperation>(
                    "Command_P2POperation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_P2POperation>()
    }
}

impl ::protobuf::Clear for Command_P2POperation {
    fn clear(&mut self) {
        self.clear_peer();
        self.clear_operation();
        self.clear_allChildOperationsSucceeded();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_P2POperation {
    fn eq(&self, other: &Command_P2POperation) -> bool {
        self.peer == other.peer &&
        self.operation == other.operation &&
        self.allChildOperationsSucceeded == other.allChildOperationsSucceeded &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_P2POperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_P2POperation_peer_acc_type;
static Command_P2POperation_peer_acc: Command_P2POperation_peer_acc_type = Command_P2POperation_peer_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation> for Command_P2POperation_peer_acc_type {
    fn name(&self) -> &'static str {
        "peer"
    }

    fn has_field(&self, m: &Command_P2POperation) -> bool {
        m.has_peer()
    }

    fn get_message<'a>(&self, m: &'a Command_P2POperation) -> &'a ::protobuf::Message {
        m.get_peer() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_operation_acc_type;
static Command_P2POperation_operation_acc: Command_P2POperation_operation_acc_type = Command_P2POperation_operation_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation> for Command_P2POperation_operation_acc_type {
    fn name(&self) -> &'static str {
        "operation"
    }

    fn len_field(&self, m: &Command_P2POperation) -> uint {
        m.get_operation().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a Command_P2POperation, index: uint) -> &'a ::protobuf::Message {
        &m.get_operation()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_allChildOperationsSucceeded_acc_type;
static Command_P2POperation_allChildOperationsSucceeded_acc: Command_P2POperation_allChildOperationsSucceeded_acc_type = Command_P2POperation_allChildOperationsSucceeded_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation> for Command_P2POperation_allChildOperationsSucceeded_acc_type {
    fn name(&self) -> &'static str {
        "allChildOperationsSucceeded"
    }

    fn has_field(&self, m: &Command_P2POperation) -> bool {
        m.has_allChildOperationsSucceeded()
    }

    fn get_bool(&self, m: &Command_P2POperation) -> bool {
        m.get_allChildOperationsSucceeded()
    }
}

#[deriving(Clone,Default)]
pub struct Command_P2POperation_Operation {
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    newKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    force: ::std::option::Option<bool>,
    status: ::protobuf::SingularPtrField<Command_Status>,
    p2pop: ::protobuf::SingularPtrField<Command_P2POperation>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_P2POperation_Operation {
    pub fn new() -> Command_P2POperation_Operation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_P2POperation_Operation {
        static mut instance: ::protobuf::lazy::Lazy<Command_P2POperation_Operation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_P2POperation_Operation,
        };
        unsafe {
            instance.get(|| {
                Command_P2POperation_Operation {
                    key: ::protobuf::SingularField::none(),
                    version: ::protobuf::SingularField::none(),
                    newKey: ::protobuf::SingularField::none(),
                    force: ::std::option::None,
                    status: ::protobuf::SingularPtrField::none(),
                    p2pop: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes key = 3;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_key(&'a self) -> &'a [u8] {
        match self.key.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes version = 4;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.version.is_none() {
            self.version.set_default();
        };
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::vec::Vec<u8> {
        self.version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_version(&'a self) -> &'a [u8] {
        match self.version.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes newKey = 5;

    pub fn clear_newKey(&mut self) {
        self.newKey.clear();
    }

    pub fn has_newKey(&self) -> bool {
        self.newKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.newKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newKey(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.newKey.is_none() {
            self.newKey.set_default();
        };
        self.newKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_newKey(&mut self) -> ::std::vec::Vec<u8> {
        self.newKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_newKey(&'a self) -> &'a [u8] {
        match self.newKey.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bool force = 6;

    pub fn clear_force(&mut self) {
        self.force = ::std::option::None;
    }

    pub fn has_force(&self) -> bool {
        self.force.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = ::std::option::Some(v);
    }

    pub fn get_force(&self) -> bool {
        self.force.unwrap_or(false)
    }

    // optional .com.seagate.kinetic.proto.Command.Status status = 7;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Command_Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&'a mut self) -> &'a mut Command_Status {
        if self.status.is_none() {
            self.status.set_default();
        };
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> Command_Status {
        self.status.take().unwrap_or_else(|| Command_Status::new())
    }

    pub fn get_status(&'a self) -> &'a Command_Status {
        self.status.as_ref().unwrap_or_else(|| Command_Status::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.P2POperation p2pop = 8;

    pub fn clear_p2pop(&mut self) {
        self.p2pop.clear();
    }

    pub fn has_p2pop(&self) -> bool {
        self.p2pop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2pop(&mut self, v: Command_P2POperation) {
        self.p2pop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2pop(&'a mut self) -> &'a mut Command_P2POperation {
        if self.p2pop.is_none() {
            self.p2pop.set_default();
        };
        self.p2pop.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2pop(&mut self) -> Command_P2POperation {
        self.p2pop.take().unwrap_or_else(|| Command_P2POperation::new())
    }

    pub fn get_p2pop(&'a self) -> &'a Command_P2POperation {
        self.p2pop.as_ref().unwrap_or_else(|| Command_P2POperation::default_instance())
    }
}

impl ::protobuf::Message for Command_P2POperation_Operation {
    fn new() -> Command_P2POperation_Operation {
        Command_P2POperation_Operation::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.key.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.version.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.newKey.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.force = ::std::option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.status.set_default();
                    try!(is.merge_message(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.p2pop.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.key.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        for value in self.version.iter() {
            my_size += ::protobuf::rt::bytes_size(4, value.as_slice());
        };
        for value in self.newKey.iter() {
            my_size += ::protobuf::rt::bytes_size(5, value.as_slice());
        };
        if self.force.is_some() {
            my_size += 2;
        };
        for value in self.status.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.p2pop.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.key.as_ref() {
            Some(v) => {
                try!(os.write_bytes(3, v.as_slice()));
            },
            None => {},
        };
        match self.version.as_ref() {
            Some(v) => {
                try!(os.write_bytes(4, v.as_slice()));
            },
            None => {},
        };
        match self.newKey.as_ref() {
            Some(v) => {
                try!(os.write_bytes(5, v.as_slice()));
            },
            None => {},
        };
        match self.force {
            Some(v) => {
                try!(os.write_bool(6, v));
            },
            None => {},
        };
        match self.status.as_ref() {
            Some(v) => {
                try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.p2pop.as_ref() {
            Some(v) => {
                try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_P2POperation_Operation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Operation_key_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Operation_version_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Operation_newKey_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Operation_force_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Operation_status_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Operation_p2pop_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_P2POperation_Operation>(
                    "Command_P2POperation_Operation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_P2POperation_Operation>()
    }
}

impl ::protobuf::Clear for Command_P2POperation_Operation {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_version();
        self.clear_newKey();
        self.clear_force();
        self.clear_status();
        self.clear_p2pop();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_P2POperation_Operation {
    fn eq(&self, other: &Command_P2POperation_Operation) -> bool {
        self.key == other.key &&
        self.version == other.version &&
        self.newKey == other.newKey &&
        self.force == other.force &&
        self.status == other.status &&
        self.p2pop == other.p2pop &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_P2POperation_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_P2POperation_Operation_key_acc_type;
static Command_P2POperation_Operation_key_acc: Command_P2POperation_Operation_key_acc_type = Command_P2POperation_Operation_key_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation> for Command_P2POperation_Operation_key_acc_type {
    fn name(&self) -> &'static str {
        "key"
    }

    fn has_field(&self, m: &Command_P2POperation_Operation) -> bool {
        m.has_key()
    }

    fn get_bytes<'a>(&self, m: &'a Command_P2POperation_Operation) -> &'a [u8] {
        m.get_key()
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_Operation_version_acc_type;
static Command_P2POperation_Operation_version_acc: Command_P2POperation_Operation_version_acc_type = Command_P2POperation_Operation_version_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation> for Command_P2POperation_Operation_version_acc_type {
    fn name(&self) -> &'static str {
        "version"
    }

    fn has_field(&self, m: &Command_P2POperation_Operation) -> bool {
        m.has_version()
    }

    fn get_bytes<'a>(&self, m: &'a Command_P2POperation_Operation) -> &'a [u8] {
        m.get_version()
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_Operation_newKey_acc_type;
static Command_P2POperation_Operation_newKey_acc: Command_P2POperation_Operation_newKey_acc_type = Command_P2POperation_Operation_newKey_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation> for Command_P2POperation_Operation_newKey_acc_type {
    fn name(&self) -> &'static str {
        "newKey"
    }

    fn has_field(&self, m: &Command_P2POperation_Operation) -> bool {
        m.has_newKey()
    }

    fn get_bytes<'a>(&self, m: &'a Command_P2POperation_Operation) -> &'a [u8] {
        m.get_newKey()
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_Operation_force_acc_type;
static Command_P2POperation_Operation_force_acc: Command_P2POperation_Operation_force_acc_type = Command_P2POperation_Operation_force_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation> for Command_P2POperation_Operation_force_acc_type {
    fn name(&self) -> &'static str {
        "force"
    }

    fn has_field(&self, m: &Command_P2POperation_Operation) -> bool {
        m.has_force()
    }

    fn get_bool(&self, m: &Command_P2POperation_Operation) -> bool {
        m.get_force()
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_Operation_status_acc_type;
static Command_P2POperation_Operation_status_acc: Command_P2POperation_Operation_status_acc_type = Command_P2POperation_Operation_status_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation> for Command_P2POperation_Operation_status_acc_type {
    fn name(&self) -> &'static str {
        "status"
    }

    fn has_field(&self, m: &Command_P2POperation_Operation) -> bool {
        m.has_status()
    }

    fn get_message<'a>(&self, m: &'a Command_P2POperation_Operation) -> &'a ::protobuf::Message {
        m.get_status() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_Operation_p2pop_acc_type;
static Command_P2POperation_Operation_p2pop_acc: Command_P2POperation_Operation_p2pop_acc_type = Command_P2POperation_Operation_p2pop_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Operation> for Command_P2POperation_Operation_p2pop_acc_type {
    fn name(&self) -> &'static str {
        "p2pop"
    }

    fn has_field(&self, m: &Command_P2POperation_Operation) -> bool {
        m.has_p2pop()
    }

    fn get_message<'a>(&self, m: &'a Command_P2POperation_Operation) -> &'a ::protobuf::Message {
        m.get_p2pop() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,Default)]
pub struct Command_P2POperation_Peer {
    hostname: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    tls: ::std::option::Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_P2POperation_Peer {
    pub fn new() -> Command_P2POperation_Peer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_P2POperation_Peer {
        static mut instance: ::protobuf::lazy::Lazy<Command_P2POperation_Peer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_P2POperation_Peer,
        };
        unsafe {
            instance.get(|| {
                Command_P2POperation_Peer {
                    hostname: ::protobuf::SingularField::none(),
                    port: ::std::option::None,
                    tls: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional int32 port = 2;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Some(v);
    }

    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    // optional bool tls = 3;

    pub fn clear_tls(&mut self) {
        self.tls = ::std::option::None;
    }

    pub fn has_tls(&self) -> bool {
        self.tls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: bool) {
        self.tls = ::std::option::Some(v);
    }

    pub fn get_tls(&self) -> bool {
        self.tls.unwrap_or(false)
    }
}

impl ::protobuf::Message for Command_P2POperation_Peer {
    fn new() -> Command_P2POperation_Peer {
        Command_P2POperation_Peer::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.hostname.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.port = ::std::option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.tls = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.tls.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.hostname.as_ref() {
            Some(v) => {
                try!(os.write_string(1, v.as_slice()));
            },
            None => {},
        };
        match self.port {
            Some(v) => {
                try!(os.write_int32(2, v));
            },
            None => {},
        };
        match self.tls {
            Some(v) => {
                try!(os.write_bool(3, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_P2POperation_Peer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Peer>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Peer_hostname_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Peer>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Peer_port_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Peer>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_P2POperation_Peer_tls_acc as &'static ::protobuf::reflect::FieldAccessor<Command_P2POperation_Peer>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_P2POperation_Peer>(
                    "Command_P2POperation_Peer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_P2POperation_Peer>()
    }
}

impl ::protobuf::Clear for Command_P2POperation_Peer {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_port();
        self.clear_tls();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_P2POperation_Peer {
    fn eq(&self, other: &Command_P2POperation_Peer) -> bool {
        self.hostname == other.hostname &&
        self.port == other.port &&
        self.tls == other.tls &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_P2POperation_Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_P2POperation_Peer_hostname_acc_type;
static Command_P2POperation_Peer_hostname_acc: Command_P2POperation_Peer_hostname_acc_type = Command_P2POperation_Peer_hostname_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Peer> for Command_P2POperation_Peer_hostname_acc_type {
    fn name(&self) -> &'static str {
        "hostname"
    }

    fn has_field(&self, m: &Command_P2POperation_Peer) -> bool {
        m.has_hostname()
    }

    fn get_str<'a>(&self, m: &'a Command_P2POperation_Peer) -> &'a str {
        m.get_hostname()
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_Peer_port_acc_type;
static Command_P2POperation_Peer_port_acc: Command_P2POperation_Peer_port_acc_type = Command_P2POperation_Peer_port_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Peer> for Command_P2POperation_Peer_port_acc_type {
    fn name(&self) -> &'static str {
        "port"
    }

    fn has_field(&self, m: &Command_P2POperation_Peer) -> bool {
        m.has_port()
    }

    fn get_i32(&self, m: &Command_P2POperation_Peer) -> i32 {
        m.get_port()
    }
}

#[allow(non_camel_case_types)]
struct Command_P2POperation_Peer_tls_acc_type;
static Command_P2POperation_Peer_tls_acc: Command_P2POperation_Peer_tls_acc_type = Command_P2POperation_Peer_tls_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_P2POperation_Peer> for Command_P2POperation_Peer_tls_acc_type {
    fn name(&self) -> &'static str {
        "tls"
    }

    fn has_field(&self, m: &Command_P2POperation_Peer) -> bool {
        m.has_tls()
    }

    fn get_bool(&self, m: &Command_P2POperation_Peer) -> bool {
        m.get_tls()
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog {
    types: ::std::vec::Vec<Command_GetLog_Type>,
    utilizations: ::protobuf::RepeatedField<Command_GetLog_Utilization>,
    temperatures: ::protobuf::RepeatedField<Command_GetLog_Temperature>,
    capacity: ::protobuf::SingularPtrField<Command_GetLog_Capacity>,
    configuration: ::protobuf::SingularPtrField<Command_GetLog_Configuration>,
    statistics: ::protobuf::RepeatedField<Command_GetLog_Statistics>,
    messages: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    limits: ::protobuf::SingularPtrField<Command_GetLog_Limits>,
    device: ::protobuf::SingularPtrField<Command_GetLog_Device>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog {
    pub fn new() -> Command_GetLog {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog {
                    types: ::std::vec::Vec::new(),
                    utilizations: ::protobuf::RepeatedField::new(),
                    temperatures: ::protobuf::RepeatedField::new(),
                    capacity: ::protobuf::SingularPtrField::none(),
                    configuration: ::protobuf::SingularPtrField::none(),
                    statistics: ::protobuf::RepeatedField::new(),
                    messages: ::protobuf::SingularField::none(),
                    limits: ::protobuf::SingularPtrField::none(),
                    device: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .com.seagate.kinetic.proto.Command.GetLog.Type types = 1;

    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<Command_GetLog_Type>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&'a mut self) -> &'a mut ::std::vec::Vec<Command_GetLog_Type> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<Command_GetLog_Type> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }

    pub fn get_types(&'a self) -> &'a [Command_GetLog_Type] {
        self.types.as_slice()
    }

    // repeated .com.seagate.kinetic.proto.Command.GetLog.Utilization utilizations = 2;

    pub fn clear_utilizations(&mut self) {
        self.utilizations.clear();
    }

    // Param is passed by value, moved
    pub fn set_utilizations(&mut self, v: ::protobuf::RepeatedField<Command_GetLog_Utilization>) {
        self.utilizations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_utilizations(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Command_GetLog_Utilization> {
        &mut self.utilizations
    }

    // Take field
    pub fn take_utilizations(&mut self) -> ::protobuf::RepeatedField<Command_GetLog_Utilization> {
        ::std::mem::replace(&mut self.utilizations, ::protobuf::RepeatedField::new())
    }

    pub fn get_utilizations(&'a self) -> &'a [Command_GetLog_Utilization] {
        self.utilizations.as_slice()
    }

    // repeated .com.seagate.kinetic.proto.Command.GetLog.Temperature temperatures = 3;

    pub fn clear_temperatures(&mut self) {
        self.temperatures.clear();
    }

    // Param is passed by value, moved
    pub fn set_temperatures(&mut self, v: ::protobuf::RepeatedField<Command_GetLog_Temperature>) {
        self.temperatures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_temperatures(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Command_GetLog_Temperature> {
        &mut self.temperatures
    }

    // Take field
    pub fn take_temperatures(&mut self) -> ::protobuf::RepeatedField<Command_GetLog_Temperature> {
        ::std::mem::replace(&mut self.temperatures, ::protobuf::RepeatedField::new())
    }

    pub fn get_temperatures(&'a self) -> &'a [Command_GetLog_Temperature] {
        self.temperatures.as_slice()
    }

    // optional .com.seagate.kinetic.proto.Command.GetLog.Capacity capacity = 4;

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: Command_GetLog_Capacity) {
        self.capacity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capacity(&'a mut self) -> &'a mut Command_GetLog_Capacity {
        if self.capacity.is_none() {
            self.capacity.set_default();
        };
        self.capacity.as_mut().unwrap()
    }

    // Take field
    pub fn take_capacity(&mut self) -> Command_GetLog_Capacity {
        self.capacity.take().unwrap_or_else(|| Command_GetLog_Capacity::new())
    }

    pub fn get_capacity(&'a self) -> &'a Command_GetLog_Capacity {
        self.capacity.as_ref().unwrap_or_else(|| Command_GetLog_Capacity::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.GetLog.Configuration configuration = 5;

    pub fn clear_configuration(&mut self) {
        self.configuration.clear();
    }

    pub fn has_configuration(&self) -> bool {
        self.configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configuration(&mut self, v: Command_GetLog_Configuration) {
        self.configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configuration(&'a mut self) -> &'a mut Command_GetLog_Configuration {
        if self.configuration.is_none() {
            self.configuration.set_default();
        };
        self.configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_configuration(&mut self) -> Command_GetLog_Configuration {
        self.configuration.take().unwrap_or_else(|| Command_GetLog_Configuration::new())
    }

    pub fn get_configuration(&'a self) -> &'a Command_GetLog_Configuration {
        self.configuration.as_ref().unwrap_or_else(|| Command_GetLog_Configuration::default_instance())
    }

    // repeated .com.seagate.kinetic.proto.Command.GetLog.Statistics statistics = 6;

    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ::protobuf::RepeatedField<Command_GetLog_Statistics>) {
        self.statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statistics(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Command_GetLog_Statistics> {
        &mut self.statistics
    }

    // Take field
    pub fn take_statistics(&mut self) -> ::protobuf::RepeatedField<Command_GetLog_Statistics> {
        ::std::mem::replace(&mut self.statistics, ::protobuf::RepeatedField::new())
    }

    pub fn get_statistics(&'a self) -> &'a [Command_GetLog_Statistics] {
        self.statistics.as_slice()
    }

    // optional bytes messages = 7;

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    pub fn has_messages(&self) -> bool {
        self.messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<u8>) {
        self.messages = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messages(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.messages.is_none() {
            self.messages.set_default();
        };
        self.messages.as_mut().unwrap()
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<u8> {
        self.messages.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_messages(&'a self) -> &'a [u8] {
        match self.messages.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional .com.seagate.kinetic.proto.Command.GetLog.Limits limits = 8;

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    pub fn has_limits(&self) -> bool {
        self.limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: Command_GetLog_Limits) {
        self.limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limits(&'a mut self) -> &'a mut Command_GetLog_Limits {
        if self.limits.is_none() {
            self.limits.set_default();
        };
        self.limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_limits(&mut self) -> Command_GetLog_Limits {
        self.limits.take().unwrap_or_else(|| Command_GetLog_Limits::new())
    }

    pub fn get_limits(&'a self) -> &'a Command_GetLog_Limits {
        self.limits.as_ref().unwrap_or_else(|| Command_GetLog_Limits::default_instance())
    }

    // optional .com.seagate.kinetic.proto.Command.GetLog.Device device = 9;

    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: Command_GetLog_Device) {
        self.device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&'a mut self) -> &'a mut Command_GetLog_Device {
        if self.device.is_none() {
            self.device.set_default();
        };
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> Command_GetLog_Device {
        self.device.take().unwrap_or_else(|| Command_GetLog_Device::new())
    }

    pub fn get_device(&'a self) -> &'a Command_GetLog_Device {
        self.device.as_ref().unwrap_or_else(|| Command_GetLog_Device::default_instance())
    }
}

impl ::protobuf::Message for Command_GetLog {
    fn new() -> Command_GetLog {
        Command_GetLog::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    match wire_type {
                        ::protobuf::wire_format::WireTypeLengthDelimited => {
                            try!(is.read_repeated_packed_enum_into(&mut self.types));
                        },
                        ::protobuf::wire_format::WireTypeVarint => {
                            self.types.push(try!(is.read_enum()));
                        },
                        _ => {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        },
                    };
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.utilizations.push_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.temperatures.push_default();
                    try!(is.merge_message(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.capacity.set_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.configuration.set_default();
                    try!(is.merge_message(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.statistics.push_default();
                    try!(is.merge_message(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.messages.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.limits.set_default();
                    try!(is.merge_message(tmp))
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.device.set_default();
                    try!(is.merge_message(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.types.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.utilizations.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.temperatures.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.capacity.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.configuration.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.statistics.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.messages.iter() {
            my_size += ::protobuf::rt::bytes_size(7, value.as_slice());
        };
        for value in self.limits.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.device.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.types.iter() {
            try!(os.write_enum(1, *v as i32));
        };
        for v in self.utilizations.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.temperatures.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        match self.capacity.as_ref() {
            Some(v) => {
                try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.configuration.as_ref() {
            Some(v) => {
                try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        for v in self.statistics.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        match self.messages.as_ref() {
            Some(v) => {
                try!(os.write_bytes(7, v.as_slice()));
            },
            None => {},
        };
        match self.limits.as_ref() {
            Some(v) => {
                try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        match self.device.as_ref() {
            Some(v) => {
                try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
                try!(os.write_raw_varint32(v.get_cached_size()));
                try!(v.write_to_with_cached_sizes(os));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_types_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_utilizations_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_temperatures_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_capacity_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_configuration_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_statistics_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_messages_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_limits_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_device_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog>(
                    "Command_GetLog",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog>()
    }
}

impl ::protobuf::Clear for Command_GetLog {
    fn clear(&mut self) {
        self.clear_types();
        self.clear_utilizations();
        self.clear_temperatures();
        self.clear_capacity();
        self.clear_configuration();
        self.clear_statistics();
        self.clear_messages();
        self.clear_limits();
        self.clear_device();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog {
    fn eq(&self, other: &Command_GetLog) -> bool {
        self.types == other.types &&
        self.utilizations == other.utilizations &&
        self.temperatures == other.temperatures &&
        self.capacity == other.capacity &&
        self.configuration == other.configuration &&
        self.statistics == other.statistics &&
        self.messages == other.messages &&
        self.limits == other.limits &&
        self.device == other.device &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_types_acc_type;
static Command_GetLog_types_acc: Command_GetLog_types_acc_type = Command_GetLog_types_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_types_acc_type {
    fn name(&self) -> &'static str {
        "types"
    }

    fn len_field(&self, m: &Command_GetLog) -> uint {
        m.get_types().len()
    }

    fn get_rep_enum_item<'a>(&self, m: &Command_GetLog, index: uint) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_types()[index].descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_utilizations_acc_type;
static Command_GetLog_utilizations_acc: Command_GetLog_utilizations_acc_type = Command_GetLog_utilizations_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_utilizations_acc_type {
    fn name(&self) -> &'static str {
        "utilizations"
    }

    fn len_field(&self, m: &Command_GetLog) -> uint {
        m.get_utilizations().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a Command_GetLog, index: uint) -> &'a ::protobuf::Message {
        &m.get_utilizations()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_temperatures_acc_type;
static Command_GetLog_temperatures_acc: Command_GetLog_temperatures_acc_type = Command_GetLog_temperatures_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_temperatures_acc_type {
    fn name(&self) -> &'static str {
        "temperatures"
    }

    fn len_field(&self, m: &Command_GetLog) -> uint {
        m.get_temperatures().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a Command_GetLog, index: uint) -> &'a ::protobuf::Message {
        &m.get_temperatures()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_capacity_acc_type;
static Command_GetLog_capacity_acc: Command_GetLog_capacity_acc_type = Command_GetLog_capacity_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_capacity_acc_type {
    fn name(&self) -> &'static str {
        "capacity"
    }

    fn has_field(&self, m: &Command_GetLog) -> bool {
        m.has_capacity()
    }

    fn get_message<'a>(&self, m: &'a Command_GetLog) -> &'a ::protobuf::Message {
        m.get_capacity() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_configuration_acc_type;
static Command_GetLog_configuration_acc: Command_GetLog_configuration_acc_type = Command_GetLog_configuration_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_configuration_acc_type {
    fn name(&self) -> &'static str {
        "configuration"
    }

    fn has_field(&self, m: &Command_GetLog) -> bool {
        m.has_configuration()
    }

    fn get_message<'a>(&self, m: &'a Command_GetLog) -> &'a ::protobuf::Message {
        m.get_configuration() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_statistics_acc_type;
static Command_GetLog_statistics_acc: Command_GetLog_statistics_acc_type = Command_GetLog_statistics_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_statistics_acc_type {
    fn name(&self) -> &'static str {
        "statistics"
    }

    fn len_field(&self, m: &Command_GetLog) -> uint {
        m.get_statistics().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a Command_GetLog, index: uint) -> &'a ::protobuf::Message {
        &m.get_statistics()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_messages_acc_type;
static Command_GetLog_messages_acc: Command_GetLog_messages_acc_type = Command_GetLog_messages_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_messages_acc_type {
    fn name(&self) -> &'static str {
        "messages"
    }

    fn has_field(&self, m: &Command_GetLog) -> bool {
        m.has_messages()
    }

    fn get_bytes<'a>(&self, m: &'a Command_GetLog) -> &'a [u8] {
        m.get_messages()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_limits_acc_type;
static Command_GetLog_limits_acc: Command_GetLog_limits_acc_type = Command_GetLog_limits_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_limits_acc_type {
    fn name(&self) -> &'static str {
        "limits"
    }

    fn has_field(&self, m: &Command_GetLog) -> bool {
        m.has_limits()
    }

    fn get_message<'a>(&self, m: &'a Command_GetLog) -> &'a ::protobuf::Message {
        m.get_limits() as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_device_acc_type;
static Command_GetLog_device_acc: Command_GetLog_device_acc_type = Command_GetLog_device_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog> for Command_GetLog_device_acc_type {
    fn name(&self) -> &'static str {
        "device"
    }

    fn has_field(&self, m: &Command_GetLog) -> bool {
        m.has_device()
    }

    fn get_message<'a>(&self, m: &'a Command_GetLog) -> &'a ::protobuf::Message {
        m.get_device() as &'a ::protobuf::Message
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog_Utilization {
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::std::option::Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog_Utilization {
    pub fn new() -> Command_GetLog_Utilization {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog_Utilization {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog_Utilization> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog_Utilization,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog_Utilization {
                    name: ::protobuf::SingularField::none(),
                    value: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional float value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Some(v);
    }

    pub fn get_value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }
}

impl ::protobuf::Message for Command_GetLog_Utilization {
    fn new() -> Command_GetLog_Utilization {
        Command_GetLog_Utilization::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_float());
                    self.value = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        if self.value.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.name.as_ref() {
            Some(v) => {
                try!(os.write_string(1, v.as_slice()));
            },
            None => {},
        };
        match self.value {
            Some(v) => {
                try!(os.write_float(2, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog_Utilization>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Utilization>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Utilization_name_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Utilization>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Utilization_value_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Utilization>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog_Utilization>(
                    "Command_GetLog_Utilization",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog_Utilization>()
    }
}

impl ::protobuf::Clear for Command_GetLog_Utilization {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog_Utilization {
    fn eq(&self, other: &Command_GetLog_Utilization) -> bool {
        self.name == other.name &&
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog_Utilization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_Utilization_name_acc_type;
static Command_GetLog_Utilization_name_acc: Command_GetLog_Utilization_name_acc_type = Command_GetLog_Utilization_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Utilization> for Command_GetLog_Utilization_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &Command_GetLog_Utilization) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Utilization) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Utilization_value_acc_type;
static Command_GetLog_Utilization_value_acc: Command_GetLog_Utilization_value_acc_type = Command_GetLog_Utilization_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Utilization> for Command_GetLog_Utilization_value_acc_type {
    fn name(&self) -> &'static str {
        "value"
    }

    fn has_field(&self, m: &Command_GetLog_Utilization) -> bool {
        m.has_value()
    }

    fn get_f32(&self, m: &Command_GetLog_Utilization) -> f32 {
        m.get_value()
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog_Temperature {
    name: ::protobuf::SingularField<::std::string::String>,
    current: ::std::option::Option<f32>,
    minimum: ::std::option::Option<f32>,
    maximum: ::std::option::Option<f32>,
    target: ::std::option::Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog_Temperature {
    pub fn new() -> Command_GetLog_Temperature {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog_Temperature {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog_Temperature> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog_Temperature,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog_Temperature {
                    name: ::protobuf::SingularField::none(),
                    current: ::std::option::None,
                    minimum: ::std::option::None,
                    maximum: ::std::option::None,
                    target: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional float current = 2;

    pub fn clear_current(&mut self) {
        self.current = ::std::option::None;
    }

    pub fn has_current(&self) -> bool {
        self.current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: f32) {
        self.current = ::std::option::Some(v);
    }

    pub fn get_current(&self) -> f32 {
        self.current.unwrap_or(0.)
    }

    // optional float minimum = 3;

    pub fn clear_minimum(&mut self) {
        self.minimum = ::std::option::None;
    }

    pub fn has_minimum(&self) -> bool {
        self.minimum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: f32) {
        self.minimum = ::std::option::Some(v);
    }

    pub fn get_minimum(&self) -> f32 {
        self.minimum.unwrap_or(0.)
    }

    // optional float maximum = 4;

    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: f32) {
        self.maximum = ::std::option::Some(v);
    }

    pub fn get_maximum(&self) -> f32 {
        self.maximum.unwrap_or(0.)
    }

    // optional float target = 5;

    pub fn clear_target(&mut self) {
        self.target = ::std::option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: f32) {
        self.target = ::std::option::Some(v);
    }

    pub fn get_target(&self) -> f32 {
        self.target.unwrap_or(0.)
    }
}

impl ::protobuf::Message for Command_GetLog_Temperature {
    fn new() -> Command_GetLog_Temperature {
        Command_GetLog_Temperature::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_float());
                    self.current = ::std::option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_float());
                    self.minimum = ::std::option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_float());
                    self.maximum = ::std::option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_float());
                    self.target = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        if self.current.is_some() {
            my_size += 5;
        };
        if self.minimum.is_some() {
            my_size += 5;
        };
        if self.maximum.is_some() {
            my_size += 5;
        };
        if self.target.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.name.as_ref() {
            Some(v) => {
                try!(os.write_string(1, v.as_slice()));
            },
            None => {},
        };
        match self.current {
            Some(v) => {
                try!(os.write_float(2, v));
            },
            None => {},
        };
        match self.minimum {
            Some(v) => {
                try!(os.write_float(3, v));
            },
            None => {},
        };
        match self.maximum {
            Some(v) => {
                try!(os.write_float(4, v));
            },
            None => {},
        };
        match self.target {
            Some(v) => {
                try!(os.write_float(5, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog_Temperature>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Temperature_name_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Temperature_current_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Temperature_minimum_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Temperature_maximum_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Temperature_target_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog_Temperature>(
                    "Command_GetLog_Temperature",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog_Temperature>()
    }
}

impl ::protobuf::Clear for Command_GetLog_Temperature {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_current();
        self.clear_minimum();
        self.clear_maximum();
        self.clear_target();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog_Temperature {
    fn eq(&self, other: &Command_GetLog_Temperature) -> bool {
        self.name == other.name &&
        self.current == other.current &&
        self.minimum == other.minimum &&
        self.maximum == other.maximum &&
        self.target == other.target &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog_Temperature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_Temperature_name_acc_type;
static Command_GetLog_Temperature_name_acc: Command_GetLog_Temperature_name_acc_type = Command_GetLog_Temperature_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature> for Command_GetLog_Temperature_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &Command_GetLog_Temperature) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Temperature) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Temperature_current_acc_type;
static Command_GetLog_Temperature_current_acc: Command_GetLog_Temperature_current_acc_type = Command_GetLog_Temperature_current_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature> for Command_GetLog_Temperature_current_acc_type {
    fn name(&self) -> &'static str {
        "current"
    }

    fn has_field(&self, m: &Command_GetLog_Temperature) -> bool {
        m.has_current()
    }

    fn get_f32(&self, m: &Command_GetLog_Temperature) -> f32 {
        m.get_current()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Temperature_minimum_acc_type;
static Command_GetLog_Temperature_minimum_acc: Command_GetLog_Temperature_minimum_acc_type = Command_GetLog_Temperature_minimum_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature> for Command_GetLog_Temperature_minimum_acc_type {
    fn name(&self) -> &'static str {
        "minimum"
    }

    fn has_field(&self, m: &Command_GetLog_Temperature) -> bool {
        m.has_minimum()
    }

    fn get_f32(&self, m: &Command_GetLog_Temperature) -> f32 {
        m.get_minimum()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Temperature_maximum_acc_type;
static Command_GetLog_Temperature_maximum_acc: Command_GetLog_Temperature_maximum_acc_type = Command_GetLog_Temperature_maximum_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature> for Command_GetLog_Temperature_maximum_acc_type {
    fn name(&self) -> &'static str {
        "maximum"
    }

    fn has_field(&self, m: &Command_GetLog_Temperature) -> bool {
        m.has_maximum()
    }

    fn get_f32(&self, m: &Command_GetLog_Temperature) -> f32 {
        m.get_maximum()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Temperature_target_acc_type;
static Command_GetLog_Temperature_target_acc: Command_GetLog_Temperature_target_acc_type = Command_GetLog_Temperature_target_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Temperature> for Command_GetLog_Temperature_target_acc_type {
    fn name(&self) -> &'static str {
        "target"
    }

    fn has_field(&self, m: &Command_GetLog_Temperature) -> bool {
        m.has_target()
    }

    fn get_f32(&self, m: &Command_GetLog_Temperature) -> f32 {
        m.get_target()
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog_Capacity {
    nominalCapacityInBytes: ::std::option::Option<u64>,
    portionFull: ::std::option::Option<f32>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog_Capacity {
    pub fn new() -> Command_GetLog_Capacity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog_Capacity {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog_Capacity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog_Capacity,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog_Capacity {
                    nominalCapacityInBytes: ::std::option::None,
                    portionFull: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint64 nominalCapacityInBytes = 4;

    pub fn clear_nominalCapacityInBytes(&mut self) {
        self.nominalCapacityInBytes = ::std::option::None;
    }

    pub fn has_nominalCapacityInBytes(&self) -> bool {
        self.nominalCapacityInBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nominalCapacityInBytes(&mut self, v: u64) {
        self.nominalCapacityInBytes = ::std::option::Some(v);
    }

    pub fn get_nominalCapacityInBytes(&self) -> u64 {
        self.nominalCapacityInBytes.unwrap_or(0)
    }

    // optional float portionFull = 5;

    pub fn clear_portionFull(&mut self) {
        self.portionFull = ::std::option::None;
    }

    pub fn has_portionFull(&self) -> bool {
        self.portionFull.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portionFull(&mut self, v: f32) {
        self.portionFull = ::std::option::Some(v);
    }

    pub fn get_portionFull(&self) -> f32 {
        self.portionFull.unwrap_or(0.)
    }
}

impl ::protobuf::Message for Command_GetLog_Capacity {
    fn new() -> Command_GetLog_Capacity {
        Command_GetLog_Capacity::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.nominalCapacityInBytes = ::std::option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_float());
                    self.portionFull = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.nominalCapacityInBytes.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.portionFull.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.nominalCapacityInBytes {
            Some(v) => {
                try!(os.write_uint64(4, v));
            },
            None => {},
        };
        match self.portionFull {
            Some(v) => {
                try!(os.write_float(5, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog_Capacity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Capacity>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Capacity_nominalCapacityInBytes_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Capacity>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Capacity_portionFull_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Capacity>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog_Capacity>(
                    "Command_GetLog_Capacity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog_Capacity>()
    }
}

impl ::protobuf::Clear for Command_GetLog_Capacity {
    fn clear(&mut self) {
        self.clear_nominalCapacityInBytes();
        self.clear_portionFull();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog_Capacity {
    fn eq(&self, other: &Command_GetLog_Capacity) -> bool {
        self.nominalCapacityInBytes == other.nominalCapacityInBytes &&
        self.portionFull == other.portionFull &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog_Capacity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_Capacity_nominalCapacityInBytes_acc_type;
static Command_GetLog_Capacity_nominalCapacityInBytes_acc: Command_GetLog_Capacity_nominalCapacityInBytes_acc_type = Command_GetLog_Capacity_nominalCapacityInBytes_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Capacity> for Command_GetLog_Capacity_nominalCapacityInBytes_acc_type {
    fn name(&self) -> &'static str {
        "nominalCapacityInBytes"
    }

    fn has_field(&self, m: &Command_GetLog_Capacity) -> bool {
        m.has_nominalCapacityInBytes()
    }

    fn get_u64(&self, m: &Command_GetLog_Capacity) -> u64 {
        m.get_nominalCapacityInBytes()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Capacity_portionFull_acc_type;
static Command_GetLog_Capacity_portionFull_acc: Command_GetLog_Capacity_portionFull_acc_type = Command_GetLog_Capacity_portionFull_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Capacity> for Command_GetLog_Capacity_portionFull_acc_type {
    fn name(&self) -> &'static str {
        "portionFull"
    }

    fn has_field(&self, m: &Command_GetLog_Capacity) -> bool {
        m.has_portionFull()
    }

    fn get_f32(&self, m: &Command_GetLog_Capacity) -> f32 {
        m.get_portionFull()
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog_Configuration {
    vendor: ::protobuf::SingularField<::std::string::String>,
    model: ::protobuf::SingularField<::std::string::String>,
    serialNumber: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    worldWideName: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version: ::protobuf::SingularField<::std::string::String>,
    compilationDate: ::protobuf::SingularField<::std::string::String>,
    sourceHash: ::protobuf::SingularField<::std::string::String>,
    protocolVersion: ::protobuf::SingularField<::std::string::String>,
    protocolCompilationDate: ::protobuf::SingularField<::std::string::String>,
    protocolSourceHash: ::protobuf::SingularField<::std::string::String>,
    interface: ::protobuf::RepeatedField<Command_GetLog_Configuration_Interface>,
    port: ::std::option::Option<i32>,
    tlsPort: ::std::option::Option<i32>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog_Configuration {
    pub fn new() -> Command_GetLog_Configuration {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog_Configuration {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog_Configuration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog_Configuration,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog_Configuration {
                    vendor: ::protobuf::SingularField::none(),
                    model: ::protobuf::SingularField::none(),
                    serialNumber: ::protobuf::SingularField::none(),
                    worldWideName: ::protobuf::SingularField::none(),
                    version: ::protobuf::SingularField::none(),
                    compilationDate: ::protobuf::SingularField::none(),
                    sourceHash: ::protobuf::SingularField::none(),
                    protocolVersion: ::protobuf::SingularField::none(),
                    protocolCompilationDate: ::protobuf::SingularField::none(),
                    protocolSourceHash: ::protobuf::SingularField::none(),
                    interface: ::protobuf::RepeatedField::new(),
                    port: ::std::option::None,
                    tlsPort: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string vendor = 5;

    pub fn clear_vendor(&mut self) {
        self.vendor.clear();
    }

    pub fn has_vendor(&self) -> bool {
        self.vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendor(&mut self, v: ::std::string::String) {
        self.vendor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendor(&'a mut self) -> &'a mut ::std::string::String {
        if self.vendor.is_none() {
            self.vendor.set_default();
        };
        self.vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_vendor(&mut self) -> ::std::string::String {
        self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_vendor(&'a self) -> &'a str {
        match self.vendor.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional string model = 6;

    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    pub fn has_model(&self) -> bool {
        self.model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&'a mut self) -> &'a mut ::std::string::String {
        if self.model.is_none() {
            self.model.set_default();
        };
        self.model.as_mut().unwrap()
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        self.model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_model(&'a self) -> &'a str {
        match self.model.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional bytes serialNumber = 7;

    pub fn clear_serialNumber(&mut self) {
        self.serialNumber.clear();
    }

    pub fn has_serialNumber(&self) -> bool {
        self.serialNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialNumber(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialNumber = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialNumber(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.serialNumber.is_none() {
            self.serialNumber.set_default();
        };
        self.serialNumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialNumber(&mut self) -> ::std::vec::Vec<u8> {
        self.serialNumber.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_serialNumber(&'a self) -> &'a [u8] {
        match self.serialNumber.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes worldWideName = 14;

    pub fn clear_worldWideName(&mut self) {
        self.worldWideName.clear();
    }

    pub fn has_worldWideName(&self) -> bool {
        self.worldWideName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worldWideName(&mut self, v: ::std::vec::Vec<u8>) {
        self.worldWideName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worldWideName(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.worldWideName.is_none() {
            self.worldWideName.set_default();
        };
        self.worldWideName.as_mut().unwrap()
    }

    // Take field
    pub fn take_worldWideName(&mut self) -> ::std::vec::Vec<u8> {
        self.worldWideName.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_worldWideName(&'a self) -> &'a [u8] {
        match self.worldWideName.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional string version = 8;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&'a mut self) -> &'a mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        };
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_version(&'a self) -> &'a str {
        match self.version.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional string compilationDate = 12;

    pub fn clear_compilationDate(&mut self) {
        self.compilationDate.clear();
    }

    pub fn has_compilationDate(&self) -> bool {
        self.compilationDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compilationDate(&mut self, v: ::std::string::String) {
        self.compilationDate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compilationDate(&'a mut self) -> &'a mut ::std::string::String {
        if self.compilationDate.is_none() {
            self.compilationDate.set_default();
        };
        self.compilationDate.as_mut().unwrap()
    }

    // Take field
    pub fn take_compilationDate(&mut self) -> ::std::string::String {
        self.compilationDate.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_compilationDate(&'a self) -> &'a str {
        match self.compilationDate.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional string sourceHash = 13;

    pub fn clear_sourceHash(&mut self) {
        self.sourceHash.clear();
    }

    pub fn has_sourceHash(&self) -> bool {
        self.sourceHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceHash(&mut self, v: ::std::string::String) {
        self.sourceHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceHash(&'a mut self) -> &'a mut ::std::string::String {
        if self.sourceHash.is_none() {
            self.sourceHash.set_default();
        };
        self.sourceHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourceHash(&mut self) -> ::std::string::String {
        self.sourceHash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sourceHash(&'a self) -> &'a str {
        match self.sourceHash.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional string protocolVersion = 15;

    pub fn clear_protocolVersion(&mut self) {
        self.protocolVersion.clear();
    }

    pub fn has_protocolVersion(&self) -> bool {
        self.protocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocolVersion(&mut self, v: ::std::string::String) {
        self.protocolVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolVersion(&'a mut self) -> &'a mut ::std::string::String {
        if self.protocolVersion.is_none() {
            self.protocolVersion.set_default();
        };
        self.protocolVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocolVersion(&mut self) -> ::std::string::String {
        self.protocolVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocolVersion(&'a self) -> &'a str {
        match self.protocolVersion.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional string protocolCompilationDate = 16;

    pub fn clear_protocolCompilationDate(&mut self) {
        self.protocolCompilationDate.clear();
    }

    pub fn has_protocolCompilationDate(&self) -> bool {
        self.protocolCompilationDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocolCompilationDate(&mut self, v: ::std::string::String) {
        self.protocolCompilationDate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolCompilationDate(&'a mut self) -> &'a mut ::std::string::String {
        if self.protocolCompilationDate.is_none() {
            self.protocolCompilationDate.set_default();
        };
        self.protocolCompilationDate.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocolCompilationDate(&mut self) -> ::std::string::String {
        self.protocolCompilationDate.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocolCompilationDate(&'a self) -> &'a str {
        match self.protocolCompilationDate.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional string protocolSourceHash = 17;

    pub fn clear_protocolSourceHash(&mut self) {
        self.protocolSourceHash.clear();
    }

    pub fn has_protocolSourceHash(&self) -> bool {
        self.protocolSourceHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocolSourceHash(&mut self, v: ::std::string::String) {
        self.protocolSourceHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocolSourceHash(&'a mut self) -> &'a mut ::std::string::String {
        if self.protocolSourceHash.is_none() {
            self.protocolSourceHash.set_default();
        };
        self.protocolSourceHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocolSourceHash(&mut self) -> ::std::string::String {
        self.protocolSourceHash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocolSourceHash(&'a self) -> &'a str {
        match self.protocolSourceHash.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // repeated .com.seagate.kinetic.proto.Command.GetLog.Configuration.Interface interface = 9;

    pub fn clear_interface(&mut self) {
        self.interface.clear();
    }

    // Param is passed by value, moved
    pub fn set_interface(&mut self, v: ::protobuf::RepeatedField<Command_GetLog_Configuration_Interface>) {
        self.interface = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interface(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Command_GetLog_Configuration_Interface> {
        &mut self.interface
    }

    // Take field
    pub fn take_interface(&mut self) -> ::protobuf::RepeatedField<Command_GetLog_Configuration_Interface> {
        ::std::mem::replace(&mut self.interface, ::protobuf::RepeatedField::new())
    }

    pub fn get_interface(&'a self) -> &'a [Command_GetLog_Configuration_Interface] {
        self.interface.as_slice()
    }

    // optional int32 port = 10;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Some(v);
    }

    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    // optional int32 tlsPort = 11;

    pub fn clear_tlsPort(&mut self) {
        self.tlsPort = ::std::option::None;
    }

    pub fn has_tlsPort(&self) -> bool {
        self.tlsPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tlsPort(&mut self, v: i32) {
        self.tlsPort = ::std::option::Some(v);
    }

    pub fn get_tlsPort(&self) -> i32 {
        self.tlsPort.unwrap_or(0)
    }
}

impl ::protobuf::Message for Command_GetLog_Configuration {
    fn new() -> Command_GetLog_Configuration {
        Command_GetLog_Configuration::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.vendor.set_default();
                    try!(is.read_string_into(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.model.set_default();
                    try!(is.read_string_into(tmp))
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.serialNumber.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.worldWideName.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.version.set_default();
                    try!(is.read_string_into(tmp))
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.compilationDate.set_default();
                    try!(is.read_string_into(tmp))
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.sourceHash.set_default();
                    try!(is.read_string_into(tmp))
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.protocolVersion.set_default();
                    try!(is.read_string_into(tmp))
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.protocolCompilationDate.set_default();
                    try!(is.read_string_into(tmp))
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.protocolSourceHash.set_default();
                    try!(is.read_string_into(tmp))
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.interface.push_default();
                    try!(is.merge_message(tmp))
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.port = ::std::option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int32());
                    self.tlsPort = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.vendor.iter() {
            my_size += ::protobuf::rt::string_size(5, value.as_slice());
        };
        for value in self.model.iter() {
            my_size += ::protobuf::rt::string_size(6, value.as_slice());
        };
        for value in self.serialNumber.iter() {
            my_size += ::protobuf::rt::bytes_size(7, value.as_slice());
        };
        for value in self.worldWideName.iter() {
            my_size += ::protobuf::rt::bytes_size(14, value.as_slice());
        };
        for value in self.version.iter() {
            my_size += ::protobuf::rt::string_size(8, value.as_slice());
        };
        for value in self.compilationDate.iter() {
            my_size += ::protobuf::rt::string_size(12, value.as_slice());
        };
        for value in self.sourceHash.iter() {
            my_size += ::protobuf::rt::string_size(13, value.as_slice());
        };
        for value in self.protocolVersion.iter() {
            my_size += ::protobuf::rt::string_size(15, value.as_slice());
        };
        for value in self.protocolCompilationDate.iter() {
            my_size += ::protobuf::rt::string_size(16, value.as_slice());
        };
        for value in self.protocolSourceHash.iter() {
            my_size += ::protobuf::rt::string_size(17, value.as_slice());
        };
        for value in self.interface.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.tlsPort.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.vendor.as_ref() {
            Some(v) => {
                try!(os.write_string(5, v.as_slice()));
            },
            None => {},
        };
        match self.model.as_ref() {
            Some(v) => {
                try!(os.write_string(6, v.as_slice()));
            },
            None => {},
        };
        match self.serialNumber.as_ref() {
            Some(v) => {
                try!(os.write_bytes(7, v.as_slice()));
            },
            None => {},
        };
        match self.worldWideName.as_ref() {
            Some(v) => {
                try!(os.write_bytes(14, v.as_slice()));
            },
            None => {},
        };
        match self.version.as_ref() {
            Some(v) => {
                try!(os.write_string(8, v.as_slice()));
            },
            None => {},
        };
        match self.compilationDate.as_ref() {
            Some(v) => {
                try!(os.write_string(12, v.as_slice()));
            },
            None => {},
        };
        match self.sourceHash.as_ref() {
            Some(v) => {
                try!(os.write_string(13, v.as_slice()));
            },
            None => {},
        };
        match self.protocolVersion.as_ref() {
            Some(v) => {
                try!(os.write_string(15, v.as_slice()));
            },
            None => {},
        };
        match self.protocolCompilationDate.as_ref() {
            Some(v) => {
                try!(os.write_string(16, v.as_slice()));
            },
            None => {},
        };
        match self.protocolSourceHash.as_ref() {
            Some(v) => {
                try!(os.write_string(17, v.as_slice()));
            },
            None => {},
        };
        for v in self.interface.iter() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        match self.port {
            Some(v) => {
                try!(os.write_int32(10, v));
            },
            None => {},
        };
        match self.tlsPort {
            Some(v) => {
                try!(os.write_int32(11, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog_Configuration>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_vendor_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_model_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_serialNumber_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_worldWideName_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_version_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_compilationDate_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_sourceHash_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_protocolVersion_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_protocolCompilationDate_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_protocolSourceHash_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_interface_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_port_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_tlsPort_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog_Configuration>(
                    "Command_GetLog_Configuration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog_Configuration>()
    }
}

impl ::protobuf::Clear for Command_GetLog_Configuration {
    fn clear(&mut self) {
        self.clear_vendor();
        self.clear_model();
        self.clear_serialNumber();
        self.clear_worldWideName();
        self.clear_version();
        self.clear_compilationDate();
        self.clear_sourceHash();
        self.clear_protocolVersion();
        self.clear_protocolCompilationDate();
        self.clear_protocolSourceHash();
        self.clear_interface();
        self.clear_port();
        self.clear_tlsPort();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog_Configuration {
    fn eq(&self, other: &Command_GetLog_Configuration) -> bool {
        self.vendor == other.vendor &&
        self.model == other.model &&
        self.serialNumber == other.serialNumber &&
        self.worldWideName == other.worldWideName &&
        self.version == other.version &&
        self.compilationDate == other.compilationDate &&
        self.sourceHash == other.sourceHash &&
        self.protocolVersion == other.protocolVersion &&
        self.protocolCompilationDate == other.protocolCompilationDate &&
        self.protocolSourceHash == other.protocolSourceHash &&
        self.interface == other.interface &&
        self.port == other.port &&
        self.tlsPort == other.tlsPort &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog_Configuration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_vendor_acc_type;
static Command_GetLog_Configuration_vendor_acc: Command_GetLog_Configuration_vendor_acc_type = Command_GetLog_Configuration_vendor_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_vendor_acc_type {
    fn name(&self) -> &'static str {
        "vendor"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_vendor()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a str {
        m.get_vendor()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_model_acc_type;
static Command_GetLog_Configuration_model_acc: Command_GetLog_Configuration_model_acc_type = Command_GetLog_Configuration_model_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_model_acc_type {
    fn name(&self) -> &'static str {
        "model"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_model()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a str {
        m.get_model()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_serialNumber_acc_type;
static Command_GetLog_Configuration_serialNumber_acc: Command_GetLog_Configuration_serialNumber_acc_type = Command_GetLog_Configuration_serialNumber_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_serialNumber_acc_type {
    fn name(&self) -> &'static str {
        "serialNumber"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_serialNumber()
    }

    fn get_bytes<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a [u8] {
        m.get_serialNumber()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_worldWideName_acc_type;
static Command_GetLog_Configuration_worldWideName_acc: Command_GetLog_Configuration_worldWideName_acc_type = Command_GetLog_Configuration_worldWideName_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_worldWideName_acc_type {
    fn name(&self) -> &'static str {
        "worldWideName"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_worldWideName()
    }

    fn get_bytes<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a [u8] {
        m.get_worldWideName()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_version_acc_type;
static Command_GetLog_Configuration_version_acc: Command_GetLog_Configuration_version_acc_type = Command_GetLog_Configuration_version_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_version_acc_type {
    fn name(&self) -> &'static str {
        "version"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_version()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a str {
        m.get_version()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_compilationDate_acc_type;
static Command_GetLog_Configuration_compilationDate_acc: Command_GetLog_Configuration_compilationDate_acc_type = Command_GetLog_Configuration_compilationDate_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_compilationDate_acc_type {
    fn name(&self) -> &'static str {
        "compilationDate"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_compilationDate()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a str {
        m.get_compilationDate()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_sourceHash_acc_type;
static Command_GetLog_Configuration_sourceHash_acc: Command_GetLog_Configuration_sourceHash_acc_type = Command_GetLog_Configuration_sourceHash_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_sourceHash_acc_type {
    fn name(&self) -> &'static str {
        "sourceHash"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_sourceHash()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a str {
        m.get_sourceHash()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_protocolVersion_acc_type;
static Command_GetLog_Configuration_protocolVersion_acc: Command_GetLog_Configuration_protocolVersion_acc_type = Command_GetLog_Configuration_protocolVersion_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_protocolVersion_acc_type {
    fn name(&self) -> &'static str {
        "protocolVersion"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_protocolVersion()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a str {
        m.get_protocolVersion()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_protocolCompilationDate_acc_type;
static Command_GetLog_Configuration_protocolCompilationDate_acc: Command_GetLog_Configuration_protocolCompilationDate_acc_type = Command_GetLog_Configuration_protocolCompilationDate_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_protocolCompilationDate_acc_type {
    fn name(&self) -> &'static str {
        "protocolCompilationDate"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_protocolCompilationDate()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a str {
        m.get_protocolCompilationDate()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_protocolSourceHash_acc_type;
static Command_GetLog_Configuration_protocolSourceHash_acc: Command_GetLog_Configuration_protocolSourceHash_acc_type = Command_GetLog_Configuration_protocolSourceHash_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_protocolSourceHash_acc_type {
    fn name(&self) -> &'static str {
        "protocolSourceHash"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_protocolSourceHash()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration) -> &'a str {
        m.get_protocolSourceHash()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_interface_acc_type;
static Command_GetLog_Configuration_interface_acc: Command_GetLog_Configuration_interface_acc_type = Command_GetLog_Configuration_interface_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_interface_acc_type {
    fn name(&self) -> &'static str {
        "interface"
    }

    fn len_field(&self, m: &Command_GetLog_Configuration) -> uint {
        m.get_interface().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a Command_GetLog_Configuration, index: uint) -> &'a ::protobuf::Message {
        &m.get_interface()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_port_acc_type;
static Command_GetLog_Configuration_port_acc: Command_GetLog_Configuration_port_acc_type = Command_GetLog_Configuration_port_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_port_acc_type {
    fn name(&self) -> &'static str {
        "port"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_port()
    }

    fn get_i32(&self, m: &Command_GetLog_Configuration) -> i32 {
        m.get_port()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_tlsPort_acc_type;
static Command_GetLog_Configuration_tlsPort_acc: Command_GetLog_Configuration_tlsPort_acc_type = Command_GetLog_Configuration_tlsPort_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration> for Command_GetLog_Configuration_tlsPort_acc_type {
    fn name(&self) -> &'static str {
        "tlsPort"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration) -> bool {
        m.has_tlsPort()
    }

    fn get_i32(&self, m: &Command_GetLog_Configuration) -> i32 {
        m.get_tlsPort()
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog_Configuration_Interface {
    name: ::protobuf::SingularField<::std::string::String>,
    MAC: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ipv4Address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ipv6Address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog_Configuration_Interface {
    pub fn new() -> Command_GetLog_Configuration_Interface {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog_Configuration_Interface {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog_Configuration_Interface> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog_Configuration_Interface,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog_Configuration_Interface {
                    name: ::protobuf::SingularField::none(),
                    MAC: ::protobuf::SingularField::none(),
                    ipv4Address: ::protobuf::SingularField::none(),
                    ipv6Address: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => v.as_slice(),
            None => "",
        }
    }

    // optional bytes MAC = 2;

    pub fn clear_MAC(&mut self) {
        self.MAC.clear();
    }

    pub fn has_MAC(&self) -> bool {
        self.MAC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_MAC(&mut self, v: ::std::vec::Vec<u8>) {
        self.MAC = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_MAC(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.MAC.is_none() {
            self.MAC.set_default();
        };
        self.MAC.as_mut().unwrap()
    }

    // Take field
    pub fn take_MAC(&mut self) -> ::std::vec::Vec<u8> {
        self.MAC.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_MAC(&'a self) -> &'a [u8] {
        match self.MAC.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes ipv4Address = 3;

    pub fn clear_ipv4Address(&mut self) {
        self.ipv4Address.clear();
    }

    pub fn has_ipv4Address(&self) -> bool {
        self.ipv4Address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4Address(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv4Address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv4Address(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.ipv4Address.is_none() {
            self.ipv4Address.set_default();
        };
        self.ipv4Address.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv4Address(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv4Address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_ipv4Address(&'a self) -> &'a [u8] {
        match self.ipv4Address.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes ipv6Address = 4;

    pub fn clear_ipv6Address(&mut self) {
        self.ipv6Address.clear();
    }

    pub fn has_ipv6Address(&self) -> bool {
        self.ipv6Address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6Address(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipv6Address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6Address(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.ipv6Address.is_none() {
            self.ipv6Address.set_default();
        };
        self.ipv6Address.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6Address(&mut self) -> ::std::vec::Vec<u8> {
        self.ipv6Address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_ipv6Address(&'a self) -> &'a [u8] {
        match self.ipv6Address.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for Command_GetLog_Configuration_Interface {
    fn new() -> Command_GetLog_Configuration_Interface {
        Command_GetLog_Configuration_Interface::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_string_into(tmp))
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.MAC.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ipv4Address.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.ipv6Address.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, value.as_slice());
        };
        for value in self.MAC.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        for value in self.ipv4Address.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        for value in self.ipv6Address.iter() {
            my_size += ::protobuf::rt::bytes_size(4, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.name.as_ref() {
            Some(v) => {
                try!(os.write_string(1, v.as_slice()));
            },
            None => {},
        };
        match self.MAC.as_ref() {
            Some(v) => {
                try!(os.write_bytes(2, v.as_slice()));
            },
            None => {},
        };
        match self.ipv4Address.as_ref() {
            Some(v) => {
                try!(os.write_bytes(3, v.as_slice()));
            },
            None => {},
        };
        match self.ipv6Address.as_ref() {
            Some(v) => {
                try!(os.write_bytes(4, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog_Configuration_Interface>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_Interface_name_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_Interface_MAC_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_Interface_ipv4Address_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Configuration_Interface_ipv6Address_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog_Configuration_Interface>(
                    "Command_GetLog_Configuration_Interface",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog_Configuration_Interface>()
    }
}

impl ::protobuf::Clear for Command_GetLog_Configuration_Interface {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_MAC();
        self.clear_ipv4Address();
        self.clear_ipv6Address();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog_Configuration_Interface {
    fn eq(&self, other: &Command_GetLog_Configuration_Interface) -> bool {
        self.name == other.name &&
        self.MAC == other.MAC &&
        self.ipv4Address == other.ipv4Address &&
        self.ipv6Address == other.ipv6Address &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog_Configuration_Interface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_Interface_name_acc_type;
static Command_GetLog_Configuration_Interface_name_acc: Command_GetLog_Configuration_Interface_name_acc_type = Command_GetLog_Configuration_Interface_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface> for Command_GetLog_Configuration_Interface_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration_Interface) -> bool {
        m.has_name()
    }

    fn get_str<'a>(&self, m: &'a Command_GetLog_Configuration_Interface) -> &'a str {
        m.get_name()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_Interface_MAC_acc_type;
static Command_GetLog_Configuration_Interface_MAC_acc: Command_GetLog_Configuration_Interface_MAC_acc_type = Command_GetLog_Configuration_Interface_MAC_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface> for Command_GetLog_Configuration_Interface_MAC_acc_type {
    fn name(&self) -> &'static str {
        "MAC"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration_Interface) -> bool {
        m.has_MAC()
    }

    fn get_bytes<'a>(&self, m: &'a Command_GetLog_Configuration_Interface) -> &'a [u8] {
        m.get_MAC()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_Interface_ipv4Address_acc_type;
static Command_GetLog_Configuration_Interface_ipv4Address_acc: Command_GetLog_Configuration_Interface_ipv4Address_acc_type = Command_GetLog_Configuration_Interface_ipv4Address_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface> for Command_GetLog_Configuration_Interface_ipv4Address_acc_type {
    fn name(&self) -> &'static str {
        "ipv4Address"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration_Interface) -> bool {
        m.has_ipv4Address()
    }

    fn get_bytes<'a>(&self, m: &'a Command_GetLog_Configuration_Interface) -> &'a [u8] {
        m.get_ipv4Address()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Configuration_Interface_ipv6Address_acc_type;
static Command_GetLog_Configuration_Interface_ipv6Address_acc: Command_GetLog_Configuration_Interface_ipv6Address_acc_type = Command_GetLog_Configuration_Interface_ipv6Address_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Configuration_Interface> for Command_GetLog_Configuration_Interface_ipv6Address_acc_type {
    fn name(&self) -> &'static str {
        "ipv6Address"
    }

    fn has_field(&self, m: &Command_GetLog_Configuration_Interface) -> bool {
        m.has_ipv6Address()
    }

    fn get_bytes<'a>(&self, m: &'a Command_GetLog_Configuration_Interface) -> &'a [u8] {
        m.get_ipv6Address()
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog_Statistics {
    messageType: ::std::option::Option<Command_MessageType>,
    count: ::std::option::Option<u64>,
    bytes: ::std::option::Option<u64>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog_Statistics {
    pub fn new() -> Command_GetLog_Statistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog_Statistics {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog_Statistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog_Statistics,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog_Statistics {
                    messageType: ::std::option::None,
                    count: ::std::option::None,
                    bytes: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .com.seagate.kinetic.proto.Command.MessageType messageType = 1;

    pub fn clear_messageType(&mut self) {
        self.messageType = ::std::option::None;
    }

    pub fn has_messageType(&self) -> bool {
        self.messageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageType(&mut self, v: Command_MessageType) {
        self.messageType = ::std::option::Some(v);
    }

    pub fn get_messageType(&self) -> Command_MessageType {
        self.messageType.unwrap_or(Command_MessageType::INVALID_MESSAGE_TYPE)
    }

    // optional uint64 count = 4;

    pub fn clear_count(&mut self) {
        self.count = ::std::option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = ::std::option::Some(v);
    }

    pub fn get_count(&self) -> u64 {
        self.count.unwrap_or(0)
    }

    // optional uint64 bytes = 5;

    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = ::std::option::Some(v);
    }

    pub fn get_bytes(&self) -> u64 {
        self.bytes.unwrap_or(0)
    }
}

impl ::protobuf::Message for Command_GetLog_Statistics {
    fn new() -> Command_GetLog_Statistics {
        Command_GetLog_Statistics::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.messageType = ::std::option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.count = ::std::option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.messageType.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.count.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.messageType {
            Some(v) => {
                try!(os.write_enum(1, v as i32));
            },
            None => {},
        };
        match self.count {
            Some(v) => {
                try!(os.write_uint64(4, v));
            },
            None => {},
        };
        match self.bytes {
            Some(v) => {
                try!(os.write_uint64(5, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog_Statistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Statistics>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Statistics_messageType_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Statistics>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Statistics_count_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Statistics>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Statistics_bytes_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Statistics>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog_Statistics>(
                    "Command_GetLog_Statistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog_Statistics>()
    }
}

impl ::protobuf::Clear for Command_GetLog_Statistics {
    fn clear(&mut self) {
        self.clear_messageType();
        self.clear_count();
        self.clear_bytes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog_Statistics {
    fn eq(&self, other: &Command_GetLog_Statistics) -> bool {
        self.messageType == other.messageType &&
        self.count == other.count &&
        self.bytes == other.bytes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog_Statistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_Statistics_messageType_acc_type;
static Command_GetLog_Statistics_messageType_acc: Command_GetLog_Statistics_messageType_acc_type = Command_GetLog_Statistics_messageType_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Statistics> for Command_GetLog_Statistics_messageType_acc_type {
    fn name(&self) -> &'static str {
        "messageType"
    }

    fn has_field(&self, m: &Command_GetLog_Statistics) -> bool {
        m.has_messageType()
    }

    fn get_enum<'a>(&self, m: &Command_GetLog_Statistics) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_messageType().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Statistics_count_acc_type;
static Command_GetLog_Statistics_count_acc: Command_GetLog_Statistics_count_acc_type = Command_GetLog_Statistics_count_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Statistics> for Command_GetLog_Statistics_count_acc_type {
    fn name(&self) -> &'static str {
        "count"
    }

    fn has_field(&self, m: &Command_GetLog_Statistics) -> bool {
        m.has_count()
    }

    fn get_u64(&self, m: &Command_GetLog_Statistics) -> u64 {
        m.get_count()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Statistics_bytes_acc_type;
static Command_GetLog_Statistics_bytes_acc: Command_GetLog_Statistics_bytes_acc_type = Command_GetLog_Statistics_bytes_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Statistics> for Command_GetLog_Statistics_bytes_acc_type {
    fn name(&self) -> &'static str {
        "bytes"
    }

    fn has_field(&self, m: &Command_GetLog_Statistics) -> bool {
        m.has_bytes()
    }

    fn get_u64(&self, m: &Command_GetLog_Statistics) -> u64 {
        m.get_bytes()
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog_Limits {
    maxKeySize: ::std::option::Option<u32>,
    maxValueSize: ::std::option::Option<u32>,
    maxVersionSize: ::std::option::Option<u32>,
    maxTagSize: ::std::option::Option<u32>,
    maxConnections: ::std::option::Option<u32>,
    maxOutstandingReadRequests: ::std::option::Option<u32>,
    maxOutstandingWriteRequests: ::std::option::Option<u32>,
    maxMessageSize: ::std::option::Option<u32>,
    maxKeyRangeCount: ::std::option::Option<u32>,
    maxIdentityCount: ::std::option::Option<u32>,
    maxPinSize: ::std::option::Option<u32>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog_Limits {
    pub fn new() -> Command_GetLog_Limits {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog_Limits {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog_Limits> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog_Limits,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog_Limits {
                    maxKeySize: ::std::option::None,
                    maxValueSize: ::std::option::None,
                    maxVersionSize: ::std::option::None,
                    maxTagSize: ::std::option::None,
                    maxConnections: ::std::option::None,
                    maxOutstandingReadRequests: ::std::option::None,
                    maxOutstandingWriteRequests: ::std::option::None,
                    maxMessageSize: ::std::option::None,
                    maxKeyRangeCount: ::std::option::None,
                    maxIdentityCount: ::std::option::None,
                    maxPinSize: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 maxKeySize = 1;

    pub fn clear_maxKeySize(&mut self) {
        self.maxKeySize = ::std::option::None;
    }

    pub fn has_maxKeySize(&self) -> bool {
        self.maxKeySize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxKeySize(&mut self, v: u32) {
        self.maxKeySize = ::std::option::Some(v);
    }

    pub fn get_maxKeySize(&self) -> u32 {
        self.maxKeySize.unwrap_or(0)
    }

    // optional uint32 maxValueSize = 2;

    pub fn clear_maxValueSize(&mut self) {
        self.maxValueSize = ::std::option::None;
    }

    pub fn has_maxValueSize(&self) -> bool {
        self.maxValueSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxValueSize(&mut self, v: u32) {
        self.maxValueSize = ::std::option::Some(v);
    }

    pub fn get_maxValueSize(&self) -> u32 {
        self.maxValueSize.unwrap_or(0)
    }

    // optional uint32 maxVersionSize = 3;

    pub fn clear_maxVersionSize(&mut self) {
        self.maxVersionSize = ::std::option::None;
    }

    pub fn has_maxVersionSize(&self) -> bool {
        self.maxVersionSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxVersionSize(&mut self, v: u32) {
        self.maxVersionSize = ::std::option::Some(v);
    }

    pub fn get_maxVersionSize(&self) -> u32 {
        self.maxVersionSize.unwrap_or(0)
    }

    // optional uint32 maxTagSize = 4;

    pub fn clear_maxTagSize(&mut self) {
        self.maxTagSize = ::std::option::None;
    }

    pub fn has_maxTagSize(&self) -> bool {
        self.maxTagSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxTagSize(&mut self, v: u32) {
        self.maxTagSize = ::std::option::Some(v);
    }

    pub fn get_maxTagSize(&self) -> u32 {
        self.maxTagSize.unwrap_or(0)
    }

    // optional uint32 maxConnections = 5;

    pub fn clear_maxConnections(&mut self) {
        self.maxConnections = ::std::option::None;
    }

    pub fn has_maxConnections(&self) -> bool {
        self.maxConnections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxConnections(&mut self, v: u32) {
        self.maxConnections = ::std::option::Some(v);
    }

    pub fn get_maxConnections(&self) -> u32 {
        self.maxConnections.unwrap_or(0)
    }

    // optional uint32 maxOutstandingReadRequests = 6;

    pub fn clear_maxOutstandingReadRequests(&mut self) {
        self.maxOutstandingReadRequests = ::std::option::None;
    }

    pub fn has_maxOutstandingReadRequests(&self) -> bool {
        self.maxOutstandingReadRequests.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxOutstandingReadRequests(&mut self, v: u32) {
        self.maxOutstandingReadRequests = ::std::option::Some(v);
    }

    pub fn get_maxOutstandingReadRequests(&self) -> u32 {
        self.maxOutstandingReadRequests.unwrap_or(0)
    }

    // optional uint32 maxOutstandingWriteRequests = 7;

    pub fn clear_maxOutstandingWriteRequests(&mut self) {
        self.maxOutstandingWriteRequests = ::std::option::None;
    }

    pub fn has_maxOutstandingWriteRequests(&self) -> bool {
        self.maxOutstandingWriteRequests.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxOutstandingWriteRequests(&mut self, v: u32) {
        self.maxOutstandingWriteRequests = ::std::option::Some(v);
    }

    pub fn get_maxOutstandingWriteRequests(&self) -> u32 {
        self.maxOutstandingWriteRequests.unwrap_or(0)
    }

    // optional uint32 maxMessageSize = 8;

    pub fn clear_maxMessageSize(&mut self) {
        self.maxMessageSize = ::std::option::None;
    }

    pub fn has_maxMessageSize(&self) -> bool {
        self.maxMessageSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxMessageSize(&mut self, v: u32) {
        self.maxMessageSize = ::std::option::Some(v);
    }

    pub fn get_maxMessageSize(&self) -> u32 {
        self.maxMessageSize.unwrap_or(0)
    }

    // optional uint32 maxKeyRangeCount = 9;

    pub fn clear_maxKeyRangeCount(&mut self) {
        self.maxKeyRangeCount = ::std::option::None;
    }

    pub fn has_maxKeyRangeCount(&self) -> bool {
        self.maxKeyRangeCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxKeyRangeCount(&mut self, v: u32) {
        self.maxKeyRangeCount = ::std::option::Some(v);
    }

    pub fn get_maxKeyRangeCount(&self) -> u32 {
        self.maxKeyRangeCount.unwrap_or(0)
    }

    // optional uint32 maxIdentityCount = 10;

    pub fn clear_maxIdentityCount(&mut self) {
        self.maxIdentityCount = ::std::option::None;
    }

    pub fn has_maxIdentityCount(&self) -> bool {
        self.maxIdentityCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxIdentityCount(&mut self, v: u32) {
        self.maxIdentityCount = ::std::option::Some(v);
    }

    pub fn get_maxIdentityCount(&self) -> u32 {
        self.maxIdentityCount.unwrap_or(0)
    }

    // optional uint32 maxPinSize = 11;

    pub fn clear_maxPinSize(&mut self) {
        self.maxPinSize = ::std::option::None;
    }

    pub fn has_maxPinSize(&self) -> bool {
        self.maxPinSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxPinSize(&mut self, v: u32) {
        self.maxPinSize = ::std::option::Some(v);
    }

    pub fn get_maxPinSize(&self) -> u32 {
        self.maxPinSize.unwrap_or(0)
    }
}

impl ::protobuf::Message for Command_GetLog_Limits {
    fn new() -> Command_GetLog_Limits {
        Command_GetLog_Limits::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxKeySize = ::std::option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxValueSize = ::std::option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxVersionSize = ::std::option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxTagSize = ::std::option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxConnections = ::std::option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxOutstandingReadRequests = ::std::option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxOutstandingWriteRequests = ::std::option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxMessageSize = ::std::option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxKeyRangeCount = ::std::option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxIdentityCount = ::std::option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_uint32());
                    self.maxPinSize = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.maxKeySize.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxValueSize.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxVersionSize.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxTagSize.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxConnections.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxOutstandingReadRequests.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxOutstandingWriteRequests.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxMessageSize.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxKeyRangeCount.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxIdentityCount.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.maxPinSize.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.maxKeySize {
            Some(v) => {
                try!(os.write_uint32(1, v));
            },
            None => {},
        };
        match self.maxValueSize {
            Some(v) => {
                try!(os.write_uint32(2, v));
            },
            None => {},
        };
        match self.maxVersionSize {
            Some(v) => {
                try!(os.write_uint32(3, v));
            },
            None => {},
        };
        match self.maxTagSize {
            Some(v) => {
                try!(os.write_uint32(4, v));
            },
            None => {},
        };
        match self.maxConnections {
            Some(v) => {
                try!(os.write_uint32(5, v));
            },
            None => {},
        };
        match self.maxOutstandingReadRequests {
            Some(v) => {
                try!(os.write_uint32(6, v));
            },
            None => {},
        };
        match self.maxOutstandingWriteRequests {
            Some(v) => {
                try!(os.write_uint32(7, v));
            },
            None => {},
        };
        match self.maxMessageSize {
            Some(v) => {
                try!(os.write_uint32(8, v));
            },
            None => {},
        };
        match self.maxKeyRangeCount {
            Some(v) => {
                try!(os.write_uint32(9, v));
            },
            None => {},
        };
        match self.maxIdentityCount {
            Some(v) => {
                try!(os.write_uint32(10, v));
            },
            None => {},
        };
        match self.maxPinSize {
            Some(v) => {
                try!(os.write_uint32(11, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog_Limits>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxKeySize_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxValueSize_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxVersionSize_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxTagSize_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxConnections_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxOutstandingReadRequests_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxOutstandingWriteRequests_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxMessageSize_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxKeyRangeCount_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxIdentityCount_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Limits_maxPinSize_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog_Limits>(
                    "Command_GetLog_Limits",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog_Limits>()
    }
}

impl ::protobuf::Clear for Command_GetLog_Limits {
    fn clear(&mut self) {
        self.clear_maxKeySize();
        self.clear_maxValueSize();
        self.clear_maxVersionSize();
        self.clear_maxTagSize();
        self.clear_maxConnections();
        self.clear_maxOutstandingReadRequests();
        self.clear_maxOutstandingWriteRequests();
        self.clear_maxMessageSize();
        self.clear_maxKeyRangeCount();
        self.clear_maxIdentityCount();
        self.clear_maxPinSize();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog_Limits {
    fn eq(&self, other: &Command_GetLog_Limits) -> bool {
        self.maxKeySize == other.maxKeySize &&
        self.maxValueSize == other.maxValueSize &&
        self.maxVersionSize == other.maxVersionSize &&
        self.maxTagSize == other.maxTagSize &&
        self.maxConnections == other.maxConnections &&
        self.maxOutstandingReadRequests == other.maxOutstandingReadRequests &&
        self.maxOutstandingWriteRequests == other.maxOutstandingWriteRequests &&
        self.maxMessageSize == other.maxMessageSize &&
        self.maxKeyRangeCount == other.maxKeyRangeCount &&
        self.maxIdentityCount == other.maxIdentityCount &&
        self.maxPinSize == other.maxPinSize &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog_Limits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxKeySize_acc_type;
static Command_GetLog_Limits_maxKeySize_acc: Command_GetLog_Limits_maxKeySize_acc_type = Command_GetLog_Limits_maxKeySize_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxKeySize_acc_type {
    fn name(&self) -> &'static str {
        "maxKeySize"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxKeySize()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxKeySize()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxValueSize_acc_type;
static Command_GetLog_Limits_maxValueSize_acc: Command_GetLog_Limits_maxValueSize_acc_type = Command_GetLog_Limits_maxValueSize_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxValueSize_acc_type {
    fn name(&self) -> &'static str {
        "maxValueSize"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxValueSize()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxValueSize()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxVersionSize_acc_type;
static Command_GetLog_Limits_maxVersionSize_acc: Command_GetLog_Limits_maxVersionSize_acc_type = Command_GetLog_Limits_maxVersionSize_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxVersionSize_acc_type {
    fn name(&self) -> &'static str {
        "maxVersionSize"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxVersionSize()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxVersionSize()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxTagSize_acc_type;
static Command_GetLog_Limits_maxTagSize_acc: Command_GetLog_Limits_maxTagSize_acc_type = Command_GetLog_Limits_maxTagSize_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxTagSize_acc_type {
    fn name(&self) -> &'static str {
        "maxTagSize"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxTagSize()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxTagSize()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxConnections_acc_type;
static Command_GetLog_Limits_maxConnections_acc: Command_GetLog_Limits_maxConnections_acc_type = Command_GetLog_Limits_maxConnections_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxConnections_acc_type {
    fn name(&self) -> &'static str {
        "maxConnections"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxConnections()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxConnections()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxOutstandingReadRequests_acc_type;
static Command_GetLog_Limits_maxOutstandingReadRequests_acc: Command_GetLog_Limits_maxOutstandingReadRequests_acc_type = Command_GetLog_Limits_maxOutstandingReadRequests_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxOutstandingReadRequests_acc_type {
    fn name(&self) -> &'static str {
        "maxOutstandingReadRequests"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxOutstandingReadRequests()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxOutstandingReadRequests()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxOutstandingWriteRequests_acc_type;
static Command_GetLog_Limits_maxOutstandingWriteRequests_acc: Command_GetLog_Limits_maxOutstandingWriteRequests_acc_type = Command_GetLog_Limits_maxOutstandingWriteRequests_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxOutstandingWriteRequests_acc_type {
    fn name(&self) -> &'static str {
        "maxOutstandingWriteRequests"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxOutstandingWriteRequests()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxOutstandingWriteRequests()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxMessageSize_acc_type;
static Command_GetLog_Limits_maxMessageSize_acc: Command_GetLog_Limits_maxMessageSize_acc_type = Command_GetLog_Limits_maxMessageSize_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxMessageSize_acc_type {
    fn name(&self) -> &'static str {
        "maxMessageSize"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxMessageSize()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxMessageSize()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxKeyRangeCount_acc_type;
static Command_GetLog_Limits_maxKeyRangeCount_acc: Command_GetLog_Limits_maxKeyRangeCount_acc_type = Command_GetLog_Limits_maxKeyRangeCount_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxKeyRangeCount_acc_type {
    fn name(&self) -> &'static str {
        "maxKeyRangeCount"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxKeyRangeCount()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxKeyRangeCount()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxIdentityCount_acc_type;
static Command_GetLog_Limits_maxIdentityCount_acc: Command_GetLog_Limits_maxIdentityCount_acc_type = Command_GetLog_Limits_maxIdentityCount_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxIdentityCount_acc_type {
    fn name(&self) -> &'static str {
        "maxIdentityCount"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxIdentityCount()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxIdentityCount()
    }
}

#[allow(non_camel_case_types)]
struct Command_GetLog_Limits_maxPinSize_acc_type;
static Command_GetLog_Limits_maxPinSize_acc: Command_GetLog_Limits_maxPinSize_acc_type = Command_GetLog_Limits_maxPinSize_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Limits> for Command_GetLog_Limits_maxPinSize_acc_type {
    fn name(&self) -> &'static str {
        "maxPinSize"
    }

    fn has_field(&self, m: &Command_GetLog_Limits) -> bool {
        m.has_maxPinSize()
    }

    fn get_u32(&self, m: &Command_GetLog_Limits) -> u32 {
        m.get_maxPinSize()
    }
}

#[deriving(Clone,Default)]
pub struct Command_GetLog_Device {
    name: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_GetLog_Device {
    pub fn new() -> Command_GetLog_Device {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_GetLog_Device {
        static mut instance: ::protobuf::lazy::Lazy<Command_GetLog_Device> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_GetLog_Device,
        };
        unsafe {
            instance.get(|| {
                Command_GetLog_Device {
                    name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        self.name.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_name(&'a self) -> &'a [u8] {
        match self.name.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for Command_GetLog_Device {
    fn new() -> Command_GetLog_Device {
        Command_GetLog_Device::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.name.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::bytes_size(1, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.name.as_ref() {
            Some(v) => {
                try!(os.write_bytes(1, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_GetLog_Device>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Device>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_GetLog_Device_name_acc as &'static ::protobuf::reflect::FieldAccessor<Command_GetLog_Device>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_GetLog_Device>(
                    "Command_GetLog_Device",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_GetLog_Device>()
    }
}

impl ::protobuf::Clear for Command_GetLog_Device {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_GetLog_Device {
    fn eq(&self, other: &Command_GetLog_Device) -> bool {
        self.name == other.name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_GetLog_Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_GetLog_Device_name_acc_type;
static Command_GetLog_Device_name_acc: Command_GetLog_Device_name_acc_type = Command_GetLog_Device_name_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_GetLog_Device> for Command_GetLog_Device_name_acc_type {
    fn name(&self) -> &'static str {
        "name"
    }

    fn has_field(&self, m: &Command_GetLog_Device) -> bool {
        m.has_name()
    }

    fn get_bytes<'a>(&self, m: &'a Command_GetLog_Device) -> &'a [u8] {
        m.get_name()
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_GetLog_Type {
    INVALID_TYPE = -1,
    UTILIZATIONS = 0,
    TEMPERATURES = 1,
    CAPACITIES = 2,
    CONFIGURATION = 3,
    STATISTICS = 4,
    MESSAGES = 5,
    LIMITS = 6,
    DEVICE = 7,
}


impl ::protobuf::ProtobufEnum for Command_GetLog_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_GetLog_Type> {
        match value {
            -1 => ::std::option::Some(Command_GetLog_Type::INVALID_TYPE),
            0 => ::std::option::Some(Command_GetLog_Type::UTILIZATIONS),
            1 => ::std::option::Some(Command_GetLog_Type::TEMPERATURES),
            2 => ::std::option::Some(Command_GetLog_Type::CAPACITIES),
            3 => ::std::option::Some(Command_GetLog_Type::CONFIGURATION),
            4 => ::std::option::Some(Command_GetLog_Type::STATISTICS),
            5 => ::std::option::Some(Command_GetLog_Type::MESSAGES),
            6 => ::std::option::Some(Command_GetLog_Type::LIMITS),
            7 => ::std::option::Some(Command_GetLog_Type::DEVICE),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_GetLog_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_GetLog_Type", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,Default)]
pub struct Command_Security {
    acl: ::protobuf::RepeatedField<Command_Security_ACL>,
    oldLockPIN: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    newLockPIN: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    oldErasePIN: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    newErasePIN: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_Security {
    pub fn new() -> Command_Security {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_Security {
        static mut instance: ::protobuf::lazy::Lazy<Command_Security> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_Security,
        };
        unsafe {
            instance.get(|| {
                Command_Security {
                    acl: ::protobuf::RepeatedField::new(),
                    oldLockPIN: ::protobuf::SingularField::none(),
                    newLockPIN: ::protobuf::SingularField::none(),
                    oldErasePIN: ::protobuf::SingularField::none(),
                    newErasePIN: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .com.seagate.kinetic.proto.Command.Security.ACL acl = 2;

    pub fn clear_acl(&mut self) {
        self.acl.clear();
    }

    // Param is passed by value, moved
    pub fn set_acl(&mut self, v: ::protobuf::RepeatedField<Command_Security_ACL>) {
        self.acl = v;
    }

    // Mutable pointer to the field.
    pub fn mut_acl(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Command_Security_ACL> {
        &mut self.acl
    }

    // Take field
    pub fn take_acl(&mut self) -> ::protobuf::RepeatedField<Command_Security_ACL> {
        ::std::mem::replace(&mut self.acl, ::protobuf::RepeatedField::new())
    }

    pub fn get_acl(&'a self) -> &'a [Command_Security_ACL] {
        self.acl.as_slice()
    }

    // optional bytes oldLockPIN = 3;

    pub fn clear_oldLockPIN(&mut self) {
        self.oldLockPIN.clear();
    }

    pub fn has_oldLockPIN(&self) -> bool {
        self.oldLockPIN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldLockPIN(&mut self, v: ::std::vec::Vec<u8>) {
        self.oldLockPIN = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldLockPIN(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.oldLockPIN.is_none() {
            self.oldLockPIN.set_default();
        };
        self.oldLockPIN.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldLockPIN(&mut self) -> ::std::vec::Vec<u8> {
        self.oldLockPIN.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_oldLockPIN(&'a self) -> &'a [u8] {
        match self.oldLockPIN.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes newLockPIN = 4;

    pub fn clear_newLockPIN(&mut self) {
        self.newLockPIN.clear();
    }

    pub fn has_newLockPIN(&self) -> bool {
        self.newLockPIN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newLockPIN(&mut self, v: ::std::vec::Vec<u8>) {
        self.newLockPIN = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newLockPIN(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.newLockPIN.is_none() {
            self.newLockPIN.set_default();
        };
        self.newLockPIN.as_mut().unwrap()
    }

    // Take field
    pub fn take_newLockPIN(&mut self) -> ::std::vec::Vec<u8> {
        self.newLockPIN.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_newLockPIN(&'a self) -> &'a [u8] {
        match self.newLockPIN.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes oldErasePIN = 5;

    pub fn clear_oldErasePIN(&mut self) {
        self.oldErasePIN.clear();
    }

    pub fn has_oldErasePIN(&self) -> bool {
        self.oldErasePIN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldErasePIN(&mut self, v: ::std::vec::Vec<u8>) {
        self.oldErasePIN = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldErasePIN(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.oldErasePIN.is_none() {
            self.oldErasePIN.set_default();
        };
        self.oldErasePIN.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldErasePIN(&mut self) -> ::std::vec::Vec<u8> {
        self.oldErasePIN.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_oldErasePIN(&'a self) -> &'a [u8] {
        match self.oldErasePIN.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional bytes newErasePIN = 6;

    pub fn clear_newErasePIN(&mut self) {
        self.newErasePIN.clear();
    }

    pub fn has_newErasePIN(&self) -> bool {
        self.newErasePIN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newErasePIN(&mut self, v: ::std::vec::Vec<u8>) {
        self.newErasePIN = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newErasePIN(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.newErasePIN.is_none() {
            self.newErasePIN.set_default();
        };
        self.newErasePIN.as_mut().unwrap()
    }

    // Take field
    pub fn take_newErasePIN(&mut self) -> ::std::vec::Vec<u8> {
        self.newErasePIN.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_newErasePIN(&'a self) -> &'a [u8] {
        match self.newErasePIN.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }
}

impl ::protobuf::Message for Command_Security {
    fn new() -> Command_Security {
        Command_Security::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.acl.push_default();
                    try!(is.merge_message(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.oldLockPIN.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.newLockPIN.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.oldErasePIN.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.newErasePIN.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.acl.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.oldLockPIN.iter() {
            my_size += ::protobuf::rt::bytes_size(3, value.as_slice());
        };
        for value in self.newLockPIN.iter() {
            my_size += ::protobuf::rt::bytes_size(4, value.as_slice());
        };
        for value in self.oldErasePIN.iter() {
            my_size += ::protobuf::rt::bytes_size(5, value.as_slice());
        };
        for value in self.newErasePIN.iter() {
            my_size += ::protobuf::rt::bytes_size(6, value.as_slice());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.acl.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        match self.oldLockPIN.as_ref() {
            Some(v) => {
                try!(os.write_bytes(3, v.as_slice()));
            },
            None => {},
        };
        match self.newLockPIN.as_ref() {
            Some(v) => {
                try!(os.write_bytes(4, v.as_slice()));
            },
            None => {},
        };
        match self.oldErasePIN.as_ref() {
            Some(v) => {
                try!(os.write_bytes(5, v.as_slice()));
            },
            None => {},
        };
        match self.newErasePIN.as_ref() {
            Some(v) => {
                try!(os.write_bytes(6, v.as_slice()));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_Security>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_Security>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_acl_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_oldLockPIN_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_newLockPIN_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_oldErasePIN_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_newErasePIN_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_Security>(
                    "Command_Security",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_Security>()
    }
}

impl ::protobuf::Clear for Command_Security {
    fn clear(&mut self) {
        self.clear_acl();
        self.clear_oldLockPIN();
        self.clear_newLockPIN();
        self.clear_oldErasePIN();
        self.clear_newErasePIN();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_Security {
    fn eq(&self, other: &Command_Security) -> bool {
        self.acl == other.acl &&
        self.oldLockPIN == other.oldLockPIN &&
        self.newLockPIN == other.newLockPIN &&
        self.oldErasePIN == other.oldErasePIN &&
        self.newErasePIN == other.newErasePIN &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_Security {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_Security_acl_acc_type;
static Command_Security_acl_acc: Command_Security_acl_acc_type = Command_Security_acl_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security> for Command_Security_acl_acc_type {
    fn name(&self) -> &'static str {
        "acl"
    }

    fn len_field(&self, m: &Command_Security) -> uint {
        m.get_acl().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a Command_Security, index: uint) -> &'a ::protobuf::Message {
        &m.get_acl()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_oldLockPIN_acc_type;
static Command_Security_oldLockPIN_acc: Command_Security_oldLockPIN_acc_type = Command_Security_oldLockPIN_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security> for Command_Security_oldLockPIN_acc_type {
    fn name(&self) -> &'static str {
        "oldLockPIN"
    }

    fn has_field(&self, m: &Command_Security) -> bool {
        m.has_oldLockPIN()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Security) -> &'a [u8] {
        m.get_oldLockPIN()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_newLockPIN_acc_type;
static Command_Security_newLockPIN_acc: Command_Security_newLockPIN_acc_type = Command_Security_newLockPIN_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security> for Command_Security_newLockPIN_acc_type {
    fn name(&self) -> &'static str {
        "newLockPIN"
    }

    fn has_field(&self, m: &Command_Security) -> bool {
        m.has_newLockPIN()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Security) -> &'a [u8] {
        m.get_newLockPIN()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_oldErasePIN_acc_type;
static Command_Security_oldErasePIN_acc: Command_Security_oldErasePIN_acc_type = Command_Security_oldErasePIN_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security> for Command_Security_oldErasePIN_acc_type {
    fn name(&self) -> &'static str {
        "oldErasePIN"
    }

    fn has_field(&self, m: &Command_Security) -> bool {
        m.has_oldErasePIN()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Security) -> &'a [u8] {
        m.get_oldErasePIN()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_newErasePIN_acc_type;
static Command_Security_newErasePIN_acc: Command_Security_newErasePIN_acc_type = Command_Security_newErasePIN_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security> for Command_Security_newErasePIN_acc_type {
    fn name(&self) -> &'static str {
        "newErasePIN"
    }

    fn has_field(&self, m: &Command_Security) -> bool {
        m.has_newErasePIN()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Security) -> &'a [u8] {
        m.get_newErasePIN()
    }
}

#[deriving(Clone,Default)]
pub struct Command_Security_ACL {
    identity: ::std::option::Option<i64>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    hmacAlgorithm: ::std::option::Option<Command_Security_ACL_HMACAlgorithm>,
    scope: ::protobuf::RepeatedField<Command_Security_ACL_Scope>,
    maxPriority: ::std::option::Option<Command_Priority>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_Security_ACL {
    pub fn new() -> Command_Security_ACL {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_Security_ACL {
        static mut instance: ::protobuf::lazy::Lazy<Command_Security_ACL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_Security_ACL,
        };
        unsafe {
            instance.get(|| {
                Command_Security_ACL {
                    identity: ::std::option::None,
                    key: ::protobuf::SingularField::none(),
                    hmacAlgorithm: ::std::option::None,
                    scope: ::protobuf::RepeatedField::new(),
                    maxPriority: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 identity = 1;

    pub fn clear_identity(&mut self) {
        self.identity = ::std::option::None;
    }

    pub fn has_identity(&self) -> bool {
        self.identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: i64) {
        self.identity = ::std::option::Some(v);
    }

    pub fn get_identity(&self) -> i64 {
        self.identity.unwrap_or(0)
    }

    // optional bytes key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_key(&'a self) -> &'a [u8] {
        match self.key.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // optional .com.seagate.kinetic.proto.Command.Security.ACL.HMACAlgorithm hmacAlgorithm = 3;

    pub fn clear_hmacAlgorithm(&mut self) {
        self.hmacAlgorithm = ::std::option::None;
    }

    pub fn has_hmacAlgorithm(&self) -> bool {
        self.hmacAlgorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hmacAlgorithm(&mut self, v: Command_Security_ACL_HMACAlgorithm) {
        self.hmacAlgorithm = ::std::option::Some(v);
    }

    pub fn get_hmacAlgorithm(&self) -> Command_Security_ACL_HMACAlgorithm {
        self.hmacAlgorithm.unwrap_or(Command_Security_ACL_HMACAlgorithm::INVALID_HMAC_ALGORITHM)
    }

    // repeated .com.seagate.kinetic.proto.Command.Security.ACL.Scope scope = 4;

    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::protobuf::RepeatedField<Command_Security_ACL_Scope>) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scope(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Command_Security_ACL_Scope> {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::protobuf::RepeatedField<Command_Security_ACL_Scope> {
        ::std::mem::replace(&mut self.scope, ::protobuf::RepeatedField::new())
    }

    pub fn get_scope(&'a self) -> &'a [Command_Security_ACL_Scope] {
        self.scope.as_slice()
    }

    // optional .com.seagate.kinetic.proto.Command.Priority maxPriority = 5;

    pub fn clear_maxPriority(&mut self) {
        self.maxPriority = ::std::option::None;
    }

    pub fn has_maxPriority(&self) -> bool {
        self.maxPriority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxPriority(&mut self, v: Command_Priority) {
        self.maxPriority = ::std::option::Some(v);
    }

    pub fn get_maxPriority(&self) -> Command_Priority {
        self.maxPriority.unwrap_or(Command_Priority::NORMAL)
    }
}

impl ::protobuf::Message for Command_Security_ACL {
    fn new() -> Command_Security_ACL {
        Command_Security_ACL::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.identity = ::std::option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.key.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.hmacAlgorithm = ::std::option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.scope.push_default();
                    try!(is.merge_message(tmp))
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.maxPriority = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.identity.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.key.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        for value in self.hmacAlgorithm.iter() {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        for value in self.scope.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.maxPriority.iter() {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.identity {
            Some(v) => {
                try!(os.write_int64(1, v));
            },
            None => {},
        };
        match self.key.as_ref() {
            Some(v) => {
                try!(os.write_bytes(2, v.as_slice()));
            },
            None => {},
        };
        match self.hmacAlgorithm {
            Some(v) => {
                try!(os.write_enum(3, v as i32));
            },
            None => {},
        };
        for v in self.scope.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        match self.maxPriority {
            Some(v) => {
                try!(os.write_enum(5, v as i32));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_Security_ACL>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_identity_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_key_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_hmacAlgorithm_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_scope_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_maxPriority_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_Security_ACL>(
                    "Command_Security_ACL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_Security_ACL>()
    }
}

impl ::protobuf::Clear for Command_Security_ACL {
    fn clear(&mut self) {
        self.clear_identity();
        self.clear_key();
        self.clear_hmacAlgorithm();
        self.clear_scope();
        self.clear_maxPriority();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_Security_ACL {
    fn eq(&self, other: &Command_Security_ACL) -> bool {
        self.identity == other.identity &&
        self.key == other.key &&
        self.hmacAlgorithm == other.hmacAlgorithm &&
        self.scope == other.scope &&
        self.maxPriority == other.maxPriority &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_Security_ACL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_Security_ACL_identity_acc_type;
static Command_Security_ACL_identity_acc: Command_Security_ACL_identity_acc_type = Command_Security_ACL_identity_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL> for Command_Security_ACL_identity_acc_type {
    fn name(&self) -> &'static str {
        "identity"
    }

    fn has_field(&self, m: &Command_Security_ACL) -> bool {
        m.has_identity()
    }

    fn get_i64(&self, m: &Command_Security_ACL) -> i64 {
        m.get_identity()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_ACL_key_acc_type;
static Command_Security_ACL_key_acc: Command_Security_ACL_key_acc_type = Command_Security_ACL_key_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL> for Command_Security_ACL_key_acc_type {
    fn name(&self) -> &'static str {
        "key"
    }

    fn has_field(&self, m: &Command_Security_ACL) -> bool {
        m.has_key()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Security_ACL) -> &'a [u8] {
        m.get_key()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_ACL_hmacAlgorithm_acc_type;
static Command_Security_ACL_hmacAlgorithm_acc: Command_Security_ACL_hmacAlgorithm_acc_type = Command_Security_ACL_hmacAlgorithm_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL> for Command_Security_ACL_hmacAlgorithm_acc_type {
    fn name(&self) -> &'static str {
        "hmacAlgorithm"
    }

    fn has_field(&self, m: &Command_Security_ACL) -> bool {
        m.has_hmacAlgorithm()
    }

    fn get_enum<'a>(&self, m: &Command_Security_ACL) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_hmacAlgorithm().descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_ACL_scope_acc_type;
static Command_Security_ACL_scope_acc: Command_Security_ACL_scope_acc_type = Command_Security_ACL_scope_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL> for Command_Security_ACL_scope_acc_type {
    fn name(&self) -> &'static str {
        "scope"
    }

    fn len_field(&self, m: &Command_Security_ACL) -> uint {
        m.get_scope().len()
    }

    fn get_rep_message_item<'a>(&self, m: &'a Command_Security_ACL, index: uint) -> &'a ::protobuf::Message {
        &m.get_scope()[index] as &'a ::protobuf::Message
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_ACL_maxPriority_acc_type;
static Command_Security_ACL_maxPriority_acc: Command_Security_ACL_maxPriority_acc_type = Command_Security_ACL_maxPriority_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL> for Command_Security_ACL_maxPriority_acc_type {
    fn name(&self) -> &'static str {
        "maxPriority"
    }

    fn has_field(&self, m: &Command_Security_ACL) -> bool {
        m.has_maxPriority()
    }

    fn get_enum<'a>(&self, m: &Command_Security_ACL) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_maxPriority().descriptor()
    }
}

#[deriving(Clone,Default)]
pub struct Command_Security_ACL_Scope {
    offset: ::std::option::Option<i64>,
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    permission: ::std::vec::Vec<Command_Security_ACL_Permission>,
    TlsRequired: ::std::option::Option<bool>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_Security_ACL_Scope {
    pub fn new() -> Command_Security_ACL_Scope {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_Security_ACL_Scope {
        static mut instance: ::protobuf::lazy::Lazy<Command_Security_ACL_Scope> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_Security_ACL_Scope,
        };
        unsafe {
            instance.get(|| {
                Command_Security_ACL_Scope {
                    offset: ::std::option::None,
                    value: ::protobuf::SingularField::none(),
                    permission: ::std::vec::Vec::new(),
                    TlsRequired: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 offset = 1;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = ::std::option::Some(v);
    }

    pub fn get_offset(&self) -> i64 {
        self.offset.unwrap_or(0)
    }

    // optional bytes value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_value(&'a self) -> &'a [u8] {
        match self.value.as_ref() {
            Some(v) => v.as_slice(),
            None => [].as_slice(),
        }
    }

    // repeated .com.seagate.kinetic.proto.Command.Security.ACL.Permission permission = 3;

    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: ::std::vec::Vec<Command_Security_ACL_Permission>) {
        self.permission = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permission(&'a mut self) -> &'a mut ::std::vec::Vec<Command_Security_ACL_Permission> {
        &mut self.permission
    }

    // Take field
    pub fn take_permission(&mut self) -> ::std::vec::Vec<Command_Security_ACL_Permission> {
        ::std::mem::replace(&mut self.permission, ::std::vec::Vec::new())
    }

    pub fn get_permission(&'a self) -> &'a [Command_Security_ACL_Permission] {
        self.permission.as_slice()
    }

    // optional bool TlsRequired = 4;

    pub fn clear_TlsRequired(&mut self) {
        self.TlsRequired = ::std::option::None;
    }

    pub fn has_TlsRequired(&self) -> bool {
        self.TlsRequired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_TlsRequired(&mut self, v: bool) {
        self.TlsRequired = ::std::option::Some(v);
    }

    pub fn get_TlsRequired(&self) -> bool {
        self.TlsRequired.unwrap_or(false)
    }
}

impl ::protobuf::Message for Command_Security_ACL_Scope {
    fn new() -> Command_Security_ACL_Scope {
        Command_Security_ACL_Scope::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_int64());
                    self.offset = ::std::option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = self.value.set_default();
                    try!(is.read_bytes_into(tmp))
                },
                3 => {
                    match wire_type {
                        ::protobuf::wire_format::WireTypeLengthDelimited => {
                            try!(is.read_repeated_packed_enum_into(&mut self.permission));
                        },
                        ::protobuf::wire_format::WireTypeVarint => {
                            self.permission.push(try!(is.read_enum()));
                        },
                        _ => {
                            return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                        },
                    };
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_bool());
                    self.TlsRequired = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.offset.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::bytes_size(2, value.as_slice());
        };
        for value in self.permission.iter() {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        if self.TlsRequired.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.offset {
            Some(v) => {
                try!(os.write_int64(1, v));
            },
            None => {},
        };
        match self.value.as_ref() {
            Some(v) => {
                try!(os.write_bytes(2, v.as_slice()));
            },
            None => {},
        };
        for v in self.permission.iter() {
            try!(os.write_enum(3, *v as i32));
        };
        match self.TlsRequired {
            Some(v) => {
                try!(os.write_bool(4, v));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_Security_ACL_Scope>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_Scope_offset_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_Scope_value_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_Scope_permission_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope>) });
                fields.push(unsafe { ::std::mem::transmute(&Command_Security_ACL_Scope_TlsRequired_acc as &'static ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_Security_ACL_Scope>(
                    "Command_Security_ACL_Scope",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_Security_ACL_Scope>()
    }
}

impl ::protobuf::Clear for Command_Security_ACL_Scope {
    fn clear(&mut self) {
        self.clear_offset();
        self.clear_value();
        self.clear_permission();
        self.clear_TlsRequired();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_Security_ACL_Scope {
    fn eq(&self, other: &Command_Security_ACL_Scope) -> bool {
        self.offset == other.offset &&
        self.value == other.value &&
        self.permission == other.permission &&
        self.TlsRequired == other.TlsRequired &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_Security_ACL_Scope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_Security_ACL_Scope_offset_acc_type;
static Command_Security_ACL_Scope_offset_acc: Command_Security_ACL_Scope_offset_acc_type = Command_Security_ACL_Scope_offset_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope> for Command_Security_ACL_Scope_offset_acc_type {
    fn name(&self) -> &'static str {
        "offset"
    }

    fn has_field(&self, m: &Command_Security_ACL_Scope) -> bool {
        m.has_offset()
    }

    fn get_i64(&self, m: &Command_Security_ACL_Scope) -> i64 {
        m.get_offset()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_ACL_Scope_value_acc_type;
static Command_Security_ACL_Scope_value_acc: Command_Security_ACL_Scope_value_acc_type = Command_Security_ACL_Scope_value_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope> for Command_Security_ACL_Scope_value_acc_type {
    fn name(&self) -> &'static str {
        "value"
    }

    fn has_field(&self, m: &Command_Security_ACL_Scope) -> bool {
        m.has_value()
    }

    fn get_bytes<'a>(&self, m: &'a Command_Security_ACL_Scope) -> &'a [u8] {
        m.get_value()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_ACL_Scope_permission_acc_type;
static Command_Security_ACL_Scope_permission_acc: Command_Security_ACL_Scope_permission_acc_type = Command_Security_ACL_Scope_permission_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope> for Command_Security_ACL_Scope_permission_acc_type {
    fn name(&self) -> &'static str {
        "permission"
    }

    fn len_field(&self, m: &Command_Security_ACL_Scope) -> uint {
        m.get_permission().len()
    }

    fn get_rep_enum_item<'a>(&self, m: &Command_Security_ACL_Scope, index: uint) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_permission()[index].descriptor()
    }
}

#[allow(non_camel_case_types)]
struct Command_Security_ACL_Scope_TlsRequired_acc_type;
static Command_Security_ACL_Scope_TlsRequired_acc: Command_Security_ACL_Scope_TlsRequired_acc_type = Command_Security_ACL_Scope_TlsRequired_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_Security_ACL_Scope> for Command_Security_ACL_Scope_TlsRequired_acc_type {
    fn name(&self) -> &'static str {
        "TlsRequired"
    }

    fn has_field(&self, m: &Command_Security_ACL_Scope) -> bool {
        m.has_TlsRequired()
    }

    fn get_bool(&self, m: &Command_Security_ACL_Scope) -> bool {
        m.get_TlsRequired()
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_Security_ACL_HMACAlgorithm {
    INVALID_HMAC_ALGORITHM = -1,
    HmacSHA1 = 1,
}


impl ::protobuf::ProtobufEnum for Command_Security_ACL_HMACAlgorithm {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_Security_ACL_HMACAlgorithm> {
        match value {
            -1 => ::std::option::Some(Command_Security_ACL_HMACAlgorithm::INVALID_HMAC_ALGORITHM),
            1 => ::std::option::Some(Command_Security_ACL_HMACAlgorithm::HmacSHA1),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_Security_ACL_HMACAlgorithm>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_Security_ACL_HMACAlgorithm", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_Security_ACL_Permission {
    INVALID_PERMISSION = -1,
    READ = 0,
    WRITE = 1,
    DELETE = 2,
    RANGE = 3,
    SETUP = 4,
    P2POP = 5,
    GETLOG = 7,
    SECURITY = 8,
}


impl ::protobuf::ProtobufEnum for Command_Security_ACL_Permission {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_Security_ACL_Permission> {
        match value {
            -1 => ::std::option::Some(Command_Security_ACL_Permission::INVALID_PERMISSION),
            0 => ::std::option::Some(Command_Security_ACL_Permission::READ),
            1 => ::std::option::Some(Command_Security_ACL_Permission::WRITE),
            2 => ::std::option::Some(Command_Security_ACL_Permission::DELETE),
            3 => ::std::option::Some(Command_Security_ACL_Permission::RANGE),
            4 => ::std::option::Some(Command_Security_ACL_Permission::SETUP),
            5 => ::std::option::Some(Command_Security_ACL_Permission::P2POP),
            7 => ::std::option::Some(Command_Security_ACL_Permission::GETLOG),
            8 => ::std::option::Some(Command_Security_ACL_Permission::SECURITY),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_Security_ACL_Permission>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_Security_ACL_Permission", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,Default)]
pub struct Command_PinOperation {
    pinOpType: ::std::option::Option<Command_PinOperation_PinOpType>,
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

impl<'a> Command_PinOperation {
    pub fn new() -> Command_PinOperation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Command_PinOperation {
        static mut instance: ::protobuf::lazy::Lazy<Command_PinOperation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Command_PinOperation,
        };
        unsafe {
            instance.get(|| {
                Command_PinOperation {
                    pinOpType: ::std::option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .com.seagate.kinetic.proto.Command.PinOperation.PinOpType pinOpType = 1;

    pub fn clear_pinOpType(&mut self) {
        self.pinOpType = ::std::option::None;
    }

    pub fn has_pinOpType(&self) -> bool {
        self.pinOpType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinOpType(&mut self, v: Command_PinOperation_PinOpType) {
        self.pinOpType = ::std::option::Some(v);
    }

    pub fn get_pinOpType(&self) -> Command_PinOperation_PinOpType {
        self.pinOpType.unwrap_or(Command_PinOperation_PinOpType::INVALID_PINOP)
    }
}

impl ::protobuf::Message for Command_PinOperation {
    fn new() -> Command_PinOperation {
        Command_PinOperation::new()
    }

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Err(::protobuf::ProtobufError::WireError("unexpected wire type".to_string()));
                    };
                    let tmp = try!(is.read_enum());
                    self.pinOpType = ::std::option::Some(tmp);
                },
                _ => {
                    let unknown = try!(is.read_unknown(wire_type));
                    self.mut_unknown_fields().add_value(field_number, unknown);
                },
            };
        }
        ::std::result::Ok(())
    }

    // Compute sizes of nested messages
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.pinOpType.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        match self.pinOpType {
            Some(v) => {
                try!(os.write_enum(1, v as i32));
            },
            None => {},
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    #[allow(unused_unsafe,unused_mut)]
    fn descriptor_static(_: ::std::option::Option<Command_PinOperation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields: ::std::vec::Vec<&'static ::protobuf::reflect::FieldAccessor<Command_PinOperation>> = ::std::vec::Vec::new();
                fields.push(unsafe { ::std::mem::transmute(&Command_PinOperation_pinOpType_acc as &'static ::protobuf::reflect::FieldAccessor<Command_PinOperation>) });
                ::protobuf::reflect::MessageDescriptor::new::<Command_PinOperation>(
                    "Command_PinOperation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn type_id(&self) -> ::std::intrinsics::TypeId {
        ::std::intrinsics::TypeId::of::<Command_PinOperation>()
    }
}

impl ::protobuf::Clear for Command_PinOperation {
    fn clear(&mut self) {
        self.clear_pinOpType();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Command_PinOperation {
    fn eq(&self, other: &Command_PinOperation) -> bool {
        self.pinOpType == other.pinOpType &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Show for Command_PinOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        self.fmt_impl(f)
    }
}


#[allow(non_camel_case_types)]
struct Command_PinOperation_pinOpType_acc_type;
static Command_PinOperation_pinOpType_acc: Command_PinOperation_pinOpType_acc_type = Command_PinOperation_pinOpType_acc_type;

impl ::protobuf::reflect::FieldAccessor<Command_PinOperation> for Command_PinOperation_pinOpType_acc_type {
    fn name(&self) -> &'static str {
        "pinOpType"
    }

    fn has_field(&self, m: &Command_PinOperation) -> bool {
        m.has_pinOpType()
    }

    fn get_enum<'a>(&self, m: &Command_PinOperation) -> &'static ::protobuf::reflect::EnumValueDescriptor {
        m.get_pinOpType().descriptor()
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_PinOperation_PinOpType {
    INVALID_PINOP = -1,
    UNLOCK_PINOP = 1,
    LOCK_PINOP = 2,
    ERASE_PINOP = 3,
    SECURE_ERASE_PINOP = 4,
}


impl ::protobuf::ProtobufEnum for Command_PinOperation_PinOpType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_PinOperation_PinOpType> {
        match value {
            -1 => ::std::option::Some(Command_PinOperation_PinOpType::INVALID_PINOP),
            1 => ::std::option::Some(Command_PinOperation_PinOpType::UNLOCK_PINOP),
            2 => ::std::option::Some(Command_PinOperation_PinOpType::LOCK_PINOP),
            3 => ::std::option::Some(Command_PinOperation_PinOpType::ERASE_PINOP),
            4 => ::std::option::Some(Command_PinOperation_PinOpType::SECURE_ERASE_PINOP),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_PinOperation_PinOpType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_PinOperation_PinOpType", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_Synchronization {
    INVALID_SYNCHRONIZATION = -1,
    WRITETHROUGH = 1,
    WRITEBACK = 2,
    FLUSH = 3,
}


impl ::protobuf::ProtobufEnum for Command_Synchronization {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_Synchronization> {
        match value {
            -1 => ::std::option::Some(Command_Synchronization::INVALID_SYNCHRONIZATION),
            1 => ::std::option::Some(Command_Synchronization::WRITETHROUGH),
            2 => ::std::option::Some(Command_Synchronization::WRITEBACK),
            3 => ::std::option::Some(Command_Synchronization::FLUSH),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_Synchronization>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_Synchronization", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_Priority {
    NORMAL = 5,
    LOWEST = 1,
    LOWER = 3,
    HIGHER = 7,
    HIGHEST = 9,
}


impl ::protobuf::ProtobufEnum for Command_Priority {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_Priority> {
        match value {
            5 => ::std::option::Some(Command_Priority::NORMAL),
            1 => ::std::option::Some(Command_Priority::LOWEST),
            3 => ::std::option::Some(Command_Priority::LOWER),
            7 => ::std::option::Some(Command_Priority::HIGHER),
            9 => ::std::option::Some(Command_Priority::HIGHEST),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_Priority>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_Priority", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_Algorithm {
    INVALID_ALGORITHM = -1,
    SHA1 = 1,
    SHA2 = 2,
    SHA3 = 3,
    CRC32 = 4,
    CRC64 = 5,
}


impl ::protobuf::ProtobufEnum for Command_Algorithm {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_Algorithm> {
        match value {
            -1 => ::std::option::Some(Command_Algorithm::INVALID_ALGORITHM),
            1 => ::std::option::Some(Command_Algorithm::SHA1),
            2 => ::std::option::Some(Command_Algorithm::SHA2),
            3 => ::std::option::Some(Command_Algorithm::SHA3),
            4 => ::std::option::Some(Command_Algorithm::CRC32),
            5 => ::std::option::Some(Command_Algorithm::CRC64),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_Algorithm>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_Algorithm", file_descriptor_proto())
            })
        }
    }
}

#[deriving(Clone,PartialEq,Eq,Show)]
pub enum Command_MessageType {
    INVALID_MESSAGE_TYPE = -1,
    GET = 2,
    GET_RESPONSE = 1,
    PUT = 4,
    PUT_RESPONSE = 3,
    DELETE = 6,
    DELETE_RESPONSE = 5,
    GETNEXT = 8,
    GETNEXT_RESPONSE = 7,
    GETPREVIOUS = 10,
    GETPREVIOUS_RESPONSE = 9,
    GETKEYRANGE = 12,
    GETKEYRANGE_RESPONSE = 11,
    GETVERSION = 16,
    GETVERSION_RESPONSE = 15,
    SETUP = 22,
    SETUP_RESPONSE = 21,
    GETLOG = 24,
    GETLOG_RESPONSE = 23,
    SECURITY = 26,
    SECURITY_RESPONSE = 25,
    PEER2PEERPUSH = 28,
    PEER2PEERPUSH_RESPONSE = 27,
    NOOP = 30,
    NOOP_RESPONSE = 29,
    FLUSHALLDATA = 32,
    FLUSHALLDATA_RESPONSE = 31,
    PINOP = 36,
    PINOP_RESPONSE = 35,
    MEDIASCAN = 38,
    MEDIASCAN_RESPONSE = 37,
    MEDIAOPTIMIZE = 40,
    MEDIAOPTIMIZE_RESPONSE = 39,
}


impl ::protobuf::ProtobufEnum for Command_MessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Command_MessageType> {
        match value {
            -1 => ::std::option::Some(Command_MessageType::INVALID_MESSAGE_TYPE),
            2 => ::std::option::Some(Command_MessageType::GET),
            1 => ::std::option::Some(Command_MessageType::GET_RESPONSE),
            4 => ::std::option::Some(Command_MessageType::PUT),
            3 => ::std::option::Some(Command_MessageType::PUT_RESPONSE),
            6 => ::std::option::Some(Command_MessageType::DELETE),
            5 => ::std::option::Some(Command_MessageType::DELETE_RESPONSE),
            8 => ::std::option::Some(Command_MessageType::GETNEXT),
            7 => ::std::option::Some(Command_MessageType::GETNEXT_RESPONSE),
            10 => ::std::option::Some(Command_MessageType::GETPREVIOUS),
            9 => ::std::option::Some(Command_MessageType::GETPREVIOUS_RESPONSE),
            12 => ::std::option::Some(Command_MessageType::GETKEYRANGE),
            11 => ::std::option::Some(Command_MessageType::GETKEYRANGE_RESPONSE),
            16 => ::std::option::Some(Command_MessageType::GETVERSION),
            15 => ::std::option::Some(Command_MessageType::GETVERSION_RESPONSE),
            22 => ::std::option::Some(Command_MessageType::SETUP),
            21 => ::std::option::Some(Command_MessageType::SETUP_RESPONSE),
            24 => ::std::option::Some(Command_MessageType::GETLOG),
            23 => ::std::option::Some(Command_MessageType::GETLOG_RESPONSE),
            26 => ::std::option::Some(Command_MessageType::SECURITY),
            25 => ::std::option::Some(Command_MessageType::SECURITY_RESPONSE),
            28 => ::std::option::Some(Command_MessageType::PEER2PEERPUSH),
            27 => ::std::option::Some(Command_MessageType::PEER2PEERPUSH_RESPONSE),
            30 => ::std::option::Some(Command_MessageType::NOOP),
            29 => ::std::option::Some(Command_MessageType::NOOP_RESPONSE),
            32 => ::std::option::Some(Command_MessageType::FLUSHALLDATA),
            31 => ::std::option::Some(Command_MessageType::FLUSHALLDATA_RESPONSE),
            36 => ::std::option::Some(Command_MessageType::PINOP),
            35 => ::std::option::Some(Command_MessageType::PINOP_RESPONSE),
            38 => ::std::option::Some(Command_MessageType::MEDIASCAN),
            37 => ::std::option::Some(Command_MessageType::MEDIASCAN_RESPONSE),
            40 => ::std::option::Some(Command_MessageType::MEDIAOPTIMIZE),
            39 => ::std::option::Some(Command_MessageType::MEDIAOPTIMIZE_RESPONSE),
            _ => ::std::option::None
        }
    }

    fn enum_descriptor_static(_: Option<Command_MessageType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Command_MessageType", file_descriptor_proto())
            })
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x0d, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
    0x19, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e,
    0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x27, 0x0a, 0x05, 0x4c, 0x6f,
    0x63, 0x61, 0x6c, 0x12, 0x1e, 0x0a, 0x0f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56,
    0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x3a, 0x05, 0x33, 0x2e,
    0x30, 0x2e, 0x35, 0x22, 0xfc, 0x02, 0x0a, 0x07, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12,
    0x3d, 0x0a, 0x08, 0x61, 0x75, 0x74, 0x68, 0x54, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x0e, 0x32, 0x2b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e,
    0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x54, 0x79, 0x70, 0x65, 0x12, 0x3d,
    0x0a, 0x08, 0x68, 0x6d, 0x61, 0x63, 0x41, 0x75, 0x74, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x2b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b,
    0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x2e, 0x48, 0x4d, 0x41, 0x43, 0x61, 0x75, 0x74, 0x68, 0x12, 0x3b, 0x0a,
    0x07, 0x70, 0x69, 0x6e, 0x41, 0x75, 0x74, 0x68, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a,
    0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e,
    0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x2e, 0x50, 0x49, 0x4e, 0x61, 0x75, 0x74, 0x68, 0x12, 0x14, 0x0a, 0x0c, 0x63, 0x6f,
    0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x42, 0x79, 0x74, 0x65, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c,
    0x1a, 0x2a, 0x0a, 0x08, 0x48, 0x4d, 0x41, 0x43, 0x61, 0x75, 0x74, 0x68, 0x12, 0x10, 0x0a, 0x08,
    0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0c,
    0x0a, 0x04, 0x68, 0x6d, 0x61, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x1a, 0x16, 0x0a, 0x07,
    0x50, 0x49, 0x4e, 0x61, 0x75, 0x74, 0x68, 0x12, 0x0b, 0x0a, 0x03, 0x70, 0x69, 0x6e, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0c, 0x22, 0x5c, 0x0a, 0x08, 0x41, 0x75, 0x74, 0x68, 0x54, 0x79, 0x70, 0x65,
    0x12, 0x1e, 0x0a, 0x11, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x41, 0x55, 0x54, 0x48,
    0x5f, 0x54, 0x59, 0x50, 0x45, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
    0x12, 0x0c, 0x0a, 0x08, 0x48, 0x4d, 0x41, 0x43, 0x41, 0x55, 0x54, 0x48, 0x10, 0x01, 0x12, 0x0b,
    0x0a, 0x07, 0x50, 0x49, 0x4e, 0x41, 0x55, 0x54, 0x48, 0x10, 0x02, 0x12, 0x15, 0x0a, 0x11, 0x55,
    0x4e, 0x53, 0x4f, 0x4c, 0x49, 0x43, 0x49, 0x54, 0x45, 0x44, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53,
    0x10, 0x03, 0x22, 0x90, 0x30, 0x0a, 0x07, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x39,
    0x0a, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29,
    0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e,
    0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61,
    0x6e, 0x64, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x35, 0x0a, 0x04, 0x62, 0x6f, 0x64,
    0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65,
    0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x42, 0x6f, 0x64, 0x79,
    0x12, 0x39, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x29, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b,
    0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x1a, 0x99, 0x02, 0x0a, 0x06,
    0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x16, 0x0a, 0x0e, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65,
    0x72, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14,
    0x0a, 0x0c, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x03, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x61, 0x63, 0x6b, 0x53, 0x65, 0x71,
    0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x12, 0x43, 0x0a, 0x0b, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e,
    0x32, 0x2e, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b,
    0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65,
    0x12, 0x0f, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x03, 0x12, 0x11, 0x0a, 0x09, 0x65, 0x61, 0x72, 0x6c, 0x79, 0x45, 0x78, 0x69, 0x74, 0x18, 0x0a,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x3d, 0x0a, 0x08, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79,
    0x18, 0x0c, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61,
    0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f,
    0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x50, 0x72, 0x69, 0x6f, 0x72,
    0x69, 0x74, 0x79, 0x12, 0x12, 0x0a, 0x0a, 0x54, 0x69, 0x6d, 0x65, 0x51, 0x75, 0x61, 0x6e, 0x74,
    0x61, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x03, 0x1a, 0xb8, 0x03, 0x0a, 0x04, 0x42, 0x6f, 0x64, 0x79,
    0x12, 0x3d, 0x0a, 0x08, 0x6b, 0x65, 0x79, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65,
    0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43,
    0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x4b, 0x65, 0x79, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12,
    0x37, 0x0a, 0x05, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28,
    0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e,
    0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61,
    0x6e, 0x64, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x37, 0x0a, 0x05, 0x73, 0x65, 0x74, 0x75,
    0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65,
    0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x53, 0x65, 0x74, 0x75,
    0x70, 0x12, 0x45, 0x0a, 0x0c, 0x70, 0x32, 0x70, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65,
    0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x50, 0x32, 0x50, 0x4f,
    0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x39, 0x0a, 0x06, 0x67, 0x65, 0x74, 0x4c,
    0x6f, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73,
    0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70,
    0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65, 0x74,
    0x4c, 0x6f, 0x67, 0x12, 0x3d, 0x0a, 0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67,
    0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69,
    0x74, 0x79, 0x12, 0x3e, 0x0a, 0x05, 0x70, 0x69, 0x6e, 0x4f, 0x70, 0x18, 0x08, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x2f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e,
    0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f,
    0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x50, 0x69, 0x6e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x1a, 0xde, 0x04, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x42, 0x0a,
    0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x34, 0x2e, 0x63, 0x6f,
    0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69,
    0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e,
    0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64,
    0x65, 0x12, 0x15, 0x0a, 0x0d, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x4d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x17, 0x0a, 0x0f, 0x64, 0x65, 0x74, 0x61,
    0x69, 0x6c, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0c, 0x22, 0xdf, 0x03, 0x0a, 0x0a, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x43, 0x6f, 0x64, 0x65,
    0x12, 0x20, 0x0a, 0x13, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x53, 0x54, 0x41, 0x54,
    0x55, 0x53, 0x5f, 0x43, 0x4f, 0x44, 0x45, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x01, 0x12, 0x11, 0x0a, 0x0d, 0x4e, 0x4f, 0x54, 0x5f, 0x41, 0x54, 0x54, 0x45, 0x4d, 0x50,
    0x54, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53,
    0x10, 0x01, 0x12, 0x10, 0x0a, 0x0c, 0x48, 0x4d, 0x41, 0x43, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55,
    0x52, 0x45, 0x10, 0x02, 0x12, 0x12, 0x0a, 0x0e, 0x4e, 0x4f, 0x54, 0x5f, 0x41, 0x55, 0x54, 0x48,
    0x4f, 0x52, 0x49, 0x5a, 0x45, 0x44, 0x10, 0x03, 0x12, 0x13, 0x0a, 0x0f, 0x56, 0x45, 0x52, 0x53,
    0x49, 0x4f, 0x4e, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x04, 0x12, 0x12, 0x0a,
    0x0e, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10,
    0x05, 0x12, 0x13, 0x0a, 0x0f, 0x48, 0x45, 0x41, 0x44, 0x45, 0x52, 0x5f, 0x52, 0x45, 0x51, 0x55,
    0x49, 0x52, 0x45, 0x44, 0x10, 0x06, 0x12, 0x0d, 0x0a, 0x09, 0x4e, 0x4f, 0x54, 0x5f, 0x46, 0x4f,
    0x55, 0x4e, 0x44, 0x10, 0x07, 0x12, 0x14, 0x0a, 0x10, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4f, 0x4e,
    0x5f, 0x4d, 0x49, 0x53, 0x4d, 0x41, 0x54, 0x43, 0x48, 0x10, 0x08, 0x12, 0x10, 0x0a, 0x0c, 0x53,
    0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x42, 0x55, 0x53, 0x59, 0x10, 0x09, 0x12, 0x0b, 0x0a,
    0x07, 0x45, 0x58, 0x50, 0x49, 0x52, 0x45, 0x44, 0x10, 0x0a, 0x12, 0x0e, 0x0a, 0x0a, 0x44, 0x41,
    0x54, 0x41, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x0b, 0x12, 0x13, 0x0a, 0x0f, 0x50, 0x45,
    0x52, 0x4d, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x0c, 0x12,
    0x1b, 0x0a, 0x17, 0x52, 0x45, 0x4d, 0x4f, 0x54, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43,
    0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x10, 0x0d, 0x12, 0x0c, 0x0a, 0x08,
    0x4e, 0x4f, 0x5f, 0x53, 0x50, 0x41, 0x43, 0x45, 0x10, 0x0e, 0x12, 0x1a, 0x0a, 0x16, 0x4e, 0x4f,
    0x5f, 0x53, 0x55, 0x43, 0x48, 0x5f, 0x48, 0x4d, 0x41, 0x43, 0x5f, 0x41, 0x4c, 0x47, 0x4f, 0x52,
    0x49, 0x54, 0x48, 0x4d, 0x10, 0x0f, 0x12, 0x13, 0x0a, 0x0f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49,
    0x44, 0x5f, 0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x10, 0x10, 0x12, 0x1b, 0x0a, 0x17, 0x4e,
    0x45, 0x53, 0x54, 0x45, 0x44, 0x5f, 0x4f, 0x50, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f,
    0x45, 0x52, 0x52, 0x4f, 0x52, 0x53, 0x10, 0x11, 0x12, 0x11, 0x0a, 0x0d, 0x44, 0x45, 0x56, 0x49,
    0x43, 0x45, 0x5f, 0x4c, 0x4f, 0x43, 0x4b, 0x45, 0x44, 0x10, 0x12, 0x12, 0x1b, 0x0a, 0x17, 0x44,
    0x45, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x41, 0x4c, 0x52, 0x45, 0x41, 0x44, 0x59, 0x5f, 0x55, 0x4e,
    0x4c, 0x4f, 0x43, 0x4b, 0x45, 0x44, 0x10, 0x13, 0x12, 0x19, 0x0a, 0x15, 0x43, 0x4f, 0x4e, 0x4e,
    0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x54, 0x45,
    0x44, 0x10, 0x14, 0x1a, 0xfe, 0x01, 0x0a, 0x08, 0x4b, 0x65, 0x79, 0x56, 0x61, 0x6c, 0x75, 0x65,
    0x12, 0x12, 0x0a, 0x0a, 0x6e, 0x65, 0x77, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x0c, 0x12, 0x0d, 0x0a, 0x05, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x18, 0x08, 0x20,
    0x01, 0x28, 0x08, 0x12, 0x0b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c,
    0x12, 0x11, 0x0a, 0x09, 0x64, 0x62, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0c, 0x12, 0x0b, 0x0a, 0x03, 0x74, 0x61, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c,
    0x12, 0x3f, 0x0a, 0x09, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x0e, 0x32, 0x2c, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74,
    0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
    0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68,
    0x6d, 0x12, 0x14, 0x0a, 0x0c, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x4f, 0x6e, 0x6c,
    0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x12, 0x4b, 0x0a, 0x0f, 0x73, 0x79, 0x6e, 0x63, 0x68,
    0x72, 0x6f, 0x6e, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0e,
    0x32, 0x32, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b,
    0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x53, 0x79, 0x6e, 0x63, 0x68, 0x72, 0x6f, 0x6e, 0x69, 0x7a, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x91, 0x01, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x10,
    0x0a, 0x08, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c,
    0x12, 0x0e, 0x0a, 0x06, 0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c,
    0x12, 0x19, 0x0a, 0x11, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4b, 0x65, 0x79, 0x49, 0x6e, 0x63, 0x6c,
    0x75, 0x73, 0x69, 0x76, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x17, 0x0a, 0x0f, 0x65,
    0x6e, 0x64, 0x4b, 0x65, 0x79, 0x49, 0x6e, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x13, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x52, 0x65, 0x74, 0x75, 0x72,
    0x6e, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x72, 0x65, 0x76,
    0x65, 0x72, 0x73, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0c, 0x0a, 0x04, 0x6b, 0x65,
    0x79, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0c, 0x1a, 0x3c, 0x0a, 0x05, 0x53, 0x65, 0x74, 0x75,
    0x70, 0x12, 0x19, 0x0a, 0x11, 0x6e, 0x65, 0x77, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x56,
    0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x12, 0x18, 0x0a, 0x10,
    0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x1a, 0xc0, 0x03, 0x0a, 0x0c, 0x50, 0x32, 0x50, 0x4f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x42, 0x0a, 0x04, 0x70, 0x65, 0x65, 0x72, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67,
    0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x50, 0x32, 0x50, 0x4f, 0x70, 0x65,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x50, 0x65, 0x65, 0x72, 0x12, 0x4c, 0x0a, 0x09, 0x6f,
    0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x39,
    0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e,
    0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61,
    0x6e, 0x64, 0x2e, 0x50, 0x32, 0x50, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
    0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x0a, 0x1b, 0x61, 0x6c, 0x6c,
    0x43, 0x68, 0x69, 0x6c, 0x64, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x53,
    0x75, 0x63, 0x63, 0x65, 0x65, 0x64, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x1a, 0xc3,
    0x01, 0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0b, 0x0a, 0x03,
    0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0f, 0x0a, 0x07, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0e, 0x0a, 0x06, 0x6e, 0x65,
    0x77, 0x4b, 0x65, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0d, 0x0a, 0x05, 0x66, 0x6f,
    0x72, 0x63, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x12, 0x39, 0x0a, 0x06, 0x73, 0x74, 0x61,
    0x74, 0x75, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x63, 0x6f, 0x6d, 0x2e,
    0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x53, 0x74,
    0x61, 0x74, 0x75, 0x73, 0x12, 0x3e, 0x0a, 0x05, 0x70, 0x32, 0x70, 0x6f, 0x70, 0x18, 0x08, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74,
    0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
    0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x50, 0x32, 0x50, 0x4f, 0x70, 0x65, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x33, 0x0a, 0x04, 0x50, 0x65, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x08,
    0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0c,
    0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0b, 0x0a, 0x03,
    0x74, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x1a, 0xa9, 0x0e, 0x0a, 0x06, 0x47, 0x65,
    0x74, 0x4c, 0x6f, 0x67, 0x12, 0x3d, 0x0a, 0x05, 0x74, 0x79, 0x70, 0x65, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0e, 0x32, 0x2e, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74,
    0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
    0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x67, 0x2e, 0x54,
    0x79, 0x70, 0x65, 0x12, 0x4b, 0x0a, 0x0c, 0x75, 0x74, 0x69, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x63, 0x6f, 0x6d, 0x2e,
    0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65,
    0x74, 0x4c, 0x6f, 0x67, 0x2e, 0x55, 0x74, 0x69, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x12, 0x4b, 0x0a, 0x0c, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
    0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61,
    0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f,
    0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x6f,
    0x67, 0x2e, 0x54, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x44, 0x0a,
    0x08, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x32, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69,
    0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x67, 0x2e, 0x43, 0x61, 0x70, 0x61, 0x63,
    0x69, 0x74, 0x79, 0x12, 0x4e, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x63, 0x6f, 0x6d,
    0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63,
    0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x47,
    0x65, 0x74, 0x4c, 0x6f, 0x67, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x12, 0x48, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63,
    0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65,
    0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65, 0x74, 0x4c,
    0x6f, 0x67, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x10, 0x0a,
    0x08, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x12,
    0x40, 0x0a, 0x06, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x30, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69,
    0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x67, 0x2e, 0x4c, 0x69, 0x6d, 0x69, 0x74,
    0x73, 0x12, 0x40, 0x0a, 0x06, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x30, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e,
    0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f,
    0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x67, 0x2e, 0x44, 0x65, 0x76,
    0x69, 0x63, 0x65, 0x1a, 0x2a, 0x0a, 0x0b, 0x55, 0x74, 0x69, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x1a,
    0x5e, 0x0a, 0x0b, 0x54, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x0c,
    0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07,
    0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x12, 0x0f, 0x0a,
    0x07, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x12, 0x0f,
    0x0a, 0x07, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x12,
    0x0e, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02, 0x1a,
    0x3f, 0x0a, 0x08, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x12, 0x1e, 0x0a, 0x16, 0x6e,
    0x6f, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x49, 0x6e,
    0x42, 0x79, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x12, 0x13, 0x0a, 0x0b, 0x70,
    0x6f, 0x72, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x75, 0x6c, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x02,
    0x1a, 0xb6, 0x03, 0x0a, 0x0d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x12, 0x0e, 0x0a, 0x06, 0x76, 0x65, 0x6e, 0x64, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65,
    0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x15, 0x0a, 0x0d, 0x77, 0x6f, 0x72, 0x6c, 0x64,
    0x57, 0x69, 0x64, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0f,
    0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x17, 0x0a, 0x0f, 0x63, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61,
    0x74, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x48, 0x61, 0x73, 0x68, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x12, 0x17, 0x0a, 0x0f,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,
    0x0f, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1f, 0x0a, 0x17, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
    0x6c, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x74, 0x65,
    0x18, 0x10, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1a, 0x0a, 0x12, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
    0x6f, 0x6c, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x48, 0x61, 0x73, 0x68, 0x18, 0x11, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x54, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x18,
    0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67,
    0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74,
    0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x67,
    0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x49,
    0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74,
    0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x74, 0x6c, 0x73, 0x50, 0x6f, 0x72,
    0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x05, 0x1a, 0x50, 0x0a, 0x09, 0x49, 0x6e, 0x74, 0x65, 0x72,
    0x66, 0x61, 0x63, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x0b, 0x0a, 0x03, 0x4d, 0x41, 0x43, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x12,
    0x13, 0x0a, 0x0b, 0x69, 0x70, 0x76, 0x34, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x0c, 0x12, 0x13, 0x0a, 0x0b, 0x69, 0x70, 0x76, 0x36, 0x41, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x1a, 0x6f, 0x0a, 0x0a, 0x53, 0x74, 0x61,
    0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x43, 0x0a, 0x0b, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2e, 0x2e, 0x63,
    0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74,
    0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
    0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0d, 0x0a, 0x05,
    0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0d, 0x0a, 0x05, 0x62,
    0x79, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x1a, 0x9f, 0x02, 0x0a, 0x06, 0x4c,
    0x69, 0x6d, 0x69, 0x74, 0x73, 0x12, 0x12, 0x0a, 0x0a, 0x6d, 0x61, 0x78, 0x4b, 0x65, 0x79, 0x53,
    0x69, 0x7a, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x6d, 0x61, 0x78,
    0x56, 0x61, 0x6c, 0x75, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x16, 0x0a, 0x0e, 0x6d, 0x61, 0x78, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a,
    0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x6d, 0x61, 0x78, 0x54, 0x61,
    0x67, 0x53, 0x69, 0x7a, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x6d,
    0x61, 0x78, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x22, 0x0a, 0x1a, 0x6d, 0x61, 0x78, 0x4f, 0x75, 0x74, 0x73, 0x74, 0x61,
    0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x61, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x23, 0x0a, 0x1b, 0x6d, 0x61, 0x78, 0x4f, 0x75,
    0x74, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x57, 0x72, 0x69, 0x74, 0x65, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e,
    0x6d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x18, 0x08,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x18, 0x0a, 0x10, 0x6d, 0x61, 0x78, 0x4b, 0x65, 0x79, 0x52, 0x61,
    0x6e, 0x67, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x18,
    0x0a, 0x10, 0x6d, 0x61, 0x78, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x75,
    0x6e, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x6d, 0x61, 0x78, 0x50,
    0x69, 0x6e, 0x53, 0x69, 0x7a, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x1a, 0x16, 0x0a, 0x06,
    0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0c, 0x22, 0x9e, 0x01, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x19, 0x0a,
    0x0c, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x10, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x10, 0x0a, 0x0c, 0x55, 0x54, 0x49, 0x4c,
    0x49, 0x5a, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x45,
    0x4d, 0x50, 0x45, 0x52, 0x41, 0x54, 0x55, 0x52, 0x45, 0x53, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a,
    0x43, 0x41, 0x50, 0x41, 0x43, 0x49, 0x54, 0x49, 0x45, 0x53, 0x10, 0x02, 0x12, 0x11, 0x0a, 0x0d,
    0x43, 0x4f, 0x4e, 0x46, 0x49, 0x47, 0x55, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x12,
    0x0e, 0x0a, 0x0a, 0x53, 0x54, 0x41, 0x54, 0x49, 0x53, 0x54, 0x49, 0x43, 0x53, 0x10, 0x04, 0x12,
    0x0c, 0x0a, 0x08, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x53, 0x10, 0x05, 0x12, 0x0a, 0x0a,
    0x06, 0x4c, 0x49, 0x4d, 0x49, 0x54, 0x53, 0x10, 0x06, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x45, 0x56,
    0x49, 0x43, 0x45, 0x10, 0x07, 0x1a, 0xfd, 0x05, 0x0a, 0x08, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69,
    0x74, 0x79, 0x12, 0x3c, 0x0a, 0x03, 0x61, 0x63, 0x6c, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x2f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69,
    0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x2e, 0x41, 0x43, 0x4c,
    0x12, 0x12, 0x0a, 0x0a, 0x6f, 0x6c, 0x64, 0x4c, 0x6f, 0x63, 0x6b, 0x50, 0x49, 0x4e, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x0c, 0x12, 0x12, 0x0a, 0x0a, 0x6e, 0x65, 0x77, 0x4c, 0x6f, 0x63, 0x6b, 0x50,
    0x49, 0x4e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x13, 0x0a, 0x0b, 0x6f, 0x6c, 0x64, 0x45,
    0x72, 0x61, 0x73, 0x65, 0x50, 0x49, 0x4e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x13, 0x0a,
    0x0b, 0x6e, 0x65, 0x77, 0x45, 0x72, 0x61, 0x73, 0x65, 0x50, 0x49, 0x4e, 0x18, 0x06, 0x20, 0x01,
    0x28, 0x0c, 0x1a, 0xe0, 0x04, 0x0a, 0x03, 0x41, 0x43, 0x4c, 0x12, 0x10, 0x0a, 0x08, 0x69, 0x64,
    0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0b, 0x0a, 0x03,
    0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x54, 0x0a, 0x0d, 0x68, 0x6d, 0x61,
    0x63, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e,
    0x32, 0x3d, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b,
    0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x2e, 0x41, 0x43,
    0x4c, 0x2e, 0x48, 0x4d, 0x41, 0x43, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x12,
    0x44, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x35,
    0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e,
    0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61,
    0x6e, 0x64, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x2e, 0x41, 0x43, 0x4c, 0x2e,
    0x53, 0x63, 0x6f, 0x70, 0x65, 0x12, 0x40, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x50, 0x72, 0x69, 0x6f,
    0x72, 0x69, 0x74, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2b, 0x2e, 0x63, 0x6f, 0x6d,
    0x2e, 0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63,
    0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x50,
    0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x1a, 0x8b, 0x01, 0x0a, 0x05, 0x53, 0x63, 0x6f, 0x70,
    0x65, 0x12, 0x0e, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x03, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c,
    0x12, 0x4e, 0x0a, 0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03,
    0x20, 0x03, 0x28, 0x0e, 0x32, 0x3a, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x65, 0x61, 0x67, 0x61,
    0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
    0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
    0x79, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e,
    0x12, 0x13, 0x0a, 0x0b, 0x54, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x08, 0x22, 0x42, 0x0a, 0x0d, 0x48, 0x4d, 0x41, 0x43, 0x41, 0x6c, 0x67,
    0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x12, 0x23, 0x0a, 0x16, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49,
    0x44, 0x5f, 0x48, 0x4d, 0x41, 0x43, 0x5f, 0x41, 0x4c, 0x47, 0x4f, 0x52, 0x49, 0x54, 0x48, 0x4d,
    0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x48,
    0x6d, 0x61, 0x63, 0x53, 0x48, 0x41, 0x31, 0x10, 0x01, 0x22, 0x89, 0x01, 0x0a, 0x0a, 0x50, 0x65,
    0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a, 0x12, 0x49, 0x4e, 0x56, 0x41,
    0x4c, 0x49, 0x44, 0x5f, 0x50, 0x45, 0x52, 0x4d, 0x49, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x10, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x52, 0x45, 0x41,
    0x44, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x57, 0x52, 0x49, 0x54, 0x45, 0x10, 0x01, 0x12, 0x0a,
    0x0a, 0x06, 0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x02, 0x12, 0x09, 0x0a, 0x05, 0x52, 0x41,
    0x4e, 0x47, 0x45, 0x10, 0x03, 0x12, 0x09, 0x0a, 0x05, 0x53, 0x45, 0x54, 0x55, 0x50, 0x10, 0x04,
    0x12, 0x09, 0x0a, 0x05, 0x50, 0x32, 0x50, 0x4f, 0x50, 0x10, 0x05, 0x12, 0x0a, 0x0a, 0x06, 0x47,
    0x45, 0x54, 0x4c, 0x4f, 0x47, 0x10, 0x07, 0x12, 0x0c, 0x0a, 0x08, 0x53, 0x45, 0x43, 0x55, 0x52,
    0x49, 0x54, 0x59, 0x10, 0x08, 0x1a, 0xd0, 0x01, 0x0a, 0x0c, 0x50, 0x69, 0x6e, 0x4f, 0x70, 0x65,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x4c, 0x0a, 0x09, 0x70, 0x69, 0x6e, 0x4f, 0x70, 0x54,
    0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x39, 0x2e, 0x63, 0x6f, 0x6d, 0x2e,
    0x73, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x2e, 0x6b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63, 0x2e,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x50, 0x69,
    0x6e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x50, 0x69, 0x6e, 0x4f, 0x70,
    0x54, 0x79, 0x70, 0x65, 0x22, 0x72, 0x0a, 0x09, 0x50, 0x69, 0x6e, 0x4f, 0x70, 0x54, 0x79, 0x70,
    0x65, 0x12, 0x1a, 0x0a, 0x0d, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x50, 0x49, 0x4e,
    0x4f, 0x50, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x10, 0x0a,
    0x0c, 0x55, 0x4e, 0x4c, 0x4f, 0x43, 0x4b, 0x5f, 0x50, 0x49, 0x4e, 0x4f, 0x50, 0x10, 0x01, 0x12,
    0x0e, 0x0a, 0x0a, 0x4c, 0x4f, 0x43, 0x4b, 0x5f, 0x50, 0x49, 0x4e, 0x4f, 0x50, 0x10, 0x02, 0x12,
    0x0f, 0x0a, 0x0b, 0x45, 0x52, 0x41, 0x53, 0x45, 0x5f, 0x50, 0x49, 0x4e, 0x4f, 0x50, 0x10, 0x03,
    0x12, 0x16, 0x0a, 0x12, 0x53, 0x45, 0x43, 0x55, 0x52, 0x45, 0x5f, 0x45, 0x52, 0x41, 0x53, 0x45,
    0x5f, 0x50, 0x49, 0x4e, 0x4f, 0x50, 0x10, 0x04, 0x22, 0x63, 0x0a, 0x0f, 0x53, 0x79, 0x6e, 0x63,
    0x68, 0x72, 0x6f, 0x6e, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x17, 0x49,
    0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x53, 0x59, 0x4e, 0x43, 0x48, 0x52, 0x4f, 0x4e, 0x49,
    0x5a, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x01, 0x12, 0x10, 0x0a, 0x0c, 0x57, 0x52, 0x49, 0x54, 0x45, 0x54, 0x48, 0x52, 0x4f, 0x55, 0x47,
    0x48, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x57, 0x52, 0x49, 0x54, 0x45, 0x42, 0x41, 0x43, 0x4b,
    0x10, 0x02, 0x12, 0x09, 0x0a, 0x05, 0x46, 0x4c, 0x55, 0x53, 0x48, 0x10, 0x03, 0x22, 0x46, 0x0a,
    0x08, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x12, 0x0a, 0x0a, 0x06, 0x4e, 0x4f, 0x52,
    0x4d, 0x41, 0x4c, 0x10, 0x05, 0x12, 0x0a, 0x0a, 0x06, 0x4c, 0x4f, 0x57, 0x45, 0x53, 0x54, 0x10,
    0x01, 0x12, 0x09, 0x0a, 0x05, 0x4c, 0x4f, 0x57, 0x45, 0x52, 0x10, 0x03, 0x12, 0x0a, 0x0a, 0x06,
    0x48, 0x49, 0x47, 0x48, 0x45, 0x52, 0x10, 0x07, 0x12, 0x0b, 0x0a, 0x07, 0x48, 0x49, 0x47, 0x48,
    0x45, 0x53, 0x54, 0x10, 0x09, 0x22, 0x5f, 0x0a, 0x09, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74,
    0x68, 0x6d, 0x12, 0x1e, 0x0a, 0x11, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x5f, 0x41, 0x4c,
    0x47, 0x4f, 0x52, 0x49, 0x54, 0x48, 0x4d, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x53, 0x48, 0x41, 0x31, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04,
    0x53, 0x48, 0x41, 0x32, 0x10, 0x02, 0x12, 0x08, 0x0a, 0x04, 0x53, 0x48, 0x41, 0x33, 0x10, 0x03,
    0x12, 0x09, 0x0a, 0x05, 0x43, 0x52, 0x43, 0x33, 0x32, 0x10, 0x04, 0x12, 0x09, 0x0a, 0x05, 0x43,
    0x52, 0x43, 0x36, 0x34, 0x10, 0x05, 0x22, 0xfc, 0x04, 0x0a, 0x0b, 0x4d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x21, 0x0a, 0x14, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49,
    0x44, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x10, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x47, 0x45, 0x54,
    0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x47, 0x45, 0x54, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e,
    0x53, 0x45, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x50, 0x55, 0x54, 0x10, 0x04, 0x12, 0x10, 0x0a,
    0x0c, 0x50, 0x55, 0x54, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x03, 0x12,
    0x0a, 0x0a, 0x06, 0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x06, 0x12, 0x13, 0x0a, 0x0f, 0x44,
    0x45, 0x4c, 0x45, 0x54, 0x45, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x05,
    0x12, 0x0b, 0x0a, 0x07, 0x47, 0x45, 0x54, 0x4e, 0x45, 0x58, 0x54, 0x10, 0x08, 0x12, 0x14, 0x0a,
    0x10, 0x47, 0x45, 0x54, 0x4e, 0x45, 0x58, 0x54, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53,
    0x45, 0x10, 0x07, 0x12, 0x0f, 0x0a, 0x0b, 0x47, 0x45, 0x54, 0x50, 0x52, 0x45, 0x56, 0x49, 0x4f,
    0x55, 0x53, 0x10, 0x0a, 0x12, 0x18, 0x0a, 0x14, 0x47, 0x45, 0x54, 0x50, 0x52, 0x45, 0x56, 0x49,
    0x4f, 0x55, 0x53, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x09, 0x12, 0x0f,
    0x0a, 0x0b, 0x47, 0x45, 0x54, 0x4b, 0x45, 0x59, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x10, 0x0c, 0x12,
    0x18, 0x0a, 0x14, 0x47, 0x45, 0x54, 0x4b, 0x45, 0x59, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x5f, 0x52,
    0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x0b, 0x12, 0x0e, 0x0a, 0x0a, 0x47, 0x45, 0x54,
    0x56, 0x45, 0x52, 0x53, 0x49, 0x4f, 0x4e, 0x10, 0x10, 0x12, 0x17, 0x0a, 0x13, 0x47, 0x45, 0x54,
    0x56, 0x45, 0x52, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45,
    0x10, 0x0f, 0x12, 0x09, 0x0a, 0x05, 0x53, 0x45, 0x54, 0x55, 0x50, 0x10, 0x16, 0x12, 0x12, 0x0a,
    0x0e, 0x53, 0x45, 0x54, 0x55, 0x50, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10,
    0x15, 0x12, 0x0a, 0x0a, 0x06, 0x47, 0x45, 0x54, 0x4c, 0x4f, 0x47, 0x10, 0x18, 0x12, 0x13, 0x0a,
    0x0f, 0x47, 0x45, 0x54, 0x4c, 0x4f, 0x47, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45,
    0x10, 0x17, 0x12, 0x0c, 0x0a, 0x08, 0x53, 0x45, 0x43, 0x55, 0x52, 0x49, 0x54, 0x59, 0x10, 0x1a,
    0x12, 0x15, 0x0a, 0x11, 0x53, 0x45, 0x43, 0x55, 0x52, 0x49, 0x54, 0x59, 0x5f, 0x52, 0x45, 0x53,
    0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x19, 0x12, 0x11, 0x0a, 0x0d, 0x50, 0x45, 0x45, 0x52, 0x32,
    0x50, 0x45, 0x45, 0x52, 0x50, 0x55, 0x53, 0x48, 0x10, 0x1c, 0x12, 0x1a, 0x0a, 0x16, 0x50, 0x45,
    0x45, 0x52, 0x32, 0x50, 0x45, 0x45, 0x52, 0x50, 0x55, 0x53, 0x48, 0x5f, 0x52, 0x45, 0x53, 0x50,
    0x4f, 0x4e, 0x53, 0x45, 0x10, 0x1b, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4f, 0x50, 0x10, 0x1e,
    0x12, 0x11, 0x0a, 0x0d, 0x4e, 0x4f, 0x4f, 0x50, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53,
    0x45, 0x10, 0x1d, 0x12, 0x10, 0x0a, 0x0c, 0x46, 0x4c, 0x55, 0x53, 0x48, 0x41, 0x4c, 0x4c, 0x44,
    0x41, 0x54, 0x41, 0x10, 0x20, 0x12, 0x19, 0x0a, 0x15, 0x46, 0x4c, 0x55, 0x53, 0x48, 0x41, 0x4c,
    0x4c, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x1f,
    0x12, 0x09, 0x0a, 0x05, 0x50, 0x49, 0x4e, 0x4f, 0x50, 0x10, 0x24, 0x12, 0x12, 0x0a, 0x0e, 0x50,
    0x49, 0x4e, 0x4f, 0x50, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x10, 0x23, 0x12,
    0x0d, 0x0a, 0x09, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x53, 0x43, 0x41, 0x4e, 0x10, 0x26, 0x12, 0x16,
    0x0a, 0x12, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x53, 0x43, 0x41, 0x4e, 0x5f, 0x52, 0x45, 0x53, 0x50,
    0x4f, 0x4e, 0x53, 0x45, 0x10, 0x25, 0x12, 0x11, 0x0a, 0x0d, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x4f,
    0x50, 0x54, 0x49, 0x4d, 0x49, 0x5a, 0x45, 0x10, 0x28, 0x12, 0x1a, 0x0a, 0x16, 0x4d, 0x45, 0x44,
    0x49, 0x41, 0x4f, 0x50, 0x54, 0x49, 0x4d, 0x49, 0x5a, 0x45, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f,
    0x4e, 0x53, 0x45, 0x10, 0x27, 0x42, 0x09, 0x42, 0x07, 0x4b, 0x69, 0x6e, 0x65, 0x74, 0x69, 0x63,
    0x4a, 0xa3, 0xf7, 0x01, 0x0a, 0x07, 0x12, 0x05, 0x12, 0x00, 0xc2, 0x05, 0x01, 0x0a, 0x08, 0x0a,
    0x01, 0x02, 0x12, 0x03, 0x12, 0x08, 0x21, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x14, 0x00,
    0x28, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x14, 0x00, 0x28, 0x0a, 0x0c,
    0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x14, 0x07, 0x1b, 0x0a, 0x0d, 0x0a, 0x06,
    0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x14, 0x07, 0x1b, 0x0a, 0x0e, 0x0a, 0x07, 0x08,
    0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x14, 0x07, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x08,
    0xe7, 0x07, 0x00, 0x07, 0x12, 0x03, 0x14, 0x1e, 0x27, 0x0a, 0x96, 0x01, 0x0a, 0x02, 0x04, 0x00,
    0x12, 0x04, 0x19, 0x00, 0x1b, 0x01, 0x1a, 0x89, 0x01, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69,
    0x73, 0x20, 0x61, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70,
    0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x61, 0x64, 0x0a, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x62, 0x79, 0x20, 0x62,
    0x75, 0x69, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x0a, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x72,
    0x65, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x19, 0x08, 0x0d, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x1a, 0x08, 0x40, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x1a, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x00, 0x05, 0x12, 0x03, 0x1a, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x1a, 0x18, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x1a, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x08, 0x12, 0x03, 0x1a, 0x2c,
    0x3f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x07, 0x12, 0x03, 0x1a, 0x37, 0x3e, 0x0a,
    0x40, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x1e, 0x00, 0x57, 0x01, 0x1a, 0x34, 0x20, 0x54, 0x48,
    0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20,
    0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e,
    0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x1e, 0x08, 0x0f, 0x0a, 0x40, 0x0a,
    0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03, 0x23, 0x08, 0x27, 0x1a, 0x33, 0x20, 0x45, 0x76, 0x65,
    0x72, 0x79, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20,
    0x62, 0x65, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f,
    0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x23, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x00, 0x06, 0x12, 0x03, 0x23, 0x11, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x23, 0x1a, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02,
    0x00, 0x03, 0x12, 0x03, 0x23, 0x25, 0x26, 0x0a, 0x1e, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x01, 0x12,
    0x03, 0x26, 0x08, 0x27, 0x1a, 0x11, 0x20, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x04,
    0x12, 0x03, 0x26, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x06, 0x12, 0x03,
    0x26, 0x11, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x26, 0x1a,
    0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x03, 0x12, 0x03, 0x26, 0x25, 0x26, 0x0a,
    0x56, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x02, 0x12, 0x03, 0x2a, 0x08, 0x25, 0x1a, 0x49, 0x20, 0x66,
    0x6f, 0x72, 0x20, 0x50, 0x69, 0x6e, 0x20, 0x62, 0x61, 0x73, 0x65, 0x64, 0x20, 0x6f, 0x70, 0x65,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x69,
    0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x75, 0x6e,
    0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65,
    0x20, 0x65, 0x72, 0x61, 0x73, 0x65, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x04,
    0x12, 0x03, 0x2a, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x06, 0x12, 0x03,
    0x2a, 0x11, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x01, 0x12, 0x03, 0x2a, 0x19,
    0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x02, 0x03, 0x12, 0x03, 0x2a, 0x23, 0x24, 0x0a,
    0x70, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x03, 0x12, 0x03, 0x2e, 0x08, 0x28, 0x1a, 0x63, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x65, 0x6d, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64, 0x20, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x28, 0x66, 0x6f, 0x72, 0x20, 0x48,
    0x4d, 0x41, 0x43, 0x61, 0x75, 0x74, 0x68, 0x29, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x20, 0x28, 0x66, 0x6f, 0x72, 0x20,
    0x61, 0x6c, 0x6c, 0x20, 0x61, 0x75, 0x74, 0x68, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x29, 0x2e,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x04, 0x12, 0x03, 0x2e, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x03, 0x05, 0x12, 0x03, 0x2e, 0x11, 0x16, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x03, 0x01, 0x12, 0x03, 0x2e, 0x17, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x02, 0x03, 0x03, 0x12, 0x03, 0x2e, 0x26, 0x27, 0x0a, 0x53, 0x0a, 0x04, 0x04, 0x01, 0x04,
    0x00, 0x12, 0x04, 0x31, 0x08, 0x42, 0x09, 0x1a, 0x45, 0x20, 0x54, 0x68, 0x65, 0x20, 0x4d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72,
    0x6d, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x6f, 0x20,
    0x62, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x01, 0x04, 0x00, 0x01, 0x12, 0x03, 0x31, 0x0d, 0x15, 0x0a, 0x45, 0x0a, 0x06,
    0x04, 0x01, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x34, 0x10, 0x27, 0x1a, 0x36, 0x20, 0x69, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x74, 0x79, 0x70,
    0x65, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x2c, 0x20, 0x63, 0x6c,
    0x6f, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x34, 0x10, 0x21, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x03,
    0x34, 0x24, 0x26, 0x0a, 0x70, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x12, 0x03, 0x38,
    0x10, 0x1d, 0x1a, 0x61, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x20, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x2e,
    0x20, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x48, 0x4d, 0x41, 0x43, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x61,
    0x6e, 0x64, 0x0a, 0x20, 0x69, 0x66, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x2c, 0x20,
    0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x01,
    0x12, 0x03, 0x38, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x01, 0x02,
    0x12, 0x03, 0x38, 0x1b, 0x1c, 0x0a, 0xbe, 0x01, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x02,
    0x12, 0x03, 0x3d, 0x10, 0x1c, 0x1a, 0xae, 0x01, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20,
    0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x49, 0x53, 0x45, 0x20, 0x63,
    0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x6d, 0x75,
    0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x54, 0x4c, 0x53, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
    0x0a, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f, 0x74,
    0x2c, 0x20, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x6e,
    0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
    0x20, 0x6f, 0x76, 0x65, 0x72, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x54, 0x4c, 0x53, 0x20, 0x63,
    0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x69, 0x6e, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x03, 0x3d, 0x10, 0x17, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x02,
    0x02, 0x12, 0x03, 0x3d, 0x1a, 0x1b, 0x0a, 0x7e, 0x0a, 0x06, 0x04, 0x01, 0x04, 0x00, 0x02, 0x03,
    0x12, 0x03, 0x41, 0x10, 0x26, 0x1a, 0x6f, 0x20, 0x49, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65,
    0x76, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65,
    0x76, 0x69, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f,
    0x20, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65,
    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x75, 0x6e, 0x73, 0x6f, 0x6c,
    0x69, 0x63, 0x69, 0x74, 0x65, 0x64, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x77, 0x69,
    0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x66,
    0x69, 0x72, 0x73, 0x74, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x03,
    0x01, 0x12, 0x03, 0x41, 0x10, 0x21, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x04, 0x00, 0x02, 0x03,
    0x02, 0x12, 0x03, 0x41, 0x24, 0x25, 0x0a, 0xc2, 0x01, 0x0a, 0x04, 0x04, 0x01, 0x03, 0x00, 0x12,
    0x04, 0x48, 0x08, 0x4e, 0x09, 0x1a, 0xb3, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x20, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63,
    0x65, 0x0a, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x0a, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6e, 0x6c, 0x6f,
    0x63, 0x6b, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x48, 0x4d, 0x41, 0x43, 0x20, 0x70,
    0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x0a, 0x20, 0x61, 0x75, 0x74,
    0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x69, 0x74, 0x79, 0x2c, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x67,
    0x72, 0x69, 0x74, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x65, 0x6e, 0x66, 0x6f,
    0x72, 0x63, 0x65, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x01, 0x03, 0x00, 0x01, 0x12, 0x03, 0x48, 0x10, 0x18, 0x0a, 0x68, 0x0a, 0x06, 0x04, 0x01, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x03, 0x4c, 0x10, 0x2c, 0x1a, 0x59, 0x20, 0x54, 0x68, 0x65, 0x20, 0x22,
    0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x22, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69,
    0x66, 0x69, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x20, 0x74, 0x6f, 0x0a,
    0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x68, 0x6d, 0x61,
    0x63, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03,
    0x4c, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03,
    0x4c, 0x19, 0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x4c, 0x1f, 0x27, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x4c, 0x2a, 0x2b, 0x0a, 0x0d, 0x0a, 0x06, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x12, 0x03, 0x4d,
    0x10, 0x28, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x03, 0x4d,
    0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x03, 0x4d,
    0x19, 0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x4d,
    0x1f, 0x23, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x4d,
    0x26, 0x27, 0x0a, 0x3c, 0x0a, 0x04, 0x04, 0x01, 0x03, 0x01, 0x12, 0x04, 0x51, 0x08, 0x55, 0x09,
    0x1a, 0x2e, 0x20, 0x50, 0x69, 0x6e, 0x20, 0x62, 0x61, 0x73, 0x65, 0x64, 0x20, 0x61, 0x75, 0x74,
    0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x50, 0x69, 0x6e, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x03, 0x01, 0x01, 0x12, 0x03, 0x51, 0x10, 0x17, 0x0a, 0x3f,
    0x0a, 0x06, 0x04, 0x01, 0x03, 0x01, 0x02, 0x00, 0x12, 0x03, 0x54, 0x10, 0x27, 0x1a, 0x30, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x70, 0x69, 0x6e, 0x20, 0x6e, 0x65, 0x63, 0x65, 0x73, 0x73, 0x61, 0x72,
    0x79, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x0a, 0x0a,
    0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x54, 0x10, 0x18, 0x0a,
    0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x03, 0x54, 0x19, 0x1e, 0x0a,
    0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x54, 0x1f, 0x22, 0x0a,
    0x0e, 0x0a, 0x07, 0x04, 0x01, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03, 0x54, 0x25, 0x26, 0x0a,
    0x0b, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x05, 0x59, 0x00, 0xc2, 0x05, 0x01, 0x0a, 0x0a, 0x0a, 0x03,
    0x04, 0x02, 0x01, 0x12, 0x03, 0x59, 0x08, 0x0f, 0x0a, 0x1c, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x00,
    0x12, 0x03, 0x5c, 0x08, 0x23, 0x1a, 0x0f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x68,
    0x65, 0x61, 0x64, 0x65, 0x72, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x04, 0x12,
    0x03, 0x5c, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x06, 0x12, 0x03, 0x5c,
    0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x5c, 0x18, 0x1e,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x03, 0x12, 0x03, 0x5c, 0x21, 0x22, 0x0a, 0x1a,
    0x0a, 0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x5f, 0x08, 0x1f, 0x1a, 0x0d, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x20, 0x62, 0x6f, 0x64, 0x79, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x01, 0x04, 0x12, 0x03, 0x5f, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01,
    0x06, 0x12, 0x03, 0x5f, 0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x01, 0x12,
    0x03, 0x5f, 0x16, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x03, 0x12, 0x03, 0x5f,
    0x1d, 0x1e, 0x0a, 0x1e, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x02, 0x12, 0x03, 0x62, 0x08, 0x23, 0x1a,
    0x11, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75,
    0x73, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x04, 0x12, 0x03, 0x62, 0x08, 0x10,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x06, 0x12, 0x03, 0x62, 0x11, 0x17, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x01, 0x12, 0x03, 0x62, 0x18, 0x1e, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x02, 0x03, 0x12, 0x03, 0x62, 0x21, 0x22, 0x0a, 0x1e, 0x0a, 0x04, 0x04, 0x02,
    0x03, 0x00, 0x12, 0x05, 0x65, 0x08, 0x9e, 0x01, 0x09, 0x1a, 0x0f, 0x6d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x20, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x03, 0x00, 0x01, 0x12, 0x03, 0x65, 0x10, 0x16, 0x0a, 0x87, 0x02, 0x0a, 0x06, 0x04, 0x02, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x03, 0x6a, 0x10, 0x32, 0x1a, 0xf7, 0x01, 0x20, 0x22, 0x63, 0x6c, 0x75,
    0x73, 0x74, 0x65, 0x72, 0x22, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x20, 0x6e, 0x75,
    0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x75, 0x73,
    0x74, 0x65, 0x72, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20,
    0x49, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6f, 0x6d,
    0x70, 0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x2c, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6d, 0x69, 0x73, 0x73,
    0x69, 0x6e, 0x67, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x73, 0x73, 0x75, 0x6d,
    0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x30, 0x2e, 0x20, 0x28, 0x30, 0x20, 0x61,
    0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x73, 0x20, 0x6e, 0x6f,
    0x74, 0x0a, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72,
    0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x69,
    0x67, 0x6e, 0x6f, 0x72, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x74, 0x75, 0x70, 0x2e,
    0x29, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x6a,
    0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x6a,
    0x19, 0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x6a,
    0x1f, 0x2d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03, 0x6a,
    0x30, 0x31, 0x0a, 0xd7, 0x02, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x00, 0x02, 0x01, 0x12, 0x03, 0x72,
    0x10, 0x30, 0x1a, 0xc7, 0x02, 0x20, 0x41, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x6e,
    0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x63,
    0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65,
    0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x2e, 0x20, 0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x0a, 0x20, 0x74,
    0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2c, 0x20, 0x74, 0x68,
    0x69, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x64, 0x61, 0x79, 0x20, 0x69, 0x6e, 0x20,
    0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x31, 0x39,
    0x37, 0x30, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x63,
    0x61, 0x6e, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20,
    0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x69,
    0x6e, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e,
    0x65, 0x77, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x72, 0x65,
    0x6d, 0x61, 0x69, 0x6e, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x20, 0x64,
    0x75, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f,
    0x6e, 0x2e, 0x20, 0x28, 0x53, 0x65, 0x65, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
    0x20, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x29, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x03, 0x72, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x03, 0x72, 0x19, 0x1e, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x72, 0x1f, 0x2b, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x72, 0x2e, 0x2f, 0x0a, 0xa1, 0x02, 0x0a,
    0x06, 0x04, 0x02, 0x03, 0x00, 0x02, 0x02, 0x12, 0x03, 0x77, 0x10, 0x2c, 0x1a, 0x91, 0x02, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x69, 0x6e, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x54, 0x43, 0x50, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x41, 0x73, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x73, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x67, 0x65,
    0x74, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x6c, 0x61, 0x72, 0x67, 0x65, 0x72, 0x20, 0x77, 0x65, 0x20,
    0x68, 0x61, 0x76, 0x65, 0x0a, 0x20, 0x73, 0x74, 0x72, 0x6f, 0x6e, 0x67, 0x20, 0x6f, 0x72, 0x64,
    0x65, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x79,
    0x20, 0x70, 0x72, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x69, 0x6e, 0x20, 0x61, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x54, 0x68,
    0x69, 0x73, 0x20, 0x63, 0x6f, 0x6d, 0x62, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x6f,
    0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x0a, 0x20, 0x70, 0x72, 0x6f, 0x76,
    0x69, 0x64, 0x65, 0x73, 0x20, 0x73, 0x74, 0x72, 0x6f, 0x6e, 0x67, 0x20, 0x6f, 0x72, 0x64, 0x65,
    0x72, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x73, 0x65, 0x73,
    0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x20, 0x28, 0x53, 0x65, 0x65, 0x20, 0x73, 0x65, 0x63, 0x75,
    0x72, 0x69, 0x74, 0x79, 0x20, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x29, 0x2e, 0x0a,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x03, 0x77, 0x10, 0x18,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x03, 0x77, 0x19, 0x1e,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x77, 0x1f, 0x27,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x03, 0x77, 0x2a, 0x2b,
    0x0a, 0x23, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x00, 0x02, 0x03, 0x12, 0x03, 0x7a, 0x10, 0x2f, 0x1a,
    0x14, 0x63, 0x6f, 0x2d, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x20, 0x73, 0x65, 0x71, 0x75,
    0x65, 0x6e, 0x63, 0x65, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x03, 0x04,
    0x12, 0x03, 0x7a, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x03, 0x05,
    0x12, 0x03, 0x7a, 0x19, 0x1e, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x03, 0x01,
    0x12, 0x03, 0x7a, 0x1f, 0x2a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x03, 0x03,
    0x12, 0x03, 0x7a, 0x2d, 0x2e, 0x0a, 0x3c, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x00, 0x02, 0x04, 0x12,
    0x03, 0x7d, 0x10, 0x35, 0x1a, 0x2d, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x63, 0x6f, 0x64, 0x65, 0x20, 0x2d, 0x20, 0x70, 0x75, 0x74, 0x2f, 0x67, 0x65, 0x74, 0x2f, 0x64,
    0x65, 0x6c, 0x65, 0x74, 0x65, 0x2f, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x67, 0x2c, 0x20, 0x65, 0x74,
    0x63, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x03,
    0x7d, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x04, 0x06, 0x12, 0x03,
    0x7d, 0x19, 0x24, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03,
    0x7d, 0x25, 0x30, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x03,
    0x7d, 0x33, 0x34, 0x0a, 0xff, 0x03, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04,
    0x87, 0x01, 0x10, 0x2b, 0x1a, 0xee, 0x03, 0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20,
    0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x20, 0x28, 0x69, 0x6e, 0x20, 0x6d, 0x73, 0x29, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6d, 0x6f,
    0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x73, 0x68,
    0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68,
    0x69, 0x73, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x0a, 0x20, 0x69, 0x73, 0x20, 0x74,
    0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x65, 0x64, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x72, 0x65, 0x65, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62,
    0x6c, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x2e,
    0x0a, 0x20, 0x20, 0x20, 0x2d, 0x20, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x42, 0x55,
    0x53, 0x59, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x77, 0x61, 0x73, 0x20,
    0x73, 0x74, 0x69, 0x6c, 0x6c, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x71, 0x75, 0x65,
    0x75, 0x65, 0x20, 0x77, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x2d, 0x20, 0x45,
    0x58, 0x50, 0x49, 0x52, 0x45, 0x44, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x20, 0x61, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x69,
    0x6e, 0x67, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x61, 0x73,
    0x20, 0x73, 0x74, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65,
    0x64, 0x2e, 0x0a, 0x20, 0x20, 0x20, 0x2d, 0x20, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x52, 0x52,
    0x4f, 0x52, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x77, 0x61, 0x73, 0x20,
    0x69, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x72,
    0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x77, 0x61, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x0a,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65,
    0x74, 0x65, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x65, 0x78, 0x70,
    0x69, 0x72, 0x65, 0x64, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x05, 0x04,
    0x12, 0x04, 0x87, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x05,
    0x05, 0x12, 0x04, 0x87, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02,
    0x05, 0x01, 0x12, 0x04, 0x87, 0x01, 0x1f, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00,
    0x02, 0x05, 0x03, 0x12, 0x04, 0x87, 0x01, 0x29, 0x2a, 0x0a, 0xa5, 0x04, 0x0a, 0x06, 0x04, 0x02,
    0x03, 0x00, 0x02, 0x06, 0x12, 0x04, 0x8f, 0x01, 0x10, 0x2d, 0x1a, 0x94, 0x04, 0x20, 0x49, 0x66,
    0x20, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x20,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74,
    0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x20, 0x72, 0x65, 0x76, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x69, 0x65, 0x73, 0x20, 0x65, 0x76, 0x65,
    0x6e, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74,
    0x20, 0x68, 0x61, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65,
    0x64, 0x2e, 0x0a, 0x20, 0x49, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x63, 0x61, 0x73, 0x65,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c,
    0x20, 0x62, 0x65, 0x20, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x2e, 0x20,
    0x54, 0x6f, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69,
    0x63, 0x65, 0x20, 0x65, 0x78, 0x68, 0x61, 0x75, 0x73, 0x74, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x70,
    0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x72, 0x65,
    0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x2c, 0x20, 0x6c, 0x65, 0x61, 0x76, 0x65, 0x0a, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x20, 0x6f, 0x72,
    0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x20, 0x69, 0x73,
    0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x65,
    0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69,
    0x62, 0x6c, 0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x0a, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65,
    0x72, 0x79, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x20, 0x4f, 0x6e, 0x20, 0x61, 0x20, 0x64, 0x69,
    0x73, 0x6b, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d,
    0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x63,
    0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64,
    0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x2e, 0x0a, 0x20, 0x4f, 0x6e,
    0x63, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20,
    0x64, 0x61, 0x74, 0x61, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6f, 0x6d,
    0x70, 0x6c, 0x65, 0x74, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6e,
    0x6f, 0x74, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x65, 0x64, 0x65, 0x64, 0x2c, 0x20, 0x50, 0x45,
    0x52, 0x4d, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52, 0x20, 0x77, 0x69,
    0x6c, 0x6c, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0x8f, 0x01,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0x8f,
    0x01, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04,
    0x8f, 0x01, 0x1e, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12,
    0x04, 0x8f, 0x01, 0x2a, 0x2c, 0x0a, 0xd9, 0x01, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x00, 0x02, 0x07,
    0x12, 0x04, 0x96, 0x01, 0x10, 0x30, 0x1a, 0xc8, 0x01, 0x20, 0x50, 0x72, 0x69, 0x6f, 0x72, 0x69,
    0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x69,
    0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x65, 0x74, 0x65,
    0x72, 0x6d, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72,
    0x69, 0x74, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69,
    0x74, 0x79, 0x20, 0x61, 0x74, 0x20, 0x61, 0x20, 0x68, 0x69, 0x67, 0x68, 0x65, 0x72, 0x20, 0x70,
    0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x65, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74,
    0x0a, 0x20, 0x6f, 0x66, 0x20, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72,
    0x69, 0x74, 0x79, 0x20, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x2e, 0x20, 0x41, 0x20, 0x68,
    0x69, 0x67, 0x68, 0x65, 0x72, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20,
    0x68, 0x69, 0x67, 0x68, 0x65, 0x72, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x07, 0x04, 0x12, 0x04, 0x96, 0x01,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x07, 0x06, 0x12, 0x04, 0x96,
    0x01, 0x19, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04,
    0x96, 0x01, 0x22, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x07, 0x03, 0x12,
    0x04, 0x96, 0x01, 0x2d, 0x2f, 0x0a, 0xc3, 0x02, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x00, 0x02, 0x08,
    0x12, 0x04, 0x9d, 0x01, 0x10, 0x2f, 0x1a, 0xb2, 0x02, 0x20, 0x41, 0x20, 0x68, 0x69, 0x6e, 0x74,
    0x20, 0x6f, 0x66, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x6a,
    0x6f, 0x62, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x62, 0x65,
    0x66, 0x6f, 0x72, 0x65, 0x20, 0x79, 0x69, 0x65, 0x6c, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x20, 0x53,
    0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x0a, 0x20, 0x6d, 0x69, 0x6c,
    0x69, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x2e, 0x20, 0x41, 0x20, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x30, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x20,
    0x6f, 0x6e, 0x65, 0x0a, 0x20, 0x73, 0x75, 0x62, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x63, 0x68, 0x65, 0x63,
    0x6b, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72,
    0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x73, 0x75, 0x62, 0x20,
    0x68, 0x69, 0x67, 0x68, 0x65, 0x72, 0x0a, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79,
    0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x20, 0x41, 0x6e, 0x20,
    0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x73, 0x75, 0x62,
    0x2d, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74,
    0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x20, 0x70, 0x75, 0x74,
    0x0a, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x50, 0x32, 0x50, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x00, 0x02, 0x08, 0x04, 0x12, 0x04, 0x9d, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x00, 0x02, 0x08, 0x05, 0x12, 0x04, 0x9d, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x08, 0x01, 0x12, 0x04, 0x9d, 0x01, 0x1f, 0x29, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x00, 0x02, 0x08, 0x03, 0x12, 0x04, 0x9d, 0x01, 0x2c, 0x2e, 0x0a,
    0x1d, 0x0a, 0x04, 0x04, 0x02, 0x03, 0x01, 0x12, 0x06, 0xa1, 0x01, 0x08, 0xb9, 0x01, 0x09, 0x1a,
    0x0d, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x62, 0x6f, 0x64, 0x79, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x02, 0x03, 0x01, 0x01, 0x12, 0x04, 0xa1, 0x01, 0x10, 0x14, 0x0a, 0x1d, 0x0a,
    0x06, 0x04, 0x02, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xa4, 0x01, 0x10, 0x2f, 0x1a, 0x0d, 0x6b,
    0x65, 0x79, 0x2f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x6f, 0x70, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa4, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa4, 0x01, 0x19, 0x21, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa4, 0x01, 0x22, 0x2a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa4, 0x01, 0x2d, 0x2e,
    0x0a, 0x20, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x01, 0x10, 0x29,
    0x1a, 0x10, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa7,
    0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04,
    0xa7, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xa7, 0x01, 0x1f, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xa7, 0x01, 0x27, 0x28, 0x0a, 0x21, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x01, 0x02, 0x02,
    0x12, 0x04, 0xaa, 0x01, 0x10, 0x29, 0x1a, 0x11, 0x73, 0x65, 0x74, 0x20, 0x75, 0x70, 0x20, 0x6f,
    0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xaa, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x01, 0x02, 0x02, 0x06, 0x12, 0x04, 0xaa, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xaa, 0x01, 0x1f, 0x24, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xaa, 0x01, 0x27, 0x28, 0x0a, 0x2a, 0x0a,
    0x06, 0x04, 0x02, 0x03, 0x01, 0x02, 0x03, 0x12, 0x04, 0xad, 0x01, 0x10, 0x37, 0x1a, 0x1a, 0x20,
    0x50, 0x65, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x50, 0x65, 0x65, 0x72, 0x20, 0x6f, 0x70, 0x65,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x01, 0x02, 0x03, 0x04, 0x12, 0x04, 0xad, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x01, 0x02, 0x03, 0x06, 0x12, 0x04, 0xad, 0x01, 0x19, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xad, 0x01, 0x26, 0x32, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04, 0xad, 0x01, 0x35, 0x36, 0x0a, 0x17, 0x0a,
    0x06, 0x04, 0x02, 0x03, 0x01, 0x02, 0x04, 0x12, 0x04, 0xb2, 0x01, 0x10, 0x2b, 0x1a, 0x07, 0x47,
    0x65, 0x74, 0x4c, 0x6f, 0x67, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xb2, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02,
    0x04, 0x06, 0x12, 0x04, 0xb2, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xb2, 0x01, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x01, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb2, 0x01, 0x29, 0x2a, 0x0a, 0x20, 0x0a, 0x06, 0x04, 0x02,
    0x03, 0x01, 0x02, 0x05, 0x12, 0x04, 0xb5, 0x01, 0x10, 0x2f, 0x1a, 0x10, 0x73, 0x65, 0x74, 0x20,
    0x75, 0x70, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x01, 0x02, 0x05, 0x04, 0x12, 0x04, 0xb5, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x05, 0x06, 0x12, 0x04, 0xb5, 0x01, 0x19, 0x21, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x05, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x22, 0x2a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x05, 0x03, 0x12, 0x04, 0xb5, 0x01, 0x2d, 0x2e,
    0x0a, 0x2e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x01, 0x02, 0x06, 0x12, 0x04, 0xb8, 0x01, 0x10, 0x30,
    0x1a, 0x1e, 0x20, 0x50, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x50, 0x69, 0x6e, 0x2d, 0x62,
    0x61, 0x73, 0x65, 0x64, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x06, 0x04, 0x12, 0x04, 0xb8, 0x01, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x06, 0x06, 0x12, 0x04, 0xb8, 0x01,
    0x19, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb8,
    0x01, 0x26, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x01, 0x02, 0x06, 0x03, 0x12, 0x04,
    0xb8, 0x01, 0x2e, 0x2f, 0x0a, 0x21, 0x0a, 0x04, 0x04, 0x02, 0x03, 0x02, 0x12, 0x06, 0xbc, 0x01,
    0x08, 0x89, 0x02, 0x09, 0x1a, 0x11, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x03, 0x02, 0x01,
    0x12, 0x04, 0xbc, 0x01, 0x10, 0x16, 0x0a, 0x1c, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x02, 0x02, 0x00,
    0x12, 0x04, 0xbe, 0x01, 0x10, 0x2d, 0x1a, 0x0c, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x63,
    0x6f, 0x64, 0x65, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xbe, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x02, 0x02, 0x00, 0x06,
    0x12, 0x04, 0xbe, 0x01, 0x19, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x02, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xbe, 0x01, 0x24, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x02, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xbe, 0x01, 0x2b, 0x2c, 0x0a, 0x1f, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xc0, 0x01, 0x10, 0x32, 0x1a, 0x0f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x02, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc0, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x02, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc0, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc0, 0x01, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x02, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc0, 0x01, 0x30, 0x31, 0x0a, 0x37, 0x0a,
    0x06, 0x04, 0x02, 0x03, 0x02, 0x02, 0x02, 0x12, 0x04, 0xc2, 0x01, 0x10, 0x33, 0x1a, 0x27, 0x6f,
    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x65, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73,
    0x74, 0x61, 0x74, 0x75, 0x73, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x02, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xc2, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x02, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xc2, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x02,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xc2, 0x01, 0x1f, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x02, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc2, 0x01, 0x31, 0x32, 0x0a, 0x26, 0x0a, 0x06, 0x04, 0x02,
    0x03, 0x02, 0x04, 0x00, 0x12, 0x06, 0xc5, 0x01, 0x10, 0x87, 0x02, 0x11, 0x1a, 0x14, 0x65, 0x6e,
    0x75, 0x6d, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x63, 0x6f, 0x64,
    0x65, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x01, 0x12, 0x04, 0xc5,
    0x01, 0x15, 0x1f, 0x0a, 0x3a, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xc7, 0x01, 0x18, 0x31, 0x1a, 0x28, 0x20, 0x4d, 0x75, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d,
    0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x2c, 0x20, 0x73, 0x6f, 0x20, 0x64, 0x65, 0x66, 0x61,
    0x75, 0x6c, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x0a, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc7, 0x01,
    0x18, 0x2b, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12,
    0x04, 0xc7, 0x01, 0x2e, 0x30, 0x0a, 0x81, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00,
    0x02, 0x01, 0x12, 0x04, 0xcb, 0x01, 0x18, 0x2a, 0x1a, 0x6f, 0x20, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x61, 0x20, 0x50, 0x32, 0x50, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c,
    0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61,
    0x73, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x77, 0x61, 0x73,
    0x20, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69,
    0x73, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x0a, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x65, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x74,
    0x74, 0x65, 0x6d, 0x70, 0x74, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x02, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcb, 0x01, 0x18, 0x25, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xcb, 0x01, 0x28, 0x29, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xcc, 0x01, 0x18,
    0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xcc, 0x01, 0x18, 0x1f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x02,
    0x02, 0x12, 0x04, 0xcc, 0x01, 0x22, 0x23, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04,
    0x00, 0x02, 0x03, 0x12, 0x04, 0xcd, 0x01, 0x18, 0x29, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x02, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xcd, 0x01, 0x18, 0x24, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x04, 0xcd, 0x01, 0x27, 0x28, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x04, 0x12, 0x04, 0xce, 0x01, 0x18,
    0x2b, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xce, 0x01, 0x18, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x04,
    0x02, 0x12, 0x04, 0xce, 0x01, 0x29, 0x2a, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04,
    0x00, 0x02, 0x05, 0x12, 0x04, 0xcf, 0x01, 0x18, 0x2c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x02, 0x04, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xcf, 0x01, 0x18, 0x27, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x05, 0x02, 0x12, 0x04, 0xcf, 0x01, 0x2a, 0x2b, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x06, 0x12, 0x04, 0xd0, 0x01, 0x18,
    0x2b, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04,
    0xd0, 0x01, 0x18, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x06,
    0x02, 0x12, 0x04, 0xd0, 0x01, 0x29, 0x2a, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04,
    0x00, 0x02, 0x07, 0x12, 0x04, 0xd1, 0x01, 0x18, 0x2c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x02, 0x04, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0xd1, 0x01, 0x18, 0x27, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x07, 0x02, 0x12, 0x04, 0xd1, 0x01, 0x2a, 0x2b, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x08, 0x12, 0x04, 0xd2, 0x01, 0x18,
    0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x08, 0x01, 0x12, 0x04,
    0xd2, 0x01, 0x18, 0x21, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x08,
    0x02, 0x12, 0x04, 0xd2, 0x01, 0x24, 0x25, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04,
    0x00, 0x02, 0x09, 0x12, 0x04, 0xd3, 0x01, 0x18, 0x2d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x02, 0x04, 0x00, 0x02, 0x09, 0x01, 0x12, 0x04, 0xd3, 0x01, 0x18, 0x28, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x09, 0x02, 0x12, 0x04, 0xd3, 0x01, 0x2b, 0x2c, 0x0a,
    0xd9, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0a, 0x12, 0x04, 0xd8, 0x01,
    0x18, 0x29, 0x1a, 0xc6, 0x01, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x6d, 0x61, 0x6e, 0x79, 0x20, 0x72, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69,
    0x63, 0x65, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2c,
    0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x62, 0x65, 0x20, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x6d, 0x65, 0x73, 0x73,
    0x61, 0x67, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x20,
    0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x6f, 0x0a, 0x20,
    0x77, 0x61, 0x69, 0x74, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x74, 0x72, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c,
    0x20, 0x62, 0x61, 0x63, 0x6b, 0x2d, 0x6f, 0x66, 0x66, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xd8, 0x01, 0x18, 0x24, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0a, 0x02, 0x12, 0x04, 0xd8, 0x01, 0x27,
    0x28, 0x0a, 0x76, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0b, 0x12, 0x04, 0xdc,
    0x01, 0x18, 0x25, 0x1a, 0x64, 0x20, 0x41, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x6f, 0x70, 0x65,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x61, 0x73, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74,
    0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74,
    0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x65, 0x64, 0x20, 0x6d, 0x69, 0x64, 0x20, 0x6f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x64,
    0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x79, 0x20, 0x61, 0x20,
    0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x02, 0x04, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xdc, 0x01, 0x18, 0x1f, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0b, 0x02, 0x12, 0x04, 0xdc, 0x01, 0x22, 0x24, 0x0a,
    0x5f, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0c, 0x12, 0x04, 0xdf, 0x01, 0x18,
    0x28, 0x1a, 0x4d, 0x20, 0x41, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72,
    0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x65, 0x69,
    0x74, 0x68, 0x65, 0x72, 0x20, 0x65, 0x61, 0x72, 0x6c, 0x79, 0x45, 0x78, 0x69, 0x74, 0x20, 0x77,
    0x61, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69,
    0x6d, 0x65, 0x6f, 0x75, 0x74, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x65, 0x64, 0x2e, 0x0a,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xdf,
    0x01, 0x18, 0x22, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0c, 0x02,
    0x12, 0x04, 0xdf, 0x01, 0x25, 0x27, 0x0a, 0xfb, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04,
    0x00, 0x02, 0x0d, 0x12, 0x04, 0xe4, 0x01, 0x18, 0x2d, 0x1a, 0xe8, 0x01, 0x20, 0x41, 0x20, 0x64,
    0x61, 0x74, 0x61, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x68, 0x61, 0x70, 0x70, 0x65, 0x6e,
    0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69,
    0x62, 0x6c, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65,
    0x72, 0x79, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x68, 0x61,
    0x76, 0x65, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x0a, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d,
    0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x20,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x79, 0x69, 0x6e, 0x67, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x20, 0x68, 0x61, 0x73, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65,
    0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x72, 0x72,
    0x65, 0x63, 0x74, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c,
    0x20, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74,
    0x61, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x67, 0x65, 0x74, 0x20,
    0x72, 0x69, 0x64, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0d,
    0x01, 0x12, 0x04, 0xe4, 0x01, 0x18, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04,
    0x00, 0x02, 0x0d, 0x02, 0x12, 0x04, 0xe4, 0x01, 0x2a, 0x2c, 0x0a, 0x62, 0x0a, 0x08, 0x04, 0x02,
    0x03, 0x02, 0x04, 0x00, 0x02, 0x0e, 0x12, 0x04, 0xe7, 0x01, 0x18, 0x35, 0x1a, 0x50, 0x20, 0x41,
    0x20, 0x54, 0x43, 0x50, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x20, 0x70, 0x65,
    0x65, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x69, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x50, 0x32, 0x50, 0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xe7, 0x01, 0x18,
    0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0e, 0x02, 0x12, 0x04,
    0xe7, 0x01, 0x32, 0x34, 0x0a, 0x87, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02,
    0x0f, 0x12, 0x04, 0xeb, 0x01, 0x18, 0x26, 0x1a, 0x75, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6c,
    0x6c, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x73, 0x20, 0x74, 0x68,
    0x69, 0x73, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x62, 0x61,
    0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x73, 0x63, 0x72, 0x75, 0x62, 0x62, 0x69,
    0x6e, 0x67, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x66, 0x72, 0x65, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63,
    0x65, 0x2c, 0x0a, 0x20, 0x73, 0x6f, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x65, 0x72, 0x72, 0x6f,
    0x72, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x67, 0x6f, 0x20, 0x61, 0x77, 0x61, 0x79, 0x0a, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xeb, 0x01, 0x18,
    0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x0f, 0x02, 0x12, 0x04,
    0xeb, 0x01, 0x23, 0x25, 0x0a, 0x7c, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x10,
    0x12, 0x04, 0xef, 0x01, 0x18, 0x34, 0x1a, 0x6a, 0x20, 0x49, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x65, 0x74, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x2c, 0x20, 0x61, 0x6e,
    0x20, 0x48, 0x6d, 0x61, 0x63, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x20, 0x77,
    0x61, 0x73, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20,
    0x55, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65,
    0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x0a, 0x20,
    0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6d, 0x69, 0x73, 0x2d, 0x6d, 0x61, 0x74, 0x63,
    0x68, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x10, 0x01, 0x12,
    0x04, 0xef, 0x01, 0x18, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02,
    0x10, 0x02, 0x12, 0x04, 0xef, 0x01, 0x31, 0x33, 0x0a, 0xda, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03,
    0x02, 0x04, 0x00, 0x02, 0x11, 0x12, 0x04, 0xf3, 0x01, 0x18, 0x2d, 0x1a, 0xc7, 0x01, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x2e, 0x20, 0x53, 0x75, 0x62, 0x73, 0x65, 0x71, 0x75,
    0x65, 0x6e, 0x74, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x2e, 0x0a, 0x20, 0x45,
    0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x3a, 0x20, 0x47, 0x45, 0x54, 0x20, 0x64, 0x6f, 0x65,
    0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x20, 0x6b, 0x65,
    0x79, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2c, 0x20,
    0x47, 0x45, 0x54, 0x4b, 0x45, 0x59, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x20, 0x6f, 0x70, 0x65, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73,
    0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x4b, 0x65, 0x79, 0x2c,
    0x20, 0x65, 0x74, 0x63, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02,
    0x11, 0x01, 0x12, 0x04, 0xf3, 0x01, 0x18, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02,
    0x04, 0x00, 0x02, 0x11, 0x02, 0x12, 0x04, 0xf3, 0x01, 0x2a, 0x2c, 0x0a, 0xb4, 0x02, 0x0a, 0x08,
    0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x12, 0x12, 0x04, 0xf9, 0x01, 0x18, 0x35, 0x1a, 0xa1,
    0x02, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x50, 0x32, 0x50, 0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x73, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x77, 0x61, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x20, 0x73,
    0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x20, 0x62, 0x75, 0x74, 0x20,
    0x73, 0x6f, 0x6d, 0x65, 0x20, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x70, 0x65, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x0a, 0x20, 0x64, 0x69, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x73, 0x75, 0x63, 0x63, 0x65, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6e,
    0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6c,
    0x6c, 0x65, 0x72, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x72, 0x65, 0x76, 0x69,
    0x65, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6f, 0x66,
    0x20, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x73, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x62, 0x65, 0x20,
    0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x20, 0x3e, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2c, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x0a, 0x20, 0x6f, 0x66, 0x20, 0x6e, 0x65, 0x73,
    0x74, 0x65, 0x64, 0x20, 0x50, 0x32, 0x50, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x73, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x12, 0x01, 0x12,
    0x04, 0xf9, 0x01, 0x18, 0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02,
    0x12, 0x02, 0x12, 0x04, 0xf9, 0x01, 0x32, 0x34, 0x0a, 0x97, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03,
    0x02, 0x04, 0x00, 0x02, 0x13, 0x12, 0x04, 0xfe, 0x01, 0x18, 0x2b, 0x1a, 0x84, 0x01, 0x20, 0x49,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20,
    0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x76, 0x61, 0x6c,
    0x69, 0x64, 0x61, 0x74, 0x65, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x6d, 0x61, 0x63, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65,
    0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x0a, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x64,
    0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x13, 0x01, 0x12,
    0x04, 0xfe, 0x01, 0x18, 0x25, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02,
    0x13, 0x02, 0x12, 0x04, 0xfe, 0x01, 0x28, 0x2a, 0x0a, 0x7b, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x02,
    0x04, 0x00, 0x02, 0x14, 0x12, 0x04, 0x82, 0x02, 0x18, 0x35, 0x1a, 0x69, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x72, 0x65,
    0x61, 0x64, 0x79, 0x20, 0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x69, 0x74, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x0a, 0x20, 0x70, 0x69, 0x6e, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4e, 0x4f, 0x54, 0x20, 0x63,
    0x68, 0x65, 0x63, 0x6b, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x6e,
    0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x6f,
    0x70, 0x65, 0x6e, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02,
    0x14, 0x01, 0x12, 0x04, 0x82, 0x02, 0x18, 0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02,
    0x04, 0x00, 0x02, 0x14, 0x02, 0x12, 0x04, 0x82, 0x02, 0x32, 0x34, 0x0a, 0x65, 0x0a, 0x08, 0x04,
    0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x15, 0x12, 0x04, 0x86, 0x02, 0x18, 0x33, 0x1a, 0x53, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69,
    0x73, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74,
    0x65, 0x64, 0x2e, 0x20, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x20, 0x61, 0x73, 0x20, 0x74,
    0x6f, 0x20, 0x77, 0x68, 0x79, 0x20, 0x61, 0x72, 0x65, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
    0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02, 0x15, 0x01, 0x12,
    0x04, 0x86, 0x02, 0x18, 0x2d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x02, 0x04, 0x00, 0x02,
    0x15, 0x02, 0x12, 0x04, 0x86, 0x02, 0x30, 0x32, 0x0a, 0x2a, 0x0a, 0x04, 0x04, 0x02, 0x03, 0x03,
    0x12, 0x06, 0x8c, 0x02, 0x08, 0xb4, 0x02, 0x09, 0x1a, 0x1a, 0x6b, 0x65, 0x79, 0x2f, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x20, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x03, 0x03, 0x01, 0x12, 0x04, 0x8c,
    0x02, 0x10, 0x18, 0x0a, 0xa3, 0x01, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x03, 0x02, 0x00, 0x12, 0x04,
    0x92, 0x02, 0x10, 0x2e, 0x1a, 0x92, 0x01, 0x20, 0x4f, 0x6e, 0x20, 0x61, 0x20, 0x70, 0x75, 0x74,
    0x20, 0x6f, 0x72, 0x20, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x78, 0x74, 0x20, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61,
    0x74, 0x61, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73,
    0x20, 0x6f, 0x70, 0x61, 0x71, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x2e, 0x20, 0x28, 0x53, 0x65, 0x65, 0x20, 0x41, 0x74, 0x6f,
    0x6d, 0x69, 0x63, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x64,
    0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x29, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0x92, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x03, 0x02, 0x00, 0x05, 0x12, 0x04, 0x92, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0x92, 0x02, 0x1f, 0x29, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x03, 0x02, 0x00, 0x03, 0x12, 0x04, 0x92, 0x02, 0x2c, 0x2d, 0x0a, 0x7b, 0x0a,
    0x06, 0x04, 0x02, 0x03, 0x03, 0x02, 0x01, 0x12, 0x04, 0x95, 0x02, 0x10, 0x28, 0x1a, 0x6b, 0x20,
    0x4f, 0x6e, 0x20, 0x61, 0x20, 0x70, 0x75, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x64, 0x65, 0x6c, 0x65,
    0x74, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x67, 0x6e,
    0x6f, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67,
    0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x65, 0x78, 0x69, 0x73,
    0x74, 0x69, 0x6e, 0x67, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x28, 0x69, 0x66, 0x20, 0x69, 0x74,
    0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73, 0x29, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x03, 0x02, 0x01, 0x04, 0x12, 0x04, 0x95, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x03, 0x02, 0x01, 0x05, 0x12, 0x04, 0x95, 0x02, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x03, 0x02, 0x01, 0x01, 0x12, 0x04, 0x95, 0x02, 0x1e, 0x23, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x01, 0x03, 0x12, 0x04, 0x95, 0x02, 0x26, 0x27, 0x0a, 0x1a,
    0x0a, 0x06, 0x04, 0x02, 0x03, 0x03, 0x02, 0x02, 0x12, 0x04, 0x98, 0x02, 0x10, 0x27, 0x1a, 0x0a,
    0x65, 0x6e, 0x74, 0x72, 0x79, 0x20, 0x6b, 0x65, 0x79, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x03, 0x02, 0x02, 0x04, 0x12, 0x04, 0x98, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x03, 0x02, 0x02, 0x05, 0x12, 0x04, 0x98, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0x98, 0x02, 0x1f, 0x22, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x02, 0x03, 0x12, 0x04, 0x98, 0x02, 0x25, 0x26, 0x0a, 0x27,
    0x0a, 0x06, 0x04, 0x02, 0x03, 0x03, 0x02, 0x03, 0x12, 0x04, 0x9b, 0x02, 0x10, 0x2d, 0x1a, 0x17,
    0x65, 0x6e, 0x74, 0x72, 0x79, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e,
    0x20, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02,
    0x03, 0x04, 0x12, 0x04, 0x9b, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03,
    0x02, 0x03, 0x05, 0x12, 0x04, 0x9b, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x03, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9b, 0x02, 0x1f, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x03, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9b, 0x02, 0x2b, 0x2c, 0x0a, 0x81, 0x01, 0x0a, 0x06,
    0x04, 0x02, 0x03, 0x03, 0x02, 0x04, 0x12, 0x04, 0x9f, 0x02, 0x10, 0x27, 0x1a, 0x71, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x67,
    0x72, 0x69, 0x74, 0x79, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x61, 0x79,
    0x20, 0x6f, 0x72, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x69,
    0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x65, 0x61, 0x72, 0x2c, 0x20, 0x64, 0x65, 0x70,
    0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6c,
    0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x0a, 0x20, 0x75, 0x73, 0x65, 0x64, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x04, 0x04, 0x12, 0x04, 0x9f, 0x02, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x04, 0x05, 0x12, 0x04, 0x9f, 0x02, 0x19,
    0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x04, 0x01, 0x12, 0x04, 0x9f, 0x02,
    0x1f, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x04, 0x03, 0x12, 0x04, 0x9f,
    0x02, 0x25, 0x26, 0x0a, 0xf2, 0x02, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x03, 0x02, 0x05, 0x12, 0x04,
    0xa5, 0x02, 0x10, 0x31, 0x1a, 0xe1, 0x02, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x6c,
    0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x64, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x6f, 0x72,
    0x20, 0x43, 0x52, 0x43, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62,
    0x65, 0x20, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x20, 0x69, 0x73, 0x20,
    0x6e, 0x6f, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x20, 0x75,
    0x6e, 0x6b, 0x65, 0x79, 0x65, 0x64, 0x20, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d,
    0x0a, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x20, 0x61, 0x20, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
    0x76, 0x65, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65,
    0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65,
    0x20, 0x68, 0x61, 0x73, 0x20, 0x6e, 0x6f, 0x20, 0x69, 0x64, 0x65, 0x61, 0x20, 0x77, 0x68, 0x61,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x69, 0x73, 0x2e, 0x20, 0x53, 0x65,
    0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x63, 0x75, 0x73, 0x73, 0x69, 0x6f, 0x6e,
    0x20, 0x6f, 0x66, 0x0a, 0x20, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x20, 0x6b,
    0x65, 0x79, 0x2f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x28,
    0x53, 0x65, 0x65, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x20, 0x64, 0x6f, 0x63,
    0x75, 0x6d, 0x65, 0x6e, 0x74, 0x29, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03,
    0x02, 0x05, 0x04, 0x12, 0x04, 0xa5, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x03, 0x02, 0x05, 0x06, 0x12, 0x04, 0xa5, 0x02, 0x19, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x03, 0x02, 0x05, 0x01, 0x12, 0x04, 0xa5, 0x02, 0x23, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x03, 0x02, 0x05, 0x03, 0x12, 0x04, 0xa5, 0x02, 0x2f, 0x30, 0x0a, 0xde, 0x02, 0x0a,
    0x06, 0x04, 0x02, 0x03, 0x03, 0x02, 0x06, 0x12, 0x04, 0xab, 0x02, 0x10, 0x2f, 0x1a, 0xcd, 0x02,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x67, 0x65, 0x74, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x6f,
    0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x20, 0x66,
    0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x74,
    0x73, 0x65, 0x6c, 0x66, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x76, 0x61,
    0x6c, 0x75, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x67, 0x65, 0x74, 0x74, 0x69,
    0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x72, 0x69, 0x74, 0x79,
    0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65,
    0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x61, 0x6c,
    0x73, 0x6f, 0x0a, 0x20, 0x68, 0x61, 0x76, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x65,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20,
    0x61, 0x73, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x6c, 0x73,
    0x65, 0x2e, 0x20, 0x46, 0x6f, 0x72, 0x0a, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6f, 0x72,
    0x20, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x73, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x73,
    0x65, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20,
    0x69, 0x73, 0x20, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x06, 0x04, 0x12, 0x04, 0xab, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x06, 0x05, 0x12, 0x04, 0xab, 0x02, 0x19, 0x1d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x06, 0x01, 0x12, 0x04, 0xab, 0x02, 0x1e, 0x2a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x12, 0x04, 0xab, 0x02, 0x2d,
    0x2e, 0x0a, 0xed, 0x04, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x03, 0x02, 0x07, 0x12, 0x04, 0xb3, 0x02,
    0x10, 0x3d, 0x1a, 0xdc, 0x04, 0x20, 0x53, 0x79, 0x6e, 0x63, 0x68, 0x72, 0x6f, 0x6e, 0x69, 0x7a,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x70, 0x75, 0x74, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65,
    0x73, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20, 0x69,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65,
    0x0a, 0x20, 0x57, 0x52, 0x49, 0x54, 0x45, 0x54, 0x48, 0x52, 0x4f, 0x55, 0x47, 0x48, 0x3a, 0x20,
    0x54, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20,
    0x6d, 0x61, 0x64, 0x65, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20,
    0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x69, 0x6e, 0x67,
    0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72,
    0x20, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x20, 0x57, 0x52, 0x49, 0x54, 0x45, 0x42, 0x41, 0x43, 0x4b, 0x3a,
    0x20, 0x54, 0x68, 0x65, 0x79, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x6d, 0x61, 0x64,
    0x65, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x77, 0x68, 0x65,
    0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x63, 0x68, 0x6f,
    0x6f, 0x73, 0x65, 0x73, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x20,
    0x73, 0x75, 0x62, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x74, 0x20, 0x46, 0x4c, 0x55, 0x53, 0x48,
    0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x0a, 0x20, 0x46, 0x4c, 0x55, 0x53, 0x48, 0x3a, 0x20,
    0x41, 0x6c, 0x6c, 0x20, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x6e, 0x66, 0x6f,
    0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x68, 0x61, 0x73,
    0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65,
    0x6e, 0x20, 0x69, 0x73, 0x20, 0x70, 0x75, 0x73, 0x68, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20, 0x20, 0x20,
    0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x46, 0x4c, 0x55, 0x53, 0x48,
    0x20, 0x69, 0x73, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x6c, 0x61, 0x73, 0x74,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e,
    0x65, 0x64, 0x2e, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x57, 0x52, 0x49, 0x54, 0x45, 0x42, 0x41, 0x43,
    0x4b, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x68, 0x61,
    0x76, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x65, 0x6e, 0x64, 0x69,
    0x6e, 0x67, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x77, 0x69,
    0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x62,
    0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x4c, 0x55, 0x53, 0x48, 0x20,
    0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x74,
    0x75, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x07, 0x04, 0x12, 0x04, 0xb3, 0x02,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x07, 0x06, 0x12, 0x04, 0xb3,
    0x02, 0x19, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x07, 0x01, 0x12, 0x04,
    0xb3, 0x02, 0x29, 0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x03, 0x02, 0x07, 0x03, 0x12,
    0x04, 0xb3, 0x02, 0x3b, 0x3c, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x02, 0x04, 0x00, 0x12, 0x06, 0xb6,
    0x02, 0x08, 0xbb, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x04, 0x00, 0x01, 0x12, 0x04,
    0xb6, 0x02, 0x0d, 0x1c, 0x0a, 0x38, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04,
    0xb7, 0x02, 0x10, 0x2d, 0x22, 0x28, 0x20, 0x4d, 0x75, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x65,
    0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x2c, 0x20, 0x73, 0x6f, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75,
    0x6c, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x02, 0x10, 0x27, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xb7, 0x02, 0x2a, 0x2c,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xb8, 0x02, 0x10, 0x21,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb8, 0x02, 0x10,
    0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xb8, 0x02,
    0x1f, 0x20, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xb9, 0x02,
    0x10, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb9,
    0x02, 0x10, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04,
    0xb9, 0x02, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x00, 0x02, 0x03, 0x12, 0x04,
    0xba, 0x02, 0x10, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xba, 0x02, 0x10, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x00, 0x02, 0x03, 0x02,
    0x12, 0x04, 0xba, 0x02, 0x18, 0x19, 0x0a, 0x1d, 0x0a, 0x04, 0x04, 0x02, 0x03, 0x04, 0x12, 0x06,
    0xbe, 0x02, 0x08, 0xd1, 0x02, 0x09, 0x1a, 0x0d, 0x6b, 0x65, 0x79, 0x20, 0x72, 0x61, 0x6e, 0x67,
    0x65, 0x20, 0x6f, 0x70, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x03, 0x04, 0x01, 0x12, 0x04,
    0xbe, 0x02, 0x10, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x04, 0x02, 0x00, 0x12, 0x04,
    0xbf, 0x02, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xbf, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xbf, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xbf, 0x02, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xbf, 0x02, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x04,
    0x02, 0x01, 0x12, 0x04, 0xc0, 0x02, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xc0, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x04, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc0, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc0, 0x02, 0x1f, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x04, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc0, 0x02, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x02, 0x03, 0x04, 0x02, 0x02, 0x12, 0x04, 0xc1, 0x02, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x04, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc1, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc1, 0x02, 0x19, 0x1d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc1, 0x02, 0x1e, 0x2f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc1, 0x02, 0x32, 0x33,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x04, 0x02, 0x03, 0x12, 0x04, 0xc2, 0x02, 0x10, 0x32,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc2, 0x02, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc2, 0x02,
    0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc2,
    0x02, 0x1e, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xc2, 0x02, 0x30, 0x31, 0x0a, 0x35, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x04, 0x02, 0x04, 0x12, 0x04,
    0xc5, 0x02, 0x10, 0x2f, 0x1a, 0x25, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x78, 0x69, 0x6d,
    0x75, 0x6d, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x6b, 0x65, 0x79,
    0x73, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x04, 0x02, 0x04, 0x04, 0x12, 0x04, 0xc5, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x04, 0x02, 0x04, 0x05, 0x12, 0x04, 0xc5, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc5, 0x02, 0x1f, 0x2a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc5, 0x02, 0x2d, 0x2e, 0x0a,
    0xfc, 0x01, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x04, 0x02, 0x05, 0x12, 0x04, 0xcb, 0x02, 0x10, 0x2a,
    0x1a, 0xeb, 0x01, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x73, 0x20, 0x61, 0x72, 0x65,
    0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x20,
    0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x2e, 0x20, 0x46,
    0x6f, 0x72, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x0a, 0x20, 0x69, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x73, 0x74,
    0x61, 0x72, 0x74, 0x4b, 0x65, 0x79, 0x3d, 0x22, 0x6a, 0x22, 0x2c, 0x20, 0x65, 0x6e, 0x64, 0x4b,
    0x65, 0x79, 0x3d, 0x22, 0x6b, 0x22, 0x2c, 0x20, 0x6d, 0x61, 0x78, 0x52, 0x65, 0x74, 0x75, 0x72,
    0x6e, 0x65, 0x64, 0x3d, 0x32, 0x2c, 0x0a, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x3d,
    0x74, 0x72, 0x75, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6b, 0x65, 0x79,
    0x73, 0x20, 0x22, 0x6b, 0x30, 0x22, 0x2c, 0x20, 0x22, 0x6b, 0x31, 0x22, 0x2c, 0x20, 0x22, 0x6b,
    0x32, 0x22, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x79,
    0x73, 0x74, 0x65, 0x6d, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e,
    0x20, 0x22, 0x6b, 0x32, 0x22, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22, 0x6b, 0x31, 0x22, 0x20, 0x69,
    0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x05, 0x04, 0x12, 0x04, 0xcb, 0x02, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x05, 0x05, 0x12, 0x04, 0xcb, 0x02, 0x19, 0x1d,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x05, 0x01, 0x12, 0x04, 0xcb, 0x02, 0x1e,
    0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x04, 0x02, 0x05, 0x03, 0x12, 0x04, 0xcb, 0x02,
    0x28, 0x29, 0x0a, 0x25, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x04, 0x02, 0x06, 0x12, 0x04, 0xd0, 0x02,
    0x10, 0x28, 0x1a, 0x15, 0x67, 0x65, 0x74, 0x20, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x72, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x20, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x04, 0x02, 0x06, 0x04, 0x12, 0x04, 0xd0, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x04, 0x02, 0x06, 0x05, 0x12, 0x04, 0xd0, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x04, 0x02, 0x06, 0x01, 0x12, 0x04, 0xd0, 0x02, 0x1f, 0x23, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x04, 0x02, 0x06, 0x03, 0x12, 0x04, 0xd0, 0x02, 0x26, 0x27, 0x0a, 0xc7, 0x01,
    0x0a, 0x04, 0x04, 0x02, 0x03, 0x05, 0x12, 0x06, 0xd8, 0x02, 0x08, 0xe5, 0x02, 0x09, 0x1a, 0xb6,
    0x01, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x69, 0x65,
    0x6c, 0x64, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64,
    0x2c, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a,
    0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69,
    0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x64, 0x20,
    0x61, 0x63, 0x72, 0x6f, 0x73, 0x73, 0x20, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x20, 0x66, 0x61, 0x69,
    0x6c, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x65, 0x72, 0x61, 0x73, 0x65, 0x64, 0x20, 0x6f, 0x6e,
    0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x50, 0x49, 0x4e, 0x20, 0x65, 0x72, 0x61, 0x73,
    0x65, 0x20, 0x6f, 0x72, 0x20, 0x50, 0x49, 0x4e, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x20,
    0x65, 0x72, 0x61, 0x73, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x03, 0x05, 0x01,
    0x12, 0x04, 0xd8, 0x02, 0x10, 0x15, 0x0a, 0xb9, 0x01, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x05, 0x02,
    0x00, 0x12, 0x04, 0xdd, 0x02, 0x10, 0x35, 0x1a, 0xa8, 0x01, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63,
    0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74,
    0x6f, 0x20, 0x62, 0x65, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x65, 0x76,
    0x65, 0x72, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x73, 0x20, 0x30, 0x2e, 0x0a, 0x20, 0x49, 0x66,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67,
    0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x65, 0x64, 0x20,
    0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x75, 0x6e, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x3b,
    0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73,
    0x74, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x62, 0x6f, 0x6f,
    0x74, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65,
    0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdd,
    0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x05, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xdd, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x05, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xdd, 0x02, 0x1f, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x05, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xdd, 0x02, 0x33, 0x34, 0x0a, 0xb1, 0x01, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x05, 0x02,
    0x01, 0x12, 0x04, 0xe4, 0x02, 0x10, 0x33, 0x1a, 0xa0, 0x01, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63,
    0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x63,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20,
    0x6c, 0x6f, 0x61, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61,
    0x20, 0x70, 0x6f, 0x72, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x0a, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66,
    0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x69, 0x74, 0x73, 0x65, 0x6c,
    0x66, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x69,
    0x74, 0x73, 0x20, 0x6f, 0x77, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x67,
    0x72, 0x69, 0x74, 0x79, 0x2c, 0x0a, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
    0x69, 0x74, 0x79, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x05, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe4, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x05, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe4, 0x02, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x05, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe4, 0x02, 0x1e, 0x2e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x05, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe4, 0x02, 0x31, 0x32, 0x0a, 0x99,
    0x01, 0x0a, 0x04, 0x04, 0x02, 0x03, 0x06, 0x12, 0x06, 0xe9, 0x02, 0x08, 0x91, 0x03, 0x09, 0x1a,
    0x88, 0x01, 0x20, 0x50, 0x32, 0x50, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x73, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20,
    0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65,
    0x6e, 0x64, 0x20, 0x6b, 0x65, 0x79, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72,
    0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2e, 0x0a, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20,
    0x69, 0x73, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x6e,
    0x64, 0x61, 0x6c, 0x6f, 0x6e, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20, 0x6f,
    0x72, 0x20, 0x61, 0x64, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x70, 0x75, 0x74,
    0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02,
    0x03, 0x06, 0x01, 0x12, 0x04, 0xe9, 0x02, 0x10, 0x1c, 0x0a, 0x2d, 0x0a, 0x06, 0x04, 0x02, 0x03,
    0x06, 0x02, 0x00, 0x12, 0x04, 0xec, 0x02, 0x10, 0x27, 0x1a, 0x1d, 0x20, 0x44, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20,
    0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xec, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x06, 0x02, 0x00, 0x06, 0x12, 0x04, 0xec, 0x02, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x06, 0x02, 0x00, 0x01, 0x12, 0x04, 0xec, 0x02, 0x1e, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x06, 0x02, 0x00, 0x03, 0x12, 0x04, 0xec, 0x02, 0x25, 0x26, 0x0a, 0x35, 0x0a, 0x06,
    0x04, 0x02, 0x03, 0x06, 0x02, 0x01, 0x12, 0x04, 0xee, 0x02, 0x10, 0x31, 0x1a, 0x25, 0x20, 0x4c,
    0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x73, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x65,
    0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xee, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x02, 0x01, 0x06, 0x12,
    0x04, 0xee, 0x02, 0x19, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xee, 0x02, 0x23, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xee, 0x02, 0x2f, 0x30, 0x0a, 0xd7, 0x01, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x06,
    0x02, 0x02, 0x12, 0x04, 0xf4, 0x02, 0x10, 0x3e, 0x1a, 0xc6, 0x01, 0x20, 0x49, 0x6e, 0x64, 0x69,
    0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x61, 0x6c,
    0x6c, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x68, 0x61, 0x76,
    0x65, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x53, 0x55, 0x43, 0x43, 0x45, 0x53, 0x53,
    0x0a, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x20, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x74, 0x72, 0x61,
    0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x73, 0x20, 0x74, 0x6f, 0x20,
    0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0a, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20,
    0x63, 0x61, 0x73, 0x65, 0x73, 0x2e, 0x0a, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x72, 0x75,
    0x65, 0x2c, 0x20, 0x6e, 0x6f, 0x20, 0x66, 0x75, 0x72, 0x74, 0x68, 0x65, 0x72, 0x20, 0x65, 0x72,
    0x72, 0x6f, 0x72, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x68, 0x6f,
    0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf4, 0x02,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf4,
    0x02, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xf4, 0x02, 0x1e, 0x39, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xf4, 0x02, 0x3c, 0x3d, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x12,
    0x06, 0xf5, 0x02, 0x10, 0x89, 0x03, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x03,
    0x00, 0x01, 0x12, 0x04, 0xf5, 0x02, 0x18, 0x21, 0x0a, 0x30, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x06,
    0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfa, 0x02, 0x18, 0x2f, 0x1a, 0x1e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x6b, 0x65, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x74, 0x72,
    0x79, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x6f, 0x76, 0x65, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x06, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfa, 0x02, 0x18, 0x20, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xfa, 0x02, 0x21, 0x26,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfa,
    0x02, 0x27, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xfa, 0x02, 0x2d, 0x2e, 0x0a, 0x81, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x06, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xfd, 0x02, 0x18, 0x33, 0x1a, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f,
    0x74, 0x68, 0x65, 0x72, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x0a, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72,
    0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x6f, 0x72,
    0x65, 0x64, 0x20, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x06, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xfd, 0x02, 0x18, 0x20, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xfd, 0x02, 0x21, 0x26,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfd,
    0x02, 0x27, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xfd, 0x02, 0x31, 0x32, 0x0a, 0x4a, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00,
    0x02, 0x02, 0x12, 0x04, 0xff, 0x02, 0x18, 0x32, 0x1a, 0x38, 0x20, 0x74, 0x6f, 0x20, 0x68, 0x61,
    0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x6b, 0x65, 0x79,
    0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x61, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e,
    0x74, 0x20, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xff, 0x02, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xff, 0x02, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06,
    0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xff, 0x02, 0x27, 0x2d, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xff, 0x02, 0x30, 0x31, 0x0a, 0x45,
    0x0a, 0x08, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0x81, 0x03, 0x18, 0x30,
    0x1a, 0x33, 0x20, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x72, 0x69,
    0x74, 0x65, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x76, 0x65, 0x72, 0x73,
    0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02,
    0x03, 0x04, 0x12, 0x04, 0x81, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06,
    0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0x81, 0x03, 0x21, 0x25, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x81, 0x03, 0x26, 0x2b, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0x81, 0x03, 0x2e,
    0x2f, 0x0a, 0x23, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0x83,
    0x03, 0x18, 0x33, 0x1a, 0x11, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x73,
    0x74, 0x61, 0x74, 0x75, 0x73, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00,
    0x02, 0x04, 0x04, 0x12, 0x04, 0x83, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x06, 0x03, 0x00, 0x02, 0x04, 0x06, 0x12, 0x04, 0x83, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0x83, 0x03, 0x28, 0x2e, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0x83, 0x03,
    0x31, 0x32, 0x0a, 0xb3, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x05, 0x12,
    0x04, 0x88, 0x03, 0x18, 0x38, 0x1a, 0xa0, 0x01, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x70, 0x65, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x64, 0x64, 0x20, 0x74, 0x6f, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x75, 0x74, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x2e, 0x20, 0x54, 0x48, 0x69, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x0a, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f,
    0x66, 0x20, 0x61, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x20, 0x63, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x20, 0x2d, 0x3e, 0x20, 0x41, 0x20, 0x2d, 0x3e, 0x42, 0x20, 0x2d, 0x3e, 0x43,
    0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x69,
    0x6e, 0x67, 0x0a, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06,
    0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0x88, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x05, 0x06, 0x12, 0x04, 0x88, 0x03, 0x21, 0x2d, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0x88, 0x03, 0x2e,
    0x33, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04,
    0x88, 0x03, 0x36, 0x37, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x12, 0x06,
    0x8b, 0x03, 0x10, 0x8f, 0x03, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01,
    0x01, 0x12, 0x04, 0x8b, 0x03, 0x18, 0x1c, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x06, 0x03,
    0x01, 0x02, 0x00, 0x12, 0x04, 0x8c, 0x03, 0x18, 0x35, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x06, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8c, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8c, 0x03, 0x21, 0x27, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8c, 0x03,
    0x28, 0x30, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x8c, 0x03, 0x33, 0x34, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02,
    0x01, 0x12, 0x04, 0x8d, 0x03, 0x18, 0x30, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03,
    0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8d, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x06, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8d, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8d, 0x03, 0x27, 0x2b,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8d,
    0x03, 0x2e, 0x2f, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02, 0x02, 0x12,
    0x04, 0x8e, 0x03, 0x18, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02,
    0x02, 0x04, 0x12, 0x04, 0x8e, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x06,
    0x03, 0x01, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8e, 0x03, 0x21, 0x25, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x06, 0x03, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8e, 0x03, 0x26, 0x29, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x06, 0x03, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8e, 0x03, 0x2c,
    0x2d, 0x0a, 0x18, 0x0a, 0x04, 0x04, 0x02, 0x03, 0x07, 0x12, 0x06, 0x94, 0x03, 0x08, 0xa0, 0x04,
    0x09, 0x1a, 0x08, 0x67, 0x65, 0x74, 0x20, 0x6c, 0x6f, 0x67, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x02, 0x03, 0x07, 0x01, 0x12, 0x04, 0x94, 0x03, 0x10, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02,
    0x03, 0x07, 0x02, 0x00, 0x12, 0x04, 0x95, 0x03, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x07, 0x02, 0x00, 0x04, 0x12, 0x04, 0x95, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x07, 0x02, 0x00, 0x06, 0x12, 0x04, 0x95, 0x03, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x07, 0x02, 0x00, 0x01, 0x12, 0x04, 0x95, 0x03, 0x1e, 0x23, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x00, 0x03, 0x12, 0x04, 0x95, 0x03, 0x26, 0x27, 0x0a, 0x10,
    0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x12, 0x06, 0x96, 0x03, 0x10, 0xa0, 0x03, 0x11,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x01, 0x12, 0x04, 0x96, 0x03, 0x15,
    0x19, 0x0a, 0x3a, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0x97,
    0x03, 0x18, 0x2a, 0x22, 0x28, 0x20, 0x4d, 0x75, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x65, 0x20,
    0x66, 0x69, 0x72, 0x73, 0x74, 0x2c, 0x20, 0x73, 0x6f, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
    0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x0a, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x97, 0x03, 0x18, 0x24,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0x97,
    0x03, 0x27, 0x29, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x01, 0x12,
    0x04, 0x98, 0x03, 0x18, 0x29, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0x98, 0x03, 0x18, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0x98, 0x03, 0x27, 0x28, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0x99, 0x03, 0x18, 0x29, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x99, 0x03, 0x18, 0x24,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0x99,
    0x03, 0x27, 0x28, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x03, 0x12,
    0x04, 0x9a, 0x03, 0x18, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02,
    0x03, 0x01, 0x12, 0x04, 0x9a, 0x03, 0x18, 0x22, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x04, 0x9a, 0x03, 0x25, 0x26, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x04, 0x12, 0x04, 0x9b, 0x03, 0x18, 0x2a, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0x9b, 0x03, 0x18, 0x25,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x04, 0x02, 0x12, 0x04, 0x9b,
    0x03, 0x28, 0x29, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x05, 0x12,
    0x04, 0x9c, 0x03, 0x18, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02,
    0x05, 0x01, 0x12, 0x04, 0x9c, 0x03, 0x18, 0x22, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x04, 0x00, 0x02, 0x05, 0x02, 0x12, 0x04, 0x9c, 0x03, 0x25, 0x26, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x06, 0x12, 0x04, 0x9d, 0x03, 0x18, 0x25, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0x9d, 0x03, 0x18, 0x20,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x06, 0x02, 0x12, 0x04, 0x9d,
    0x03, 0x23, 0x24, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x07, 0x12,
    0x04, 0x9e, 0x03, 0x18, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02,
    0x07, 0x01, 0x12, 0x04, 0x9e, 0x03, 0x18, 0x1e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x04, 0x00, 0x02, 0x07, 0x02, 0x12, 0x04, 0x9e, 0x03, 0x21, 0x22, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x08, 0x12, 0x04, 0x9f, 0x03, 0x18, 0x23, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x08, 0x01, 0x12, 0x04, 0x9f, 0x03, 0x18, 0x1e,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x04, 0x00, 0x02, 0x08, 0x02, 0x12, 0x04, 0x9f,
    0x03, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x02, 0x01, 0x12, 0x04, 0xa2,
    0x03, 0x10, 0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xa2, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x01, 0x06, 0x12,
    0x04, 0xa2, 0x03, 0x19, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xa2, 0x03, 0x25, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xa2, 0x03, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x02,
    0x02, 0x12, 0x04, 0xa3, 0x03, 0x10, 0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xa3, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07,
    0x02, 0x02, 0x06, 0x12, 0x04, 0xa3, 0x03, 0x19, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x07, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x25, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x07, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa3, 0x03, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x02, 0x03, 0x07, 0x02, 0x03, 0x12, 0x04, 0xa4, 0x03, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x07, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa4, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x07, 0x02, 0x03, 0x06, 0x12, 0x04, 0xa4, 0x03, 0x19, 0x21, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa4, 0x03, 0x22, 0x2a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa4, 0x03, 0x2d, 0x2e, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x02, 0x04, 0x12, 0x04, 0xa5, 0x03, 0x10, 0x39, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x04, 0x04, 0x12, 0x04, 0xa5, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x04, 0x06, 0x12, 0x04, 0xa5, 0x03, 0x19,
    0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa5, 0x03,
    0x27, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x04, 0x03, 0x12, 0x04, 0xa5,
    0x03, 0x37, 0x38, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x02, 0x05, 0x12, 0x04, 0xa6,
    0x03, 0x10, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xa6, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x05, 0x06, 0x12,
    0x04, 0xa6, 0x03, 0x19, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xa6, 0x03, 0x24, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x05,
    0x03, 0x12, 0x04, 0xa6, 0x03, 0x31, 0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x02,
    0x06, 0x12, 0x04, 0xa7, 0x03, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02,
    0x06, 0x04, 0x12, 0x04, 0xa7, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07,
    0x02, 0x06, 0x05, 0x12, 0x04, 0xa7, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x07, 0x02, 0x06, 0x01, 0x12, 0x04, 0xa7, 0x03, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x07, 0x02, 0x06, 0x03, 0x12, 0x04, 0xa7, 0x03, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x02, 0x03, 0x07, 0x02, 0x07, 0x12, 0x04, 0xa8, 0x03, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x07, 0x02, 0x07, 0x04, 0x12, 0x04, 0xa8, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x07, 0x02, 0x07, 0x06, 0x12, 0x04, 0xa8, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x07, 0x01, 0x12, 0x04, 0xa8, 0x03, 0x20, 0x26, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x07, 0x03, 0x12, 0x04, 0xa8, 0x03, 0x29, 0x2a, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x02, 0x08, 0x12, 0x04, 0xa9, 0x03, 0x10, 0x2b, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x08, 0x04, 0x12, 0x04, 0xa9, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x08, 0x06, 0x12, 0x04, 0xa9, 0x03, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x08, 0x01, 0x12, 0x04, 0xa9, 0x03,
    0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x02, 0x08, 0x03, 0x12, 0x04, 0xa9,
    0x03, 0x29, 0x2a, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x03, 0x00, 0x12, 0x06, 0xaa,
    0x03, 0x10, 0xb4, 0x03, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x03, 0x00, 0x01,
    0x12, 0x04, 0xaa, 0x03, 0x18, 0x23, 0x0a, 0x8b, 0x02, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xaf, 0x03, 0x18, 0x31, 0x1a, 0xf8, 0x01, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x74, 0x69,
    0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x72,
    0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x6e,
    0x61, 0x6d, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6e,
    0x64, 0x61, 0x72, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x72, 0x69, 0x65,
    0x74, 0x61, 0x72, 0x79, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64,
    0x61, 0x72, 0x64, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x22, 0x48,
    0x44, 0x41, 0x22, 0x2c, 0x20, 0x22, 0x45, 0x4e, 0x30, 0x22, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22,
    0x45, 0x4e, 0x31, 0x22, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x0a, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x72, 0x65,
    0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20,
    0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x6f, 0x72, 0x20, 0x75, 0x74, 0x69, 0x6c, 0x69, 0x7a,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20,
    0x61, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6e, 0x61,
    0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xaf, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xaf, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x03, 0x28, 0x2c, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaf, 0x03, 0x2f, 0x30,
    0x0a, 0x7e, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xb3, 0x03,
    0x18, 0x31, 0x1a, 0x6c, 0x20, 0x41, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x62, 0x65,
    0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x30, 0x2e, 0x30, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x31,
    0x2e, 0x30, 0x30, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x75, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6e, 0x75, 0x6d, 0x62,
    0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a,
    0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x20, 0x31, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x73,
    0x20, 0x31, 0x30, 0x30, 0x25, 0x20, 0x75, 0x74, 0x69, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x2e, 0x0a,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb3,
    0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x00, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xb3, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x00,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xb3, 0x03, 0x27, 0x2c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb3, 0x03, 0x2f, 0x30, 0x0a, 0x10, 0x0a, 0x06,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x12, 0x06, 0xb6, 0x03, 0x10, 0xc2, 0x03, 0x11, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x01, 0x12, 0x04, 0xb6, 0x03, 0x18, 0x23, 0x0a,
    0xf8, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xbb, 0x03,
    0x18, 0x31, 0x1a, 0xe5, 0x01, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72,
    0x65, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64,
    0x2e, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x63, 0x61,
    0x6e, 0x20, 0x62, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x72, 0x69, 0x65, 0x74, 0x61, 0x72, 0x79, 0x2e, 0x20, 0x54,
    0x68, 0x65, 0x0a, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x20, 0x6e, 0x61, 0x6d,
    0x65, 0x20, 0x69, 0x73, 0x20, 0x22, 0x48, 0x44, 0x41, 0x22, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x69, 0x74,
    0x65, 0x6d, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x0a, 0x20, 0x62, 0x65,
    0x69, 0x6e, 0x67, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x73, 0x75,
    0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x6f, 0x72, 0x20,
    0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x63, 0x61, 0x6e,
    0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x61, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
    0x69, 0x76, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbb, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbb, 0x03, 0x21, 0x27,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbb,
    0x03, 0x28, 0x2c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xbb, 0x03, 0x2f, 0x30, 0x0a, 0x38, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01,
    0x02, 0x01, 0x12, 0x04, 0xbe, 0x03, 0x18, 0x33, 0x1a, 0x26, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63,
    0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75,
    0x72, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x64, 0x65, 0x67, 0x72, 0x65, 0x65, 0x73, 0x20, 0x63, 0x0a,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbe,
    0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xbe, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xbe, 0x03, 0x27, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbe, 0x03, 0x31, 0x32, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0xbf, 0x03, 0x18, 0x33, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbf, 0x03, 0x18,
    0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x02, 0x05, 0x12, 0x04,
    0xbf, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xbf, 0x03, 0x27, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbf, 0x03, 0x31, 0x32, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x01, 0x02, 0x03, 0x12, 0x04, 0xc0, 0x03, 0x18, 0x33, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc0, 0x03, 0x18, 0x20, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc0, 0x03,
    0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xc0, 0x03, 0x27, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02,
    0x03, 0x03, 0x12, 0x04, 0xc0, 0x03, 0x31, 0x32, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x01, 0x02, 0x04, 0x12, 0x04, 0xc1, 0x03, 0x18, 0x32, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x01, 0x02, 0x04, 0x04, 0x12, 0x04, 0xc1, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x04, 0x05, 0x12, 0x04, 0xc1, 0x03, 0x21, 0x26,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc1,
    0x03, 0x27, 0x2d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x01, 0x02, 0x04, 0x03,
    0x12, 0x04, 0xc1, 0x03, 0x30, 0x31, 0x0a, 0x32, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x03, 0x02,
    0x12, 0x06, 0xc5, 0x03, 0x10, 0xc9, 0x03, 0x11, 0x1a, 0x20, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65,
    0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x69, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x69, 0x6e, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x02, 0x01, 0x12, 0x04, 0xc5, 0x03, 0x18, 0x20, 0x0a, 0x24, 0x0a, 0x08, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04, 0xc7, 0x03, 0x18, 0x43, 0x1a, 0x12, 0x20,
    0x31, 0x2d, 0x33, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64,
    0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xc7, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x02, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xc7, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc7, 0x03, 0x28, 0x3e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc7, 0x03, 0x41, 0x42, 0x0a, 0x10, 0x0a,
    0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc8, 0x03, 0x18, 0x37, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x02, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc8, 0x03,
    0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x02, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xc8, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x02, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xc8, 0x03, 0x27, 0x32, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x02, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc8, 0x03, 0x35, 0x36, 0x0a, 0x10, 0x0a, 0x06, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x12, 0x06, 0xcb, 0x03, 0x10, 0xf6, 0x03, 0x11, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x01, 0x12, 0x04, 0xcb, 0x03, 0x18, 0x25, 0x0a, 0x3b,
    0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0xce, 0x03, 0x18, 0x33,
    0x1a, 0x29, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76,
    0x65, 0x6e, 0x64, 0x6f, 0x72, 0x2e, 0x20, 0x53, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65,
    0x20, 0x22, 0x53, 0x65, 0x61, 0x67, 0x61, 0x74, 0x65, 0x22, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0xce, 0x03, 0x18, 0x20, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x00, 0x05, 0x12, 0x04, 0xce, 0x03, 0x21,
    0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xce, 0x03, 0x28, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xce, 0x03, 0x31, 0x32, 0x0a, 0x4c, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x03, 0x02, 0x01, 0x12, 0x04, 0xd2, 0x03, 0x18, 0x32, 0x1a, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76,
    0x69, 0x63, 0x65, 0x2e, 0x0a, 0x20, 0x22, 0x53, 0x69, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72,
    0x22, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x6d, 0x75, 0x6c, 0x61,
    0x74, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xd2, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x03, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd2, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd2, 0x03, 0x28, 0x2d, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd2, 0x03, 0x30,
    0x31, 0x0a, 0x2d, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x02, 0x12, 0x04, 0xd5,
    0x03, 0x18, 0x38, 0x1a, 0x1b, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x53, 0x65, 0x72,
    0x69, 0x61, 0x6c, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x28, 0x53, 0x4e, 0x29, 0x0a,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd5,
    0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xd5, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xd5, 0x03, 0x27, 0x33, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x03, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd5, 0x03, 0x36, 0x37, 0x0a, 0x30, 0x0a, 0x08,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x03, 0x12, 0x04, 0xd8, 0x03, 0x18, 0x3a, 0x1a, 0x1e,
    0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x20, 0x77, 0x69,
    0x64, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x28, 0x57, 0x57, 0x4e, 0x29, 0x0a, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd8, 0x03, 0x18,
    0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xd8, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xd8, 0x03, 0x27, 0x34, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x03, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd8, 0x03, 0x37, 0x39, 0x0a, 0x9e, 0x01, 0x0a, 0x08, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x04, 0x12, 0x04, 0xdc, 0x03, 0x18, 0x34, 0x1a, 0x8b, 0x01,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x6e,
    0x64, 0x6f, 0x72, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6f, 0x66, 0x74,
    0x77, 0x61, 0x72, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69,
    0x63, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x64, 0x6f, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x0a, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e,
    0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x65, 0x6e, 0x64, 0x73, 0x20, 0x77,
    0x69, 0x74, 0x68, 0x20, 0x22, 0x78, 0x22, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x74, 0x65, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x04, 0x04, 0x12, 0x04, 0xdc, 0x03, 0x18, 0x20, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x04, 0x05, 0x12, 0x04, 0xdc, 0x03, 0x21,
    0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xdc, 0x03, 0x28, 0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xdc, 0x03, 0x32, 0x33, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x03, 0x02, 0x05, 0x12, 0x04, 0xdd, 0x03, 0x18, 0x3d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x03, 0x02, 0x05, 0x04, 0x12, 0x04, 0xdd, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x05, 0x05, 0x12, 0x04, 0xdd, 0x03, 0x21, 0x27, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x05, 0x01, 0x12, 0x04, 0xdd, 0x03,
    0x28, 0x37, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x05, 0x03, 0x12,
    0x04, 0xdd, 0x03, 0x3a, 0x3c, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02,
    0x06, 0x12, 0x04, 0xde, 0x03, 0x18, 0x38, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x03, 0x02, 0x06, 0x04, 0x12, 0x04, 0xde, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x03, 0x02, 0x06, 0x05, 0x12, 0x04, 0xde, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x06, 0x01, 0x12, 0x04, 0xde, 0x03, 0x28, 0x32,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x06, 0x03, 0x12, 0x04, 0xde,
    0x03, 0x35, 0x37, 0x0a, 0xbf, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x07,
    0x12, 0x04, 0xe3, 0x03, 0x18, 0x3d, 0x1a, 0xac, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x28, 0x2e,
    0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x29, 0x20, 0x74, 0x68, 0x61, 0x74,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x75, 0x73, 0x65, 0x73,
    0x2e, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x68, 0x69, 0x67, 0x68, 0x65, 0x73, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x6c, 0x6f,
    0x77, 0x65, 0x73, 0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x69, 0x73, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x2c, 0x20,
    0x6a, 0x75, 0x73, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
    0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x61, 0x73, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x69,
    0x6c, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02,
    0x07, 0x04, 0x12, 0x04, 0xe3, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x03, 0x02, 0x07, 0x05, 0x12, 0x04, 0xe3, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x07, 0x01, 0x12, 0x04, 0xe3, 0x03, 0x28, 0x37, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x07, 0x03, 0x12, 0x04, 0xe3, 0x03, 0x3a,
    0x3c, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x08, 0x12, 0x04, 0xe4,
    0x03, 0x18, 0x45, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x08, 0x04,
    0x12, 0x04, 0xe4, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03,
    0x02, 0x08, 0x05, 0x12, 0x04, 0xe4, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x03, 0x02, 0x08, 0x01, 0x12, 0x04, 0xe4, 0x03, 0x28, 0x3f, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x08, 0x03, 0x12, 0x04, 0xe4, 0x03, 0x42, 0x44, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x09, 0x12, 0x04, 0xe5, 0x03, 0x18,
    0x40, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x09, 0x04, 0x12, 0x04,
    0xe5, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x09,
    0x05, 0x12, 0x04, 0xe5, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x03, 0x02, 0x09, 0x01, 0x12, 0x04, 0xe5, 0x03, 0x28, 0x3a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x03, 0x02, 0x09, 0x03, 0x12, 0x04, 0xe5, 0x03, 0x3d, 0x3f, 0x0a, 0x46, 0x0a,
    0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0a, 0x12, 0x04, 0xe8, 0x03, 0x18, 0x39, 0x1a,
    0x34, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65,
    0x2e, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x70, 0x65, 0x72, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66,
    0x61, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02,
    0x0a, 0x04, 0x12, 0x04, 0xe8, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x03, 0x02, 0x0a, 0x06, 0x12, 0x04, 0xe8, 0x03, 0x21, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xe8, 0x03, 0x2b, 0x34, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xe8, 0x03, 0x37,
    0x38, 0x0a, 0x3f, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0b, 0x12, 0x04, 0xeb,
    0x03, 0x18, 0x31, 0x1a, 0x2d, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72,
    0x65, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0b, 0x04, 0x12,
    0x04, 0xeb, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02,
    0x0b, 0x05, 0x12, 0x04, 0xeb, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x03, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xeb, 0x03, 0x27, 0x2b, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xeb, 0x03, 0x2e, 0x30, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0c, 0x12, 0x04, 0xec, 0x03, 0x18, 0x34,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xec,
    0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x02, 0x0c, 0x05,
    0x12, 0x04, 0xec, 0x03, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03,
    0x02, 0x0c, 0x01, 0x12, 0x04, 0xec, 0x03, 0x27, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x03, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xec, 0x03, 0x31, 0x33, 0x0a, 0x2a, 0x0a, 0x08,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x12, 0x06, 0xef, 0x03, 0x18, 0xf4, 0x03, 0x19,
    0x1a, 0x16, 0x20, 0x31, 0x38, 0x2c, 0x20, 0x31, 0x39, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x03, 0x03, 0x00, 0x01, 0x12, 0x04, 0xef, 0x03, 0x20, 0x29, 0x0a, 0x12, 0x0a, 0x0a, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xf0, 0x03, 0x20, 0x39, 0x0a,
    0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xf0, 0x03, 0x20, 0x28, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xf0, 0x03, 0x29, 0x2f, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf0, 0x03, 0x30, 0x34, 0x0a, 0x13,
    0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf0,
    0x03, 0x37, 0x38, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xf1, 0x03, 0x20, 0x37, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x03, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf1, 0x03, 0x20, 0x28, 0x0a, 0x13, 0x0a, 0x0b,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf1, 0x03, 0x29,
    0x2e, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xf1, 0x03, 0x2f, 0x32, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf1, 0x03, 0x35, 0x36, 0x0a, 0x12, 0x0a, 0x0a, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xf2, 0x03, 0x20, 0x3f, 0x0a,
    0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xf2, 0x03, 0x20, 0x28, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xf2, 0x03, 0x29, 0x2e, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf2, 0x03, 0x2f, 0x3a, 0x0a, 0x13,
    0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf2,
    0x03, 0x3d, 0x3e, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02,
    0x03, 0x12, 0x04, 0xf3, 0x03, 0x20, 0x3f, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x03, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf3, 0x03, 0x20, 0x28, 0x0a, 0x13, 0x0a, 0x0b,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xf3, 0x03, 0x29,
    0x2e, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03, 0x03, 0x00, 0x02, 0x03, 0x01,
    0x12, 0x04, 0xf3, 0x03, 0x2f, 0x3a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x07, 0x03, 0x03,
    0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf3, 0x03, 0x3d, 0x3e, 0x0a, 0x61, 0x0a, 0x06, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x04, 0x12, 0x06, 0xf9, 0x03, 0x10, 0x81, 0x04, 0x11, 0x1a, 0x4f, 0x20,
    0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x20, 0x73, 0x74,
    0x61, 0x72, 0x74, 0x20, 0x61, 0x74, 0x20, 0x30, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x73, 0x20,
    0x75, 0x70, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x77, 0x72, 0x61,
    0x70, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x73, 0x65, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x01, 0x12, 0x04, 0xf9, 0x03, 0x18, 0x22, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x00, 0x12, 0x04, 0xfa, 0x03, 0x18,
    0x3d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xfa, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x00,
    0x06, 0x12, 0x04, 0xfa, 0x03, 0x21, 0x2c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x04, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfa, 0x03, 0x2d, 0x38, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x04, 0x02, 0x00, 0x03, 0x12, 0x04, 0xfa, 0x03, 0x3b, 0x3c, 0x0a, 0x34, 0x0a,
    0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x01, 0x12, 0x04, 0xfc, 0x03, 0x18, 0x32, 0x1a,
    0x22, 0x20, 0x32, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x33, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2c, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x75,
    0x73, 0x65, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xfc, 0x03, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xfc, 0x03, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x04, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfc, 0x03, 0x28, 0x2d, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x01, 0x03, 0x12, 0x04, 0xfc, 0x03, 0x30, 0x31, 0x0a,
    0xc5, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x02, 0x12, 0x04, 0x80, 0x04,
    0x18, 0x32, 0x1a, 0xb2, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x75, 0x6d, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74,
    0x61, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x54,
    0x68, 0x69, 0x73, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x69, 0x6e, 0x63,
    0x6c, 0x75, 0x64, 0x65, 0x20, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
    0x20, 0x46, 0x6f, 0x72, 0x20, 0x50, 0x32, 0x50, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20,
    0x6d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x0a, 0x20, 0x64,
    0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x04, 0x02, 0x02, 0x04, 0x12, 0x04, 0x80, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x04, 0x02, 0x02, 0x05, 0x12, 0x04, 0x80, 0x04, 0x21, 0x27, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x02, 0x01, 0x12, 0x04, 0x80, 0x04, 0x28, 0x2d,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x04, 0x02, 0x02, 0x03, 0x12, 0x04, 0x80,
    0x04, 0x30, 0x31, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x12, 0x06, 0x83,
    0x04, 0x10, 0x8f, 0x04, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x01,
    0x12, 0x04, 0x83, 0x04, 0x18, 0x1e, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05,
    0x02, 0x00, 0x12, 0x04, 0x84, 0x04, 0x18, 0x37, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x05, 0x02, 0x00, 0x04, 0x12, 0x04, 0x84, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x00, 0x05, 0x12, 0x04, 0x84, 0x04, 0x21, 0x27, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x00, 0x01, 0x12, 0x04, 0x84, 0x04, 0x28,
    0x32, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x00, 0x03, 0x12, 0x04,
    0x84, 0x04, 0x35, 0x36, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x01,
    0x12, 0x04, 0x85, 0x04, 0x18, 0x39, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x85, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x05, 0x02, 0x01, 0x05, 0x12, 0x04, 0x85, 0x04, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x01, 0x01, 0x12, 0x04, 0x85, 0x04, 0x28, 0x34, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x01, 0x03, 0x12, 0x04, 0x85, 0x04,
    0x37, 0x38, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x02, 0x12, 0x04,
    0x86, 0x04, 0x18, 0x3b, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x86, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x05, 0x02, 0x02, 0x05, 0x12, 0x04, 0x86, 0x04, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x05, 0x02, 0x02, 0x01, 0x12, 0x04, 0x86, 0x04, 0x28, 0x36, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x02, 0x03, 0x12, 0x04, 0x86, 0x04, 0x39, 0x3a,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x03, 0x12, 0x04, 0x87, 0x04,
    0x18, 0x37, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x03, 0x04, 0x12,
    0x04, 0x87, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02,
    0x03, 0x05, 0x12, 0x04, 0x87, 0x04, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x05, 0x02, 0x03, 0x01, 0x12, 0x04, 0x87, 0x04, 0x28, 0x32, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x03, 0x03, 0x12, 0x04, 0x87, 0x04, 0x35, 0x36, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x04, 0x12, 0x04, 0x88, 0x04, 0x18, 0x3b,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x04, 0x04, 0x12, 0x04, 0x88,
    0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x04, 0x05,
    0x12, 0x04, 0x88, 0x04, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05,
    0x02, 0x04, 0x01, 0x12, 0x04, 0x88, 0x04, 0x28, 0x36, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x05, 0x02, 0x04, 0x03, 0x12, 0x04, 0x88, 0x04, 0x39, 0x3a, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x05, 0x12, 0x04, 0x89, 0x04, 0x18, 0x47, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x05, 0x04, 0x12, 0x04, 0x89, 0x04, 0x18,
    0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x05, 0x05, 0x12, 0x04,
    0x89, 0x04, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x05,
    0x01, 0x12, 0x04, 0x89, 0x04, 0x28, 0x42, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x05, 0x02, 0x05, 0x03, 0x12, 0x04, 0x89, 0x04, 0x45, 0x46, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x05, 0x02, 0x06, 0x12, 0x04, 0x8a, 0x04, 0x18, 0x48, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x06, 0x04, 0x12, 0x04, 0x8a, 0x04, 0x18, 0x20, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x06, 0x05, 0x12, 0x04, 0x8a, 0x04,
    0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x06, 0x01, 0x12,
    0x04, 0x8a, 0x04, 0x28, 0x43, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02,
    0x06, 0x03, 0x12, 0x04, 0x8a, 0x04, 0x46, 0x47, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x05, 0x02, 0x07, 0x12, 0x04, 0x8b, 0x04, 0x18, 0x3b, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x05, 0x02, 0x07, 0x04, 0x12, 0x04, 0x8b, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x07, 0x05, 0x12, 0x04, 0x8b, 0x04, 0x21, 0x27,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x07, 0x01, 0x12, 0x04, 0x8b,
    0x04, 0x28, 0x36, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x07, 0x03,
    0x12, 0x04, 0x8b, 0x04, 0x39, 0x3a, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05,
    0x02, 0x08, 0x12, 0x04, 0x8c, 0x04, 0x18, 0x3d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07,
    0x03, 0x05, 0x02, 0x08, 0x04, 0x12, 0x04, 0x8c, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x08, 0x05, 0x12, 0x04, 0x8c, 0x04, 0x21, 0x27, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x08, 0x01, 0x12, 0x04, 0x8c, 0x04, 0x28,
    0x38, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x08, 0x03, 0x12, 0x04,
    0x8c, 0x04, 0x3b, 0x3c, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x09,
    0x12, 0x04, 0x8d, 0x04, 0x18, 0x3e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05,
    0x02, 0x09, 0x04, 0x12, 0x04, 0x8d, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x05, 0x02, 0x09, 0x05, 0x12, 0x04, 0x8d, 0x04, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x09, 0x01, 0x12, 0x04, 0x8d, 0x04, 0x28, 0x38, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x09, 0x03, 0x12, 0x04, 0x8d, 0x04,
    0x3b, 0x3d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x0a, 0x12, 0x04,
    0x8e, 0x04, 0x18, 0x38, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x0a,
    0x04, 0x12, 0x04, 0x8e, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03,
    0x05, 0x02, 0x0a, 0x05, 0x12, 0x04, 0x8e, 0x04, 0x21, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x05, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x8e, 0x04, 0x28, 0x32, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x05, 0x02, 0x0a, 0x03, 0x12, 0x04, 0x8e, 0x04, 0x35, 0x37,
    0x0a, 0xf6, 0x03, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x07, 0x03, 0x06, 0x12, 0x06, 0x9c, 0x04, 0x10,
    0x9e, 0x04, 0x11, 0x1a, 0xe3, 0x03, 0x20, 0x54, 0x68, 0x65, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63,
    0x65, 0x20, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x67, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x20, 0x69, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x73, 0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64,
    0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x62, 0x61,
    0x63, 0x6b, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x6c, 0x6f, 0x67, 0x20, 0x6f, 0x66, 0x20, 0x61,
    0x20, 0x63, 0x65, 0x72, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x69, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x65,
    0x61, 0x63, 0x68, 0x0a, 0x20, 0x6c, 0x6f, 0x67, 0x20, 0x69, 0x73, 0x20, 0x31, 0x6d, 0x20, 0x62,
    0x79, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x50, 0x72, 0x6f, 0x70, 0x72, 0x69, 0x65, 0x74, 0x61,
    0x72, 0x79, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20,
    0x62, 0x65, 0x20, 0x70, 0x72, 0x65, 0x66, 0x61, 0x63, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x76, 0x65, 0x6e, 0x64, 0x6f, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x73,
    0x6f, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6c,
    0x6c, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x68,
    0x61, 0x70, 0x70, 0x65, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74,
    0x75, 0x72, 0x65, 0x2e, 0x20, 0x41, 0x6e, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20,
    0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x0a, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20,
    0xe2, 0x80, 0x9c, 0x63, 0x6f, 0x6d, 0x2e, 0x57, 0x44, 0xe2, 0x80, 0x9d, 0x20, 0x77, 0x6f, 0x75,
    0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x57, 0x65, 0x73, 0x74, 0x65, 0x72,
    0x6e, 0x20, 0x44, 0x69, 0x67, 0x69, 0x74, 0x61, 0x6c, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65,
    0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65,
    0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x2c, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x67, 0x65, 0x74, 0x20, 0x6c, 0x6f, 0x67, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
    0x6e, 0x73, 0x20, 0x4e, 0x4f, 0x54, 0x5f, 0x46, 0x4f, 0x55, 0x4e, 0x44, 0x2e, 0x0a, 0x0a, 0x20,
    0x54, 0x68, 0x65, 0x72, 0x65, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x6f, 0x6e, 0x6c,
    0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x69, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6c, 0x6f, 0x67, 0x73,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74,
    0x72, 0x69, 0x65, 0x76, 0x65, 0x64, 0x2e, 0x21, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x07, 0x03, 0x06, 0x01, 0x12, 0x04, 0x9c, 0x04, 0x18, 0x1e, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02,
    0x03, 0x07, 0x03, 0x06, 0x02, 0x00, 0x12, 0x04, 0x9d, 0x04, 0x18, 0x30, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x07, 0x03, 0x06, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9d, 0x04, 0x18, 0x20, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x06, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9d, 0x04,
    0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x06, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x9d, 0x04, 0x27, 0x2b, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x07, 0x03, 0x06, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x9d, 0x04, 0x2e, 0x2f, 0x0a, 0x87, 0x01, 0x0a, 0x04, 0x04, 0x02, 0x03,
    0x08, 0x12, 0x06, 0xa4, 0x04, 0x08, 0xd6, 0x04, 0x09, 0x1a, 0x77, 0x20, 0x54, 0x68, 0x65, 0x73,
    0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74,
    0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x72, 0x65, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x61, 0x63, 0x72, 0x6f, 0x73,
    0x73, 0x20, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x20, 0x61, 0x6e, 0x64,
    0x0a, 0x20, 0x65, 0x72, 0x61, 0x73, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x65, 0x69, 0x74, 0x68,
    0x65, 0x72, 0x20, 0x50, 0x49, 0x4e, 0x20, 0x65, 0x72, 0x61, 0x73, 0x65, 0x20, 0x6f, 0x72, 0x20,
    0x50, 0x49, 0x4e, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x20, 0x65, 0x72, 0x61, 0x73, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x03, 0x08, 0x01, 0x12, 0x04, 0xa4, 0x04, 0x10,
    0x18, 0x0a, 0x22, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x08, 0x02, 0x00, 0x12, 0x04, 0xa5, 0x04, 0x10,
    0x25, 0x22, 0x12, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x70, 0x65, 0x72, 0x20, 0x69, 0x64, 0x65, 0x6e,
    0x74, 0x69, 0x74, 0x79, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xa5, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x00,
    0x06, 0x12, 0x04, 0xa5, 0x04, 0x19, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xa5, 0x04, 0x1d, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xa5, 0x04, 0x23, 0x24, 0x0a, 0x2e, 0x0a, 0x06, 0x04, 0x02, 0x03,
    0x08, 0x02, 0x01, 0x12, 0x04, 0xa8, 0x04, 0x10, 0x2e, 0x1a, 0x1e, 0x20, 0x53, 0x65, 0x74, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x65, 0x72, 0x61,
    0x73, 0x65, 0x20, 0x70, 0x69, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03,
    0x08, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa8, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x03, 0x08, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa8, 0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x08, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa8, 0x04, 0x1f, 0x29, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x08, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa8, 0x04, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x02, 0x03, 0x08, 0x02, 0x02, 0x12, 0x04, 0xa9, 0x04, 0x10, 0x2e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa9, 0x04, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa9, 0x04, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa9, 0x04, 0x1f, 0x29,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa9, 0x04, 0x2c,
    0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x08, 0x02, 0x03, 0x12, 0x04, 0xaa, 0x04, 0x10,
    0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x03, 0x04, 0x12, 0x04, 0xaa, 0x04,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x03, 0x05, 0x12, 0x04, 0xaa,
    0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xaa, 0x04, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x03, 0x03, 0x12,
    0x04, 0xaa, 0x04, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x08, 0x02, 0x04, 0x12,
    0x04, 0xab, 0x04, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xab, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02, 0x04,
    0x05, 0x12, 0x04, 0xab, 0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xab, 0x04, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x08,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xab, 0x04, 0x2d, 0x2e, 0x0a, 0x13, 0x0a, 0x06, 0x04, 0x02, 0x03,
    0x08, 0x03, 0x00, 0x12, 0x06, 0xae, 0x04, 0x10, 0xd4, 0x04, 0x11, 0x1a, 0x01, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x01, 0x12, 0x04, 0xae, 0x04, 0x18, 0x1b, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xaf, 0x04, 0x18,
    0x34, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xaf, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xaf, 0x04, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x04, 0x27, 0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x08, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaf, 0x04, 0x32, 0x33, 0x0a, 0x20, 0x0a,
    0x08, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x04, 0x18, 0x2f, 0x22,
    0x0e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x48, 0x4d, 0x41, 0x43, 0x20, 0x6b, 0x65, 0x79, 0x0a, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb0, 0x04,
    0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xb0, 0x04, 0x21, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xb0, 0x04, 0x27, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb0, 0x04, 0x2d, 0x2e, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xb1, 0x04, 0x18, 0x41, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb1, 0x04, 0x18, 0x20,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb1,
    0x04, 0x21, 0x2e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xb1, 0x04, 0x2f, 0x3c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xb1, 0x04, 0x3f, 0x40, 0x0a, 0xcb, 0x01, 0x0a, 0x08, 0x04, 0x02,
    0x03, 0x08, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xb6, 0x04, 0x18, 0x31, 0x1a, 0xb8, 0x01, 0x20,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20,
    0x62, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2c, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x2c, 0x20, 0x72,
    0x61, 0x6e, 0x67, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x2e, 0x20, 0x49,
    0x66, 0x20, 0x6e, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69,
    0x66, 0x69, 0x65, 0x64, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x6e, 0x6f, 0x20, 0x63, 0x68,
    0x65, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x63, 0x63, 0x75, 0x72, 0x73, 0x2e, 0x20, 0x49,
    0x66, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2c, 0x20, 0x6f, 0x6e, 0x65, 0x20,
    0x6d, 0x75, 0x73, 0x74, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x0a, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65,
    0x6a, 0x65, 0x63, 0x74, 0x65, 0x64, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03,
    0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb6, 0x04, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x08, 0x03, 0x00, 0x02, 0x03, 0x06, 0x12, 0x04, 0xb6, 0x04, 0x21, 0x26, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb6, 0x04, 0x27, 0x2c,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb6,
    0x04, 0x2f, 0x30, 0x0a, 0x12, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x00, 0x12,
    0x06, 0xb7, 0x04, 0x18, 0xbb, 0x04, 0x19, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03,
    0x00, 0x04, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x04, 0x1d, 0x2a, 0x0a, 0x25, 0x0a, 0x0a, 0x04, 0x02,
    0x03, 0x08, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb8, 0x04, 0x20, 0x3c, 0x22, 0x11,
    0x20, 0x4d, 0x75, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74,
    0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xb8, 0x04, 0x20, 0x36, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00,
    0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xb8, 0x04, 0x39, 0x3b, 0x0a, 0x46, 0x0a, 0x0a, 0x04,
    0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xba, 0x04, 0x20, 0x2d, 0x1a,
    0x1b, 0x20, 0x30, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x3b,
    0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x75, 0x73, 0x65, 0x0a, 0x22, 0x15, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75,
    0x6c, 0x74, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xba, 0x04, 0x20, 0x28, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08,
    0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xba, 0x04, 0x2b, 0x2c, 0x0a, 0x12, 0x0a,
    0x08, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x12, 0x06, 0xbd, 0x04, 0x18, 0xc2, 0x04,
    0x19, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x01, 0x12, 0x04,
    0xbd, 0x04, 0x20, 0x25, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00,
    0x02, 0x00, 0x12, 0x04, 0xbe, 0x04, 0x20, 0x3a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08,
    0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbe, 0x04, 0x20, 0x28, 0x0a, 0x13, 0x0a,
    0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbe, 0x04,
    0x29, 0x2e, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xbe, 0x04, 0x2f, 0x35, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbe, 0x04, 0x38, 0x39, 0x0a, 0x12, 0x0a, 0x0a,
    0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xbf, 0x04, 0x20, 0x39,
    0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xbf, 0x04, 0x20, 0x28, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbf, 0x04, 0x29, 0x2e, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02,
    0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbf, 0x04, 0x2f, 0x34, 0x0a,
    0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xbf, 0x04, 0x37, 0x38, 0x0a, 0x22, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00,
    0x02, 0x02, 0x12, 0x04, 0xc0, 0x04, 0x20, 0x43, 0x22, 0x0e, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x70,
    0x65, 0x72, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08,
    0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc0, 0x04, 0x20, 0x28, 0x0a, 0x13, 0x0a,
    0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0xc0, 0x04,
    0x29, 0x33, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xc0, 0x04, 0x34, 0x3e, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc0, 0x04, 0x41, 0x42, 0x0a, 0x46, 0x0a, 0x0a,
    0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xc1, 0x04, 0x20, 0x3e,
    0x22, 0x32, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x54, 0x4c, 0x53, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xc1, 0x04, 0x20, 0x28, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03,
    0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc1, 0x04, 0x29, 0x2d, 0x0a, 0x13,
    0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc1,
    0x04, 0x2e, 0x39, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x02,
    0x03, 0x03, 0x12, 0x04, 0xc1, 0x04, 0x3c, 0x3d, 0x0a, 0x12, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x08,
    0x03, 0x00, 0x04, 0x01, 0x12, 0x06, 0xc4, 0x04, 0x18, 0xce, 0x04, 0x19, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x01, 0x12, 0x04, 0xc4, 0x04, 0x1d, 0x27, 0x0a,
    0x49, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x00, 0x12, 0x04, 0xc5,
    0x04, 0x20, 0x38, 0x22, 0x35, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x20, 0x68, 0x6f, 0x6c, 0x64,
    0x65, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x20,
    0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x70,
    0x61, 0x74, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02,
    0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc5, 0x04, 0x20, 0x32, 0x0a,
    0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x00, 0x02, 0x12, 0x04,
    0xc5, 0x04, 0x35, 0x37, 0x0a, 0x29, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01,
    0x02, 0x01, 0x12, 0x04, 0xc6, 0x04, 0x20, 0x29, 0x22, 0x15, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x72,
    0x65, 0x61, 0x64, 0x20, 0x6b, 0x65, 0x79, 0x2f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x0a, 0x0a,
    0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xc6, 0x04, 0x20, 0x24, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01,
    0x02, 0x01, 0x02, 0x12, 0x04, 0xc6, 0x04, 0x27, 0x28, 0x0a, 0x2a, 0x0a, 0x0a, 0x04, 0x02, 0x03,
    0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x02, 0x12, 0x04, 0xc7, 0x04, 0x20, 0x2a, 0x22, 0x16, 0x20,
    0x63, 0x61, 0x6e, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x2f, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x73, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04,
    0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc7, 0x04, 0x20, 0x25, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02,
    0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x02, 0x02, 0x12, 0x04, 0xc7, 0x04, 0x28, 0x29, 0x0a,
    0x12, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x03, 0x12, 0x04, 0xc8,
    0x04, 0x20, 0x2b, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xc8, 0x04, 0x20, 0x26, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08,
    0x03, 0x00, 0x04, 0x01, 0x02, 0x03, 0x02, 0x12, 0x04, 0xc8, 0x04, 0x29, 0x2a, 0x0a, 0x24, 0x0a,
    0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x04, 0x12, 0x04, 0xc9, 0x04, 0x20,
    0x2a, 0x22, 0x10, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x64, 0x6f, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6e,
    0x67, 0x65, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xc9, 0x04, 0x20, 0x25, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08,
    0x03, 0x00, 0x04, 0x01, 0x02, 0x04, 0x02, 0x12, 0x04, 0xc9, 0x04, 0x28, 0x29, 0x0a, 0x2d, 0x0a,
    0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x05, 0x12, 0x04, 0xca, 0x04, 0x20,
    0x2a, 0x22, 0x19, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x73, 0x65, 0x74, 0x20, 0x75, 0x70, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x61, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0a, 0x0a, 0x13, 0x0a, 0x0b,
    0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x05, 0x01, 0x12, 0x04, 0xca, 0x04, 0x20,
    0x25, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x05, 0x02,
    0x12, 0x04, 0xca, 0x04, 0x28, 0x29, 0x0a, 0x35, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00,
    0x04, 0x01, 0x02, 0x06, 0x12, 0x04, 0xcb, 0x04, 0x20, 0x2a, 0x22, 0x21, 0x20, 0x63, 0x61, 0x6e,
    0x20, 0x64, 0x6f, 0x20, 0x61, 0x20, 0x70, 0x65, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x65,
    0x65, 0x72, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x13, 0x0a,
    0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0xcb, 0x04,
    0x20, 0x25, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x06,
    0x02, 0x12, 0x04, 0xcb, 0x04, 0x28, 0x29, 0x0a, 0x21, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x08, 0x03,
    0x00, 0x04, 0x01, 0x02, 0x07, 0x12, 0x04, 0xcc, 0x04, 0x20, 0x2b, 0x22, 0x0d, 0x20, 0x63, 0x61,
    0x6e, 0x20, 0x67, 0x65, 0x74, 0x20, 0x6c, 0x6f, 0x67, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02,
    0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x07, 0x01, 0x12, 0x04, 0xcc, 0x04, 0x20, 0x26, 0x0a,
    0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x07, 0x02, 0x12, 0x04,
    0xcc, 0x04, 0x29, 0x2a, 0x0a, 0x41, 0x0a, 0x0a, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01,
    0x02, 0x08, 0x12, 0x04, 0xcd, 0x04, 0x20, 0x2d, 0x22, 0x2d, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x73,
    0x65, 0x74, 0x20, 0x75, 0x70, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69,
    0x74, 0x79, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x02, 0x03, 0x08, 0x03,
    0x00, 0x04, 0x01, 0x02, 0x08, 0x01, 0x12, 0x04, 0xcd, 0x04, 0x20, 0x28, 0x0a, 0x13, 0x0a, 0x0b,
    0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x04, 0x01, 0x02, 0x08, 0x02, 0x12, 0x04, 0xcd, 0x04, 0x2b,
    0x2c, 0x0a, 0xbb, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04,
    0xd3, 0x04, 0x18, 0x3a, 0x1a, 0xa8, 0x01, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x78, 0x50,
    0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b,
    0x65, 0x64, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x73, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68,
    0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x0a, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69,
    0x74, 0x79, 0x20, 0x28, 0x69, 0x66, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x29, 0x20,
    0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6f,
    0x72, 0x69, 0x74, 0x79, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x67, 0x72, 0x65,
    0x61, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x65, 0x71,
    0x75, 0x61, 0x6c, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x61, 0x78, 0x50,
    0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2e, 0x0a, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd3, 0x04,
    0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02, 0x04, 0x06, 0x12,
    0x04, 0xd3, 0x04, 0x21, 0x29, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08, 0x03, 0x00, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xd3, 0x04, 0x2a, 0x35, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x08,
    0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd3, 0x04, 0x38, 0x39, 0x0a, 0x9e, 0x02, 0x0a, 0x04,
    0x04, 0x02, 0x03, 0x09, 0x12, 0x06, 0xdc, 0x04, 0x08, 0xf9, 0x04, 0x09, 0x1a, 0x8d, 0x02, 0x20,
    0x50, 0x69, 0x6e, 0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x73, 0x70, 0x65, 0x63,
    0x69, 0x61, 0x6c, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0a, 0x20, 0x69, 0x73, 0x20,
    0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20,
    0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x2c, 0x20, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x65, 0x72, 0x61, 0x73, 0x65, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x6d, 0x75, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x54, 0x4c, 0x53, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x69, 0x74, 0x79,
    0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x72, 0x69, 0x74, 0x79, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
    0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x50, 0x69, 0x6e, 0x41, 0x75, 0x74, 0x68, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x02, 0x03, 0x09, 0x01, 0x12, 0x04, 0xdc, 0x04, 0x10, 0x1c, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x02, 0x03, 0x09, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x04, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x03, 0x09, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdd, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x03, 0x09, 0x02, 0x00, 0x06, 0x12, 0x04, 0xdd, 0x04, 0x19, 0x22, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x03, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdd, 0x04, 0x23, 0x2c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x03, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdd, 0x04, 0x2f, 0x30, 0x0a,
    0x10, 0x0a, 0x06, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x12, 0x06, 0xde, 0x04, 0x10, 0xf7, 0x04,
    0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x01, 0x12, 0x04, 0xde, 0x04,
    0x15, 0x1e, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04,
    0xdf, 0x04, 0x18, 0x2b, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xdf, 0x04, 0x18, 0x25, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04,
    0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xdf, 0x04, 0x28, 0x2a, 0x0a, 0x32, 0x0a, 0x08, 0x04, 0x02,
    0x03, 0x09, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xe2, 0x04, 0x18, 0x29, 0x1a, 0x20, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x70, 0x69, 0x6e, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x75, 0x6e, 0x6c, 0x6f,
    0x63, 0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0a, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe2, 0x04, 0x18,
    0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04,
    0xe2, 0x04, 0x27, 0x28, 0x0a, 0xb9, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02,
    0x02, 0x12, 0x04, 0xe8, 0x04, 0x18, 0x27, 0x1a, 0xa6, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65,
    0x76, 0x69, 0x63, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,
    0x64, 0x65, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20,
    0x64, 0x61, 0x74, 0x61, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x20,
    0x66, 0x72, 0x6f, 0x6d, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20,
    0x70, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20,
    0x61, 0x6e, 0x64, 0x0a, 0x20, 0x64, 0x69, 0x73, 0x61, 0x73, 0x73, 0x65, 0x6d, 0x62, 0x6c, 0x79,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x0a,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe8,
    0x04, 0x18, 0x22, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02, 0x02, 0x02,
    0x12, 0x04, 0xe8, 0x04, 0x25, 0x26, 0x0a, 0x86, 0x01, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x09, 0x04,
    0x00, 0x02, 0x03, 0x12, 0x04, 0xf1, 0x04, 0x18, 0x28, 0x1a, 0x74, 0x20, 0x45, 0x72, 0x61, 0x73,
    0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x20, 0x54, 0x68,
    0x69, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65,
    0x0a, 0x20, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x69, 0x6d,
    0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x69, 0x74, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x66, 0x61, 0x73, 0x74,
    0x65, 0x72, 0x0a, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63,
    0x75, 0x72, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf1, 0x04,
    0x18, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12,
    0x04, 0xf1, 0x04, 0x26, 0x27, 0x0a, 0x70, 0x0a, 0x08, 0x04, 0x02, 0x03, 0x09, 0x04, 0x00, 0x02,
    0x04, 0x12, 0x04, 0xf6, 0x04, 0x18, 0x2f, 0x1a, 0x5e, 0x20, 0x45, 0x72, 0x61, 0x73, 0x65, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x20,
    0x77, 0x61, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x0a, 0x20, 0x70,
    0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6c, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x64, 0x69, 0x73, 0x61, 0x73, 0x73, 0x65, 0x6d, 0x62, 0x6c, 0x79, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x0a, 0x20, 0x77, 0x69,
    0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02, 0x03, 0x09, 0x04,
    0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xf6, 0x04, 0x18, 0x2a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x02,
    0x03, 0x09, 0x04, 0x00, 0x02, 0x04, 0x02, 0x12, 0x04, 0xf6, 0x04, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x02, 0x04, 0x01, 0x12, 0x06, 0xfb, 0x04, 0x08, 0x81, 0x05, 0x09, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x02, 0x04, 0x01, 0x01, 0x12, 0x04, 0xfb, 0x04, 0x0d, 0x15, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x02, 0x04, 0x01, 0x02, 0x00, 0x12, 0x04, 0xfc, 0x04, 0x10, 0x1b, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfc, 0x04, 0x10, 0x16, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x00, 0x02, 0x12, 0x04, 0xfc, 0x04, 0x19, 0x1a, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x02, 0x04, 0x01, 0x02, 0x01, 0x12, 0x04, 0xfd, 0x04, 0x10, 0x1b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfd, 0x04, 0x10, 0x16, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x01, 0x02, 0x12, 0x04, 0xfd, 0x04, 0x19, 0x1a,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x01, 0x02, 0x02, 0x12, 0x04, 0xfe, 0x04, 0x10, 0x1a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xfe, 0x04, 0x10,
    0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x02, 0x02, 0x12, 0x04, 0xfe, 0x04,
    0x18, 0x19, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x01, 0x02, 0x03, 0x12, 0x04, 0xff, 0x04,
    0x10, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xff,
    0x04, 0x10, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x03, 0x02, 0x12, 0x04,
    0xff, 0x04, 0x19, 0x1a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x01, 0x02, 0x04, 0x12, 0x04,
    0x80, 0x05, 0x10, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x04, 0x01, 0x12,
    0x04, 0x80, 0x05, 0x10, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x01, 0x02, 0x04, 0x02,
    0x12, 0x04, 0x80, 0x05, 0x1a, 0x1b, 0x0a, 0x1a, 0x0a, 0x04, 0x04, 0x02, 0x04, 0x02, 0x12, 0x06,
    0x84, 0x05, 0x08, 0x8d, 0x05, 0x09, 0x1a, 0x0a, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68,
    0x6d, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x02, 0x04, 0x02, 0x01, 0x12, 0x04, 0x84, 0x05, 0x0d,
    0x16, 0x0a, 0x38, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x02, 0x02, 0x00, 0x12, 0x04, 0x85, 0x05, 0x10,
    0x27, 0x22, 0x28, 0x20, 0x4d, 0x75, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x66, 0x69,
    0x72, 0x73, 0x74, 0x2c, 0x20, 0x73, 0x6f, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20,
    0x69, 0x73, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x05, 0x10, 0x21, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x04, 0x02, 0x02, 0x00, 0x02, 0x12, 0x04, 0x85, 0x05, 0x24, 0x26, 0x0a, 0x1a, 0x0a,
    0x06, 0x04, 0x02, 0x04, 0x02, 0x02, 0x01, 0x12, 0x04, 0x86, 0x05, 0x10, 0x19, 0x22, 0x0a, 0x20,
    0x73, 0x65, 0x65, 0x20, 0x4e, 0x49, 0x53, 0x54, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04,
    0x02, 0x02, 0x01, 0x01, 0x12, 0x04, 0x86, 0x05, 0x10, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x04, 0x02, 0x02, 0x01, 0x02, 0x12, 0x04, 0x86, 0x05, 0x17, 0x18, 0x0a, 0x1a, 0x0a, 0x06, 0x04,
    0x02, 0x04, 0x02, 0x02, 0x02, 0x12, 0x04, 0x87, 0x05, 0x10, 0x19, 0x22, 0x0a, 0x20, 0x73, 0x65,
    0x65, 0x20, 0x4e, 0x49, 0x53, 0x54, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x02, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x87, 0x05, 0x10, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x02,
    0x02, 0x02, 0x02, 0x12, 0x04, 0x87, 0x05, 0x17, 0x18, 0x0a, 0x53, 0x0a, 0x06, 0x04, 0x02, 0x04,
    0x02, 0x02, 0x03, 0x12, 0x04, 0x88, 0x05, 0x10, 0x19, 0x22, 0x43, 0x20, 0x73, 0x65, 0x65, 0x20,
    0x4e, 0x49, 0x53, 0x54, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x67, 0x20, 0x64, 0x65, 0x74, 0x65,
    0x72, 0x6d, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74,
    0x68, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x04, 0x02, 0x02, 0x03, 0x01, 0x12, 0x04, 0x88, 0x05, 0x10, 0x14, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x02, 0x02, 0x03, 0x02, 0x12, 0x04, 0x88, 0x05, 0x17, 0x18,
    0x0a, 0x44, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x02, 0x02, 0x04, 0x12, 0x04, 0x89, 0x05, 0x10, 0x1a,
    0x22, 0x34, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x52, 0x43, 0x33, 0x32, 0x20, 0x69, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x20, 0x45, 0x74, 0x68,
    0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x43, 0x52, 0x43, 0x33, 0x32, 0x2e, 0x20, 0x53, 0x65, 0x65,
    0x20, 0x49, 0x45, 0x45, 0x45, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x02, 0x02, 0x04,
    0x01, 0x12, 0x04, 0x89, 0x05, 0x10, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x02, 0x02,
    0x04, 0x02, 0x12, 0x04, 0x89, 0x05, 0x18, 0x19, 0x0a, 0x20, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x02,
    0x02, 0x05, 0x12, 0x04, 0x8a, 0x05, 0x10, 0x1a, 0x22, 0x10, 0x20, 0x54, 0x68, 0x65, 0x20, 0x43,
    0x52, 0x43, 0x20, 0x69, 0x73, 0x20, 0x2e, 0x2e, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x04, 0x02, 0x02, 0x05, 0x01, 0x12, 0x04, 0x8a, 0x05, 0x10, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x04, 0x02, 0x02, 0x05, 0x02, 0x12, 0x04, 0x8a, 0x05, 0x18, 0x19, 0x0a, 0x1f, 0x0a, 0x04,
    0x04, 0x02, 0x04, 0x03, 0x12, 0x06, 0x90, 0x05, 0x08, 0xc0, 0x05, 0x09, 0x1a, 0x0f, 0x6f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x6f, 0x64, 0x65, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x02, 0x04, 0x03, 0x01, 0x12, 0x04, 0x90, 0x05, 0x0d, 0x18, 0x0a, 0x38, 0x0a, 0x06,
    0x04, 0x02, 0x04, 0x03, 0x02, 0x00, 0x12, 0x04, 0x91, 0x05, 0x10, 0x2a, 0x22, 0x28, 0x20, 0x4d,
    0x75, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x2c, 0x20,
    0x73, 0x6f, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e,
    0x76, 0x61, 0x6c, 0x69, 0x64, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x91, 0x05, 0x10, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02,
    0x00, 0x02, 0x12, 0x04, 0x91, 0x05, 0x27, 0x29, 0x0a, 0x1e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x01, 0x12, 0x04, 0x92, 0x05, 0x10, 0x18, 0x22, 0x0e, 0x67, 0x65, 0x74, 0x20, 0x6f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x92, 0x05, 0x10, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04,
    0x03, 0x02, 0x01, 0x02, 0x12, 0x04, 0x92, 0x05, 0x16, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02,
    0x04, 0x03, 0x02, 0x02, 0x12, 0x04, 0x93, 0x05, 0x10, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x04, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0x93, 0x05, 0x10, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x04, 0x03, 0x02, 0x02, 0x02, 0x12, 0x04, 0x93, 0x05, 0x1f, 0x20, 0x0a, 0x1e, 0x0a, 0x06,
    0x04, 0x02, 0x04, 0x03, 0x02, 0x03, 0x12, 0x04, 0x94, 0x05, 0x10, 0x18, 0x22, 0x0e, 0x70, 0x75,
    0x74, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x04, 0x03, 0x02, 0x03, 0x01, 0x12, 0x04, 0x94, 0x05, 0x10, 0x13, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x03, 0x02, 0x12, 0x04, 0x94, 0x05, 0x16, 0x17, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x04, 0x12, 0x04, 0x95, 0x05, 0x10, 0x21, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x04, 0x01, 0x12, 0x04, 0x95, 0x05, 0x10, 0x1c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x04, 0x02, 0x12, 0x04, 0x95, 0x05, 0x1f, 0x20,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x05, 0x12, 0x04, 0x96, 0x05, 0x10, 0x1b,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x05, 0x01, 0x12, 0x04, 0x96, 0x05, 0x10,
    0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x05, 0x02, 0x12, 0x04, 0x96, 0x05,
    0x19, 0x1a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x06, 0x12, 0x04, 0x97, 0x05,
    0x10, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x06, 0x01, 0x12, 0x04, 0x97,
    0x05, 0x10, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x06, 0x02, 0x12, 0x04,
    0x97, 0x05, 0x22, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x07, 0x12, 0x04,
    0x98, 0x05, 0x10, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x07, 0x01, 0x12,
    0x04, 0x98, 0x05, 0x10, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x07, 0x02,
    0x12, 0x04, 0x98, 0x05, 0x1a, 0x1b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x08,
    0x12, 0x04, 0x99, 0x05, 0x10, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x08,
    0x01, 0x12, 0x04, 0x99, 0x05, 0x10, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02,
    0x08, 0x02, 0x12, 0x04, 0x99, 0x05, 0x23, 0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x09, 0x12, 0x04, 0x9a, 0x05, 0x10, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x09, 0x01, 0x12, 0x04, 0x9a, 0x05, 0x10, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04,
    0x03, 0x02, 0x09, 0x02, 0x12, 0x04, 0x9a, 0x05, 0x1e, 0x20, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02,
    0x04, 0x03, 0x02, 0x0a, 0x12, 0x04, 0x9b, 0x05, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x04, 0x03, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x9b, 0x05, 0x10, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x04, 0x03, 0x02, 0x0a, 0x02, 0x12, 0x04, 0x9b, 0x05, 0x27, 0x28, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x02, 0x04, 0x03, 0x02, 0x0b, 0x12, 0x04, 0x9c, 0x05, 0x10, 0x21, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x04, 0x03, 0x02, 0x0b, 0x01, 0x12, 0x04, 0x9c, 0x05, 0x10, 0x1b, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x0b, 0x02, 0x12, 0x04, 0x9c, 0x05, 0x1e, 0x20, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x0c, 0x12, 0x04, 0x9d, 0x05, 0x10, 0x2a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x0c, 0x01, 0x12, 0x04, 0x9d, 0x05, 0x10, 0x24, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x0c, 0x02, 0x12, 0x04, 0x9d, 0x05, 0x27, 0x29,
    0x0a, 0x34, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x0d, 0x12, 0x04, 0xa0, 0x05, 0x10, 0x20,
    0x1a, 0x24, 0x20, 0x31, 0x33, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x31, 0x34, 0x20, 0x61, 0x72, 0x65,
    0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2c, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x75, 0x73, 0x65, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x0d,
    0x01, 0x12, 0x04, 0xa0, 0x05, 0x10, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02,
    0x0d, 0x02, 0x12, 0x04, 0xa0, 0x05, 0x1d, 0x1f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x0e, 0x12, 0x04, 0xa1, 0x05, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x0e, 0x01, 0x12, 0x04, 0xa1, 0x05, 0x10, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04,
    0x03, 0x02, 0x0e, 0x02, 0x12, 0x04, 0xa1, 0x05, 0x26, 0x28, 0x0a, 0x3d, 0x0a, 0x06, 0x04, 0x02,
    0x04, 0x03, 0x02, 0x0f, 0x12, 0x04, 0xa4, 0x05, 0x10, 0x1b, 0x1a, 0x2d, 0x20, 0x31, 0x37, 0x2c,
    0x20, 0x31, 0x38, 0x2c, 0x20, 0x31, 0x39, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x32, 0x30, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2c, 0x20, 0x64, 0x6f,
    0x20, 0x6e, 0x6f, 0x74, 0x20, 0x75, 0x73, 0x65, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04,
    0x03, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xa4, 0x05, 0x10, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x04, 0x03, 0x02, 0x0f, 0x02, 0x12, 0x04, 0xa4, 0x05, 0x18, 0x1a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x02, 0x04, 0x03, 0x02, 0x10, 0x12, 0x04, 0xa5, 0x05, 0x10, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x04, 0x03, 0x02, 0x10, 0x01, 0x12, 0x04, 0xa5, 0x05, 0x10, 0x1e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x04, 0x03, 0x02, 0x10, 0x02, 0x12, 0x04, 0xa5, 0x05, 0x21, 0x23, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x11, 0x12, 0x04, 0xa6, 0x05, 0x10, 0x1c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x11, 0x01, 0x12, 0x04, 0xa6, 0x05, 0x10, 0x16, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x11, 0x02, 0x12, 0x04, 0xa6, 0x05, 0x19, 0x1b, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x12, 0x12, 0x04, 0xa7, 0x05, 0x10, 0x25, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x12, 0x01, 0x12, 0x04, 0xa7, 0x05, 0x10, 0x1f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x12, 0x02, 0x12, 0x04, 0xa7, 0x05, 0x22,
    0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x13, 0x12, 0x04, 0xa8, 0x05, 0x10,
    0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x13, 0x01, 0x12, 0x04, 0xa8, 0x05,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x13, 0x02, 0x12, 0x04, 0xa8,
    0x05, 0x1b, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x14, 0x12, 0x04, 0xa9,
    0x05, 0x10, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x14, 0x01, 0x12, 0x04,
    0xa9, 0x05, 0x10, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x14, 0x02, 0x12,
    0x04, 0xa9, 0x05, 0x24, 0x26, 0x0a, 0x2c, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x15, 0x12,
    0x04, 0xaa, 0x05, 0x10, 0x23, 0x22, 0x1c, 0x70, 0x65, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x70,
    0x65, 0x65, 0x72, 0x20, 0x70, 0x75, 0x73, 0x68, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x15, 0x01, 0x12, 0x04,
    0xaa, 0x05, 0x10, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x15, 0x02, 0x12,
    0x04, 0xaa, 0x05, 0x20, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x16, 0x12,
    0x04, 0xab, 0x05, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x16, 0x01,
    0x12, 0x04, 0xab, 0x05, 0x10, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x16,
    0x02, 0x12, 0x04, 0xab, 0x05, 0x29, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02,
    0x17, 0x12, 0x04, 0xac, 0x05, 0x10, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02,
    0x17, 0x01, 0x12, 0x04, 0xac, 0x05, 0x10, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x17, 0x02, 0x12, 0x04, 0xac, 0x05, 0x17, 0x19, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04,
    0x03, 0x02, 0x18, 0x12, 0x04, 0xad, 0x05, 0x10, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04,
    0x03, 0x02, 0x18, 0x01, 0x12, 0x04, 0xad, 0x05, 0x10, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02,
    0x04, 0x03, 0x02, 0x18, 0x02, 0x12, 0x04, 0xad, 0x05, 0x20, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x02, 0x04, 0x03, 0x02, 0x19, 0x12, 0x04, 0xae, 0x05, 0x10, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x02, 0x04, 0x03, 0x02, 0x19, 0x01, 0x12, 0x04, 0xae, 0x05, 0x10, 0x1c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x02, 0x04, 0x03, 0x02, 0x19, 0x02, 0x12, 0x04, 0xae, 0x05, 0x1f, 0x21, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1a, 0x12, 0x04, 0xaf, 0x05, 0x10, 0x2b, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1a, 0x01, 0x12, 0x04, 0xaf, 0x05, 0x10, 0x25, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1a, 0x02, 0x12, 0x04, 0xaf, 0x05, 0x28, 0x2a, 0x0a,
    0x3d, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1b, 0x12, 0x04, 0xb2, 0x05, 0x10, 0x1b, 0x1a,
    0x15, 0x20, 0x33, 0x33, 0x2c, 0x20, 0x33, 0x34, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x73,
    0x65, 0x72, 0x76, 0x65, 0x64, 0x0a, 0x22, 0x16, 0x20, 0x50, 0x69, 0x6e, 0x20, 0x62, 0x61, 0x73,
    0x65, 0x64, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1b, 0x01, 0x12, 0x04, 0xb2, 0x05, 0x10, 0x15, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1b, 0x02, 0x12, 0x04, 0xb2, 0x05, 0x18, 0x1a,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1c, 0x12, 0x04, 0xb3, 0x05, 0x10, 0x24,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1c, 0x01, 0x12, 0x04, 0xb3, 0x05, 0x10,
    0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1c, 0x02, 0x12, 0x04, 0xb3, 0x05,
    0x21, 0x23, 0x0a, 0xb1, 0x01, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1d, 0x12, 0x04, 0xb8,
    0x05, 0x10, 0x1f, 0x1a, 0xa0, 0x01, 0x20, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x20, 0x73, 0x63, 0x61,
    0x6e, 0x20, 0x69, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x64, 0x61, 0x74, 0x61,
    0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20, 0x61, 0x6e,
    0x64, 0x0a, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x65, 0x6e, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x72, 0x69, 0x74, 0x79, 0x20, 0x69,
    0x73, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64,
    0x65, 0x76, 0x69, 0x63, 0x65, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x65,
    0x6e, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x65, 0x6e, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x72,
    0x69, 0x74, 0x79, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x72,
    0x72, 0x65, 0x63, 0x74, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1d,
    0x01, 0x12, 0x04, 0xb8, 0x05, 0x10, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02,
    0x1d, 0x02, 0x12, 0x04, 0xb8, 0x05, 0x1c, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x1e, 0x12, 0x04, 0xb9, 0x05, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03,
    0x02, 0x1e, 0x01, 0x12, 0x04, 0xb9, 0x05, 0x10, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04,
    0x03, 0x02, 0x1e, 0x02, 0x12, 0x04, 0xb9, 0x05, 0x25, 0x27, 0x0a, 0xc6, 0x01, 0x0a, 0x06, 0x04,
    0x02, 0x04, 0x03, 0x02, 0x1f, 0x12, 0x04, 0xbe, 0x05, 0x10, 0x23, 0x1a, 0xb5, 0x01, 0x20, 0x54,
    0x68, 0x69, 0x73, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x73, 0x20, 0x6f, 0x70, 0x74,
    0x69, 0x6d, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x6e, 0x67, 0x73, 0x20,
    0x6c, 0x69, 0x6b, 0x65, 0x0a, 0x20, 0x64, 0x65, 0x66, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x63, 0x74, 0x69, 0x6f,
    0x6e, 0x2c, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
    0x6f, 0x6e, 0x0a, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x69,
    0x6e, 0x67, 0x73, 0x20, 0x61, 0x63, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x69, 0x73, 0x68, 0x65, 0x64,
    0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x65, 0x64, 0x69, 0x61,
    0x20, 0x6f, 0x70, 0x74, 0x69, 0x6d, 0x69, 0x7a, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
    0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1f, 0x01, 0x12, 0x04,
    0xbe, 0x05, 0x10, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x1f, 0x02, 0x12,
    0x04, 0xbe, 0x05, 0x20, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x20, 0x12,
    0x04, 0xbf, 0x05, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x20, 0x01,
    0x12, 0x04, 0xbf, 0x05, 0x10, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x02, 0x04, 0x03, 0x02, 0x20,
    0x02, 0x12, 0x04, 0xbf, 0x05, 0x29, 0x2b,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
